<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LuoRongLuoRong</title>
  
  <subtitle>博客</subtitle>
  <link href="https://luorongluorong.github.io/atom.xml" rel="self"/>
  
  <link href="https://luorongluorong.github.io/"/>
  <updated>2023-03-08T06:25:12.725Z</updated>
  <id>https://luorongluorong.github.io/</id>
  
  <author>
    <name>LuoRongLuoRong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从波提切利到梵高——英国国家美术馆珍藏展</title>
    <link href="https://luorongluorong.github.io/2023/02/15/arts/museum_exhibition_bottlicelli_to_van_gogh/"/>
    <id>https://luorongluorong.github.io/2023/02/15/arts/museum_exhibition_bottlicelli_to_van_gogh/</id>
    <published>2023-02-15T09:21:11.000Z</published>
    <updated>2023-03-08T06:25:12.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从波提切利到梵高——英国国家美术馆珍藏展"><a href="#从波提切利到梵高——英国国家美术馆珍藏展" class="headerlink" title="从波提切利到梵高——英国国家美术馆珍藏展"></a>从波提切利到梵高——英国国家美术馆珍藏展</h1><blockquote><p><a href="https://mp.weixin.qq.com/s/tRktZH3iKV2wWOFyKq2g3w">https://mp.weixin.qq.com/s/tRktZH3iKV2wWOFyKq2g3w</a></p></blockquote><p>Botticelli to Van Gogh</p><p>Masterpieces from the National Gallery, London</p><blockquote><p>2023年1月17日至5月7日，上海博物馆首度联手英国国家美术馆，推出“对话世界”文物艺术大展系列的第二个展览——“从波提切利到梵高：英国国家美术馆珍藏展”。展览通过 52 件大师杰作，为观众奉上一场视觉盛宴，讲述欧洲绘画的故事。<br>本次展览中，观众可以欣赏到波提切利、拉斐尔、提香、戈塞特、卡拉瓦乔、普桑、克劳德、凡·代克，伦勃朗、卡纳莱托、康斯特布尔、透纳、塞尚、高更、马奈、莫奈以及梵高等艺术史中如雷贯耳的大师杰作；了解到意大利文艺复兴、北方文艺复兴、威尼斯画派、样式主义、巴洛克、荷兰画派、洛可可、古典主义、浪漫主义、印象派、后印象派等熠熠生辉的艺术流派。这也是上海博物馆馆庆70周年为公众奉上的重磅展览。观众们无需前往伦敦,便可欣赏到欧洲艺术巨匠的绘画杰作。</p></blockquote><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_1_poster.jpg" alt="Alt text"></p><p>漫步展厅，眼前呈现的仿佛是一片欧洲油画史的缩影。展览第一至第五单元，主要展现了从早期文艺复兴至巴洛克时期（15世纪至17世纪）的绘画作品。那么绘画是如何成为艺术的？欧洲油画的技法从何而来？当时艺术行业的生产模式又是怎样？透过作品，亲近艺术史，本期我们将与大家一起细读欣赏英国国家美术馆珍藏展前五单元的内容。</p><blockquote><p>找一找本次展览的植物和屋顶。</p></blockquote><p><a href="https://mp.weixin.qq.com/s/m5Lpz6fwBrgzZLTfCs8Z2A">https://mp.weixin.qq.com/s/m5Lpz6fwBrgzZLTfCs8Z2A</a></p><h1 id="追溯欧洲绘画传统"><a href="#追溯欧洲绘画传统" class="headerlink" title="追溯欧洲绘画传统"></a>追溯欧洲绘画传统</h1><p>欧洲早在古希腊、古罗马时期就有类似于今日的绘画艺术，但岁月悠远，盛况难以悉知。今人所熟悉的欧洲绘画传统，兴起于15-16世纪的意大利及欧洲北方。这一时期艺术家开始为公众所瞩目，出现了艺术收藏，有人撰写画论和艺术家传记，欧洲最早的美术学院也应运而生，简而言之，绘画开始从手艺转变为艺术。</p><p>伴随着艺术的觉醒，绘画技术突飞猛进，油画逐渐取代坦培拉（即蛋彩画，Tempera）成为优势画种，速写也首次被艺术家用来记录灵感，这时期有许多艺术家投入到对透视和解剖的研究中，迫不及待地把新知识用于创作。就在短短的两三百年间，欧洲社会对绘画的态度、画家的精神风貌以及绘画技术都发生了惊人的改变，后世怀着敬畏之心把这一时期称为“文艺复兴”（Renaissance），是不无道理的。</p><p>在本次展览第一单元中，波提切利、梅西那等画家展现了15世纪意大利早期文艺复兴的生机勃勃。若对比梅西那《书房中的圣哲罗姆》与前代画作，不难看出经过15世纪大师们的努力，两个绘画问题已经得到了开创性的解决。首先是单个人物的造型问题，即怎么把一个人物画得浑圆立体、有呼吸、有质感；然后是画面空间问题，即怎么把人物与背景之间的关系画得令人信服的问题。 </p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_2.jpg" alt="Alt text"></p><p>《书房中的圣哲罗姆》安托内罗·达·梅西那</p><p>约1475年，石灰板油画</p><p>© The National Gallery, London</p><h1 id="从坦培拉（蛋彩画）到油画"><a href="#从坦培拉（蛋彩画）到油画" class="headerlink" title="从坦培拉（蛋彩画）到油画"></a>从坦培拉（蛋彩画）到油画</h1><p>文艺复兴时期的大量画作都是依附于建筑和器物的壁画、祭坛画等，能来到中国观众面前的架上绘画杰作尚属少数，其基材是木板与画布兼用，技法是坦培拉与油画兼用，这一时期是坦培拉技法最为辉煌的时期，也是坦培拉向油画过渡的时期。</p><p><strong>坦培拉技法</strong>是主要以蛋黄加水作为媒介剂来调和颜料的一种作画技法，它色彩透明，干燥后坚固稳定，很适合湿壁画（Fresco）的要求，但由于干燥速度太快，使用时难以调色，只能通过往单一颜色中调白、调黑来控制明度的变化，像素描排线那样描绘，逐笔依次形成明暗过渡的素描关系。这种技法在佛罗伦萨有很强的传统，由于它天然倾向于用素描和线条来建构画面，因此<em>佛罗伦萨画派</em>也被称为“<strong>素描派</strong>”。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_3.jpg" alt="Alt text"></p><p>《圣泽诺比乌斯的三个奇迹》 桑德罗·波提切利</p><p>约1500年，木板蛋彩画</p><p>© The National Gallery, London</p><p>油画是以油作为媒介来调和颜料的作画技法，用于罩染和厚涂均合适，且干燥速度适当，便于调色，经得住反复修改和塑造。油画是北方的传统技法，本次参展的戈塞特、昆廷·马西斯等北方大师都用油画技法，他们的作品往往色彩饱满，刻画精细，对皮毛、布料、砖石等材料的质感表现也属一流。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_4.jpg" alt="Alt text"></p><p>《年轻公主（丹麦多萝西娅？）》 扬·戈塞特</p><p>约1530-1532年，橡木板油画</p><p>© The National Gallery, London</p><p>大约自15世纪中期以后，意大利画家为了拓展坦培拉的表现力，普遍在坦培拉底色之上罩染油性色层，发展出<strong>坦培拉与油画技术相结合</strong>的技法。当时威尼斯与北方画家接触较密切，是南方最喜欢布面油画的地区，<em>威尼斯画派</em>的代表人物提香、丁托列托等强调肌肤色彩的生动感，对轮廓线和服饰进行虚实处理，也开始注意笔触的表现力，形成了与讲求素描的佛罗伦萨派不同的艺术取向，被称为“<strong>色彩派</strong>”，两派艺术取向不同，由此开启了持续至19世纪的素描与色彩之争。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_5.jpg" alt="Alt text"></p><p>《女子肖像》提香</p><p>约1510-1512年，布面油画</p><p>© The National Gallery, London</p><h1 id="行业的模式：作坊与委托订制"><a href="#行业的模式：作坊与委托订制" class="headerlink" title="行业的模式：作坊与委托订制"></a>行业的模式：作坊与委托订制</h1><p>在文艺复兴社会的普遍观念中，艺术家仍保留着手艺人的大部分特点。当时展览、拍卖等艺术市场机制还没有出现，艺术家的主要行业模式是<strong>委托订制</strong>（Commission），即先由委托人（Patron）提出要求，画家再根据要求完成画作。画家多半是本地行会的注册师傅，他组建自己的作坊，招收学徒作为助手。学徒平日里磨制颜料，熬胶放稿，从事各种杂务，也练习作画，他们的目标是有朝一日也成为独立行业的师傅。作坊既是生产单位，也是教学单位，大型绘画尤其依赖学徒的协助，最终交付的作品，有些只有关键部分是师傅亲笔所作，其他部分常常交由学徒完成。观念转变是一个漫长的过程，从16世纪开始，大约经过三百年的时间，作坊师傅变成了画室里单打独斗的艺术家，不过委托订制从未消失。在15世纪大师的作坊里，走出了文艺复兴盛期的诸位巨匠。米开朗基罗出自吉兰达约的作坊；拉斐尔出自佩鲁吉诺的作坊；提香出自乔瓦尼·贝利尼的作坊。</p><p>16世纪，米开朗基罗和拉斐尔先后前往罗马，为天主教世界最大的委托人、拥有最重要古典雕刻收藏的教皇工作。本次展出的拉斐尔《圣母子与施洗者圣约翰（加瓦圣母）》，大约作于他到达罗马不久后，当时他正处于风格转变的关头，在随后几年中他以稳健有力、和谐典雅的新风格完成了签字厅（Stanza della Segnatura）壁画，成为照耀百代的艺术伟迹。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_6.jpg" alt="Alt text"></p><p>《圣母子与施洗者圣约翰（加瓦圣母）》 拉斐尔</p><p>约1510-1511年，木板油画</p><p>© The National Gallery, London</p><h1 id="17-世纪欧洲艺术中心"><a href="#17-世纪欧洲艺术中心" class="headerlink" title="17 世纪欧洲艺术中心"></a>17 世纪欧洲艺术中心</h1><p>17世纪的艺术家面对文艺复兴的巨大遗产，也面对着天主教和新教分裂的欧洲。意大利已经成为欧洲艺术的中心，法国和西班牙王室很久以来就礼聘意大利艺术家服务于自己的宫廷，两国的年轻艺术家也把游学意大利看作成才的必由之路。</p><p>普桑毕生的大部分时间都在罗马度过，他虽是法国人，却只有待在意大利的古典废墟中才觉得回到了家，他是17世纪古典主义和素描派的代表人物，他的画有种永恒的秩序感，得到后印象主义大师塞尚的盛赞。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_7.jpg" alt="Alt text"></p><p>《酒神的养育》 尼古拉·普桑</p><p>约1628年，布面油画</p><p>© The National Gallery, London</p><p>另一位人称“克劳德·洛兰”的法国人同样以意大利为家，他是风景画发展中的一个重要人物，探索过户外作画，还把废墟引入画中，他擅长用晨曦和落霞赋予画面一层滤镜般的色调，“克劳德式的风景”成了一个特定的审美意象，强烈地影响了18世纪的英国美学。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_8.jpg" alt="Alt text"></p><p>《圣乌苏拉登船的海港》 克劳德</p><p>1641年，布面油画</p><p>© The National Gallery, London</p><h1 id="油画语言的发展：笔触与表现"><a href="#油画语言的发展：笔触与表现" class="headerlink" title="油画语言的发展：笔触与表现"></a>油画语言的发展：笔触与表现</h1><p>17世纪北方新教地区的艺术家失去了天主教会的大宗订件，一部分画家离开本地前往国外，鲁本斯的学生<strong>凡·代克</strong>即在英国为朝臣贵族画肖像。刚刚独立的荷兰共和国是这旧世界中的新国家，在那里，新的委托人饶有兴致地欣赏着风景、静物、室内景和风俗画等新题材。17世纪，<strong>布面油画</strong>取代木板坦培拉成为具有统治地位的画种，正是在这个世纪里，荷兰最具有影响的画家<strong>伦勃朗</strong>与<strong>鲁本斯</strong>、<strong>委拉斯贵兹</strong>一道，发扬了油画笔触的表现力，完善了油画语言的武库。</p><p>委拉斯贵兹以“直接画法”出名，所谓直接画法就是彻底抛弃三百年来的坦培拉底色，用纯粹的油画颜料直接作画，他第一个这样做，使得油画完全摆脱了坦培拉。委拉斯贵兹在画家生涯的各个时期用过不同画法，他四十多岁效力于西班牙费利佩四世宫廷时，用<strong>直接画法</strong>画了一批名作，包括本次参展的《费尔南多总主教像》。此画以黑红两个大色块衬托出人物的面容，摒弃精致的线条，略去服饰和衬布的细部，痛快地画出而不是制作出主教的神情，潇洒的笔触留在画面上，成为欣赏的对象。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_9.jpg" alt="Alt text"></p><p>《费尔南多总主教肖像》 迭戈·委拉斯贵兹</p><p>1640-1645年，布面油画</p><p>© The National Gallery, London</p><p>伦勃朗是整个绘画史上最杰出的肖像画家之一，他年轻时候有过一段称心岁月，中年迭遭变故，晚岁贫病交加，人们相信他的苦难经历给他的肖像画注入了忧患和深沉。他一生留下多幅自画像，本次参展的《63岁的自画像》以强烈的光影对比突出面容，用阔大的笔触和厚涂法（Impasto），寥寥数笔便塑造出结实的块面。其利用光影对比来建构画面的手法，可以通过卡拉瓦乔，追溯到莱奥纳尔多·达·芬奇的明暗法（Chiaroscuro）。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_10.jpg" alt="Alt text"><br>《63岁的自画像》 伦勃朗</p><p>1669年，布面油画</p><p>© The National Gallery, London</p><p>16世纪威尼斯画派的画家就意识到笔触的表现力，但直到伦勃朗和委拉斯贵兹的时代，笔触才广泛为画家所接受。笔触的模糊性有时比清晰的刻画更有余味，它什么都不像，却又什么都像，它调动观众的想象参与到欣赏中去，补充画家实际上并没有画出的东西。这是一种高超的艺术手法，优秀的文学家也都知道怎么用。除此之外，有意识地把笔触留在画面上，留下作画过程的痕迹，承认这是一幅画而非画中所描绘的现实，让观众体验艺术与现实之间的来回转换——这种态度使绘画超越了再现而成为表现。<strong>绘画语言本身成为欣赏对象，这正是艺术成为艺术的关键所在。</strong></p><h1 id="雅游时代"><a href="#雅游时代" class="headerlink" title="雅游时代"></a>雅游时代</h1><p>一个年轻人只有经历过意大利旅行，瞻仰过那里的古典遗迹和艺术杰作，才算完成了教育——17世纪就有英国人怀着这样的想法踏上旅程，到18世纪这终于成为社会共识，成千上万的英国富家子弟带着家人的叮嘱，在称职或不称职的“伴游导师”（Tutor）陪同下，启程汇入雅游（即壮游，Grand Tour）的洪流。雅游最初主要是英国青年前往意大利的教育旅行，但后来欧洲大陆人和美国人也都参加进来。雅游的内涵一直在变化，但在18世纪的雅游中，艺术成为一个突出的主题。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_11.jpg" alt="Alt text"></p><p>《约翰·斯图亚特勋爵与其兄弟伯纳德·斯图亚特勋爵》 安东尼·凡·代克</p><p>约1638年，布面油画</p><p>© The National Gallery, London</p><p>典型的雅游路线是从英国多弗尔渡海至法国加莱，从那里换乘驿马车前往巴黎，向南经瑞士、萨伏伊一带翻越阿尔卑斯山来到波河平原，随后前往威尼斯游历一段时间，再取道佛罗伦萨抵达旅行的目的地罗马。回程不走原路的，或经德国、荷兰再返回英国。通常完成一次这样的雅游要一年半左右时间，长的可达三年。早在17世纪，英国早期收藏艺术的一位重要人物，阿伦德尔勋爵（Earl of Arundel）就曾命建筑师伊尼戈·琼斯（Inigo Jones）陪同他前往意大利考察艺术和建筑。至雅游大盛的18世纪，英国文艺名流普遍成行，其中不乏以伴游导师的身份，趁便旅行的。雅游经历成了谈论艺术的敲门砖，伦敦著名的古典艺术家和鉴赏家团体爱好者协会（Society of Dilettanti），其入会条件就是完成一次雅游。</p><p>雅游给艺术家带来了机会，本次参展的好几位艺术家都仰仗旅行者的订件为生。意大利画家卡纳莱托笔下的威尼斯运河风光令人赏心悦目，大受英国客户的欢迎，他后来索性移居伦敦，在那里画了十年风景；</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_12.jpg" alt="Alt text"></p><p>《威尼斯：城堡区圣伯多禄圣殿》 卡纳莱托</p><p>18世纪30年代，布面油画</p><p>© The National Gallery, London</p><p>法国人韦尔内长年旅居罗马，向旅行者销售带有古典题材的海景画；</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_13.jpg" alt="Alt text"></p><p>《有渔民的河流》</p><p>克劳德-约瑟夫·韦尔内</p><p>1751年，布面油画</p><p>© The National Gallery, London</p><p>威尼斯人巴托尼则是雅游时代最著名肖像画家之一。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_14.jpg" alt="Alt text"></p><p>《班克斯费的约翰·斯科特（？）肖像》</p><p>庞贝奥·吉罗拉莫·巴托尼</p><p>1774年，布面油画</p><p>© The National Gallery, London</p><h1 id="英国画派的崛起"><a href="#英国画派的崛起" class="headerlink" title="英国画派的崛起"></a>英国画派的崛起</h1><p>18世纪也是英国画派蓬勃兴起的时期。自文艺复兴以来，英国惯于招引欧洲大陆的杰出艺术家前来服务，17世纪前期在位的英王查理一世热爱艺术，是当时欧洲最重要的收藏家之一。查理一世身边围绕着一个鉴赏团体，研究者称之为“白厅圈子”（Whitehall Groupe），前文提到的阿伦德尔勋爵就是这个团体中颇具眼力的一位，这批鉴赏家手下还掌控着一群像伊尼戈·琼斯这样的行家里手，并经常把他们派往欧洲各地发掘艺术品。</p><p>在与欧洲大陆艺术的长期交往中，英国本土艺术家成长起来，他们效仿巴黎美术学院，于18世纪中期创立了英国皇家美术学院（Royal Academy of Arts），其创院会员囊括了英国本土的优秀艺术家，本次参展的庚斯博罗就赫然在列。<strong>庚斯博罗</strong>是极富个性的肖像画大师，在温泉疗养胜地巴斯为人画了不少肖像，他的手法非常巧妙，不做过多的细节刻画，却让人感到很“像”，英国皇家美术学院的首任院长约书亚·雷诺兹曾评价庚斯博罗的高超手法，认为他深谙“传神”的要诀，省略了不必要画出的地方，任凭观众的想象力去补充。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_15.jpg" alt="Alt text"><br>《拉尔夫·朔姆贝格医生》</p><p>托马斯·庚斯博罗</p><p>约1770年，布面油画</p><p>© The National Gallery, London</p><p>18世纪的英国艺术圈子颇有几分像中国明清的文人圈子，画家与学者之间过从甚密，一位名流时常有数位画家朋友为之画像，这让英国画家经常讨论谁画得更像以及什么是“像”。<strong>他们普遍意识到传神的秘诀不在于造型准确，而在于捕捉最能反映性格的瞬间，以及留有想象余地的表现手法。</strong>这类讨论提醒我们，再现从来就不是模仿现实，<strong>再现的本质其实就是表现</strong>。因为有这样的见识，英国肖像画达到了很高成就，这在两位苏格兰画家<strong>亨利·雷班</strong>爵士和<strong>大卫·威尔基</strong>的作品中也能感受到。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_16.jpg" alt="Alt text"><br>《弓箭手》</p><p>亨利·雷班爵士</p><p>约1789-1790年，布面油画</p><p>© The National Gallery, London</p><p><strong>康斯特布尔</strong>的《干草车》曾让法国浪漫主义大师德拉克洛瓦深受启发，并为之改了自己的画。本次参展的《史特拉福磨坊》与《干草车》属于同期作品，天空高远清澈，充满光和大气的感觉。康斯特布尔笔下的风雨晴霁不是拼凑而成，而是完整的观察记录。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_17.jpg" alt="Alt text"><br>《史特拉福磨坊》</p><p>约翰·康斯特布尔</p><p>1820年，布面油画</p><p>© The National Gallery, London</p><p>晚些时候另一位英国画家<strong>约翰·拉斯金</strong>也用同样的精神观察风景，他首次记录了因工业污染而产生的一种暴雨云，还曾深入阿尔卑斯山长期考察，写下厚厚一卷书，那是画家论山的最佳著作之一。拉斯金对<strong>透纳</strong>推崇备至，赞扬后者的风景画不盲从自然却更加真实地体现了自然的精神。与这时期英国风景画的细致观察不同，法国画家<strong>柯罗</strong>追求的是风景的诗意。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_18.jpg" alt="Alt text"></p><p>《倾斜的树干》</p><p>让-巴蒂斯塔-卡米耶·柯罗</p><p>约1860-1865年，布面油画</p><p>© The National Gallery, London</p><h1 id="印象派与后印象派"><a href="#印象派与后印象派" class="headerlink" title="印象派与后印象派"></a>印象派与后印象派</h1><p>19世纪艺术家热衷于思考的一个问题是怎样画出户外的真实光效。因为户外光线非常明亮，传统绘画遇到外光一般都采用降调处理，把户外的色彩关系转换成室内的灰调子。<strong>德拉克洛瓦</strong>不满足于这种处理方式，想要发展出一套适于描绘户外光线的新的色彩体系。因为传统绘画一直把暗部处理为黑色，所以他从研究暗部的色彩开始找突破口。德拉克洛瓦的探索方向感召了一代青年画家，他们画了一幅《向德拉克洛瓦致敬》的群像表达敬意，马奈正是群像中的一员。</p><p><strong>马奈</strong>的《咖啡厅演奏会的一角》是一幅色彩斑斓、阳光明媚的快乐的画，画中的主角是位特别能干的女招待，但整幅画的气氛才是真正的主题。马奈也有改革绘画的雄心，他借鉴17世纪荷兰大师<strong>哈尔斯</strong>的活泼笔触，放弃了结实的素描——那种效果只出现在室内侧光下，而处于户外强光照射下的形体，都会失去立体感，显得扁平。一边是得自知识和理解的素描造型，一边是得自观察和感受的形体表象，马奈抛弃了所知而选择了所见，这使他成为印象派的先驱。马奈沿着德拉克洛瓦的方向更进一步，他加强了对补色的研究，画中男子的蓝色衣服与啤酒杯及背景中的黄色相互强化，拉宽了画面的色域。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_19.jpg" alt="Alt text"></p><p>《咖啡厅演奏会的一角》</p><p>爱德华·马奈</p><p>约1878-1880年，布面油画</p><p>© The National Gallery, London</p><p>19世纪，现代工业颜料丰富了画家的调色板，取代了一些原先十分昂贵的矿物颜料，例如拉斐尔画中圣母衣服所用的群青，当时价比黄金，常常在合同中单独规定成色和用量，现在则被廉价的工业群青所替代。数百年来，由于制成的颜料不能长时间保存，只能在作画前准备，19世纪中期，管装颜料的发明结束了这一局面，颜料随用随取，画家现在可以背着轻便的画箱走出户外，随地作画，这有力推动了印象派画家的探索。</p><p><strong>莫奈、雷诺阿、塞尚、高更</strong>和<strong>梵高</strong>等人先后都参加过青年画家联合展览会，展览会举办过八届，“<strong>印象派</strong>”这个名字即得自莫奈于首届展览会上展出的作品，因此上述几位画家都曾被认为是印象派画家。印象派并无自己的宣言，画风也很不一致，只是早期多作风景写生，强调在户外完成画作，<strong>抛开所知，仅画所见</strong>，在画面上捕捉到所谓“视网膜印象”。为此，他们作画时严守光照条件，当光照条件变化时，他们就停笔，等光照条件恢复了再继续画。虽然组织上非常松散，但印象派画家怀抱理想、贫贱不移的早期经历，给后世留下了一幅感人的画面。</p><p>莫奈和雷诺阿晚年见到了自己的成功，塞尚、高更和梵高则一早离开了印象派——他们都不甘于仅描绘所见。塞尚继承家产后，退隐家乡埃克斯独自作画，他在世纪末被人重新发现，其雄伟坚实的风格迷住了他过去的同道们，本次展出的是他早期一张作品。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_20.jpg" alt="Alt text"><br>《画室中的火炉》</p><p>保罗·塞尚</p><p>约1865年，布面油画</p><p>© The National Gallery, London</p><p>梵高在巴黎经历了乌托邦的破灭，只身前往法国南部小镇阿尔，燃烧生命的最后十年，成为我们时代的大师。《长草地与蝴蝶》是他罹患精神疾病，在圣雷米医院即将结束疗养时所作，画的正是医院的花园，梵高没有画出地平线，完全凭他标志性的笔触和漂亮的色彩支撑起画面，他的色彩极富表现力，热烈率直但并不简单，其复杂的黄-蓝、红-绿补色系统可以看作自马奈以来艺术家努力的成果。梵高像拉斐尔一样卒于37岁，他传奇的一生定义了现代艺术家的形象，其影响远远超乎艺术界。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_21.jpg" alt="Alt text"></p><p>《长草地与蝴蝶》</p><p>文森特·梵高</p><p>1890年，布面油画</p><p>© The National Gallery, London</p><p>高更受到原始主义和自然主义的影响，对人在现代社会中的异化深恶痛绝，他曾尝试与梵高结伴作画，又前往荒凉的布列塔尼寻求世外桃源，末了他来到南太平洋的法属殖民地塔西提岛，最后死在岛上。</p><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_22.jpg" alt="Alt text"><br>《窗前果盆和啤酒杯》</p><p>保罗·高更</p><p>可能作于1890年，布面油画</p><p>© The National Gallery, London</p><p>1910年，罗杰·弗莱在英国举办“马奈与后印象主义画家”展览，从那时起，人们开始把塞尚、高更和梵高归为一派，称他们是后印象主义画家。这三位艺术家站在传统艺术与现代艺术的转折点，其中塞尚对后世的影响尤其巨大，被尊为“现代主义之父”。</p><p><hr><br>绘画是人类普遍具有的冲动，但在大多数文明中，绘画一直停留在实用的层面上，只有屈指可数的几个文明超越了实用性，视绘画为值得宝藏的精神价值，中国和欧洲恰都属于这样的文明。中国与欧洲对待绘画的态度具有惊人的相似性——我们都认为艺术性不在“画什么”而在“怎么画”；都不惜千金收藏画作，为之著录，并发展起颇为相近的鉴定传统；我们都崇敬画家，就连津津乐道的画家故事也如出一辙——天才的无师自通、惊人表演和自由不羁；我们也都通过绘画来窥探人性，陶冶情操，并留下连篇累牍的著作。每当想起中国和欧洲文明不约而同竟有如此相似的艺术传统，心中都不禁涌起一股惊奇感！欧洲画史群星闪耀，岂能遍数？观其大略，本次展览的52幅杰作已经足够。</p><blockquote><p>*本文选编自《欧洲油画五百年：英国国家美术馆珍藏展简介》，有删节。作者：万木春（中国美术学院教授）<br>原文刊于上海博物馆编，《从波提切利到梵高：英国国家美术馆珍藏集》，上海书画出版社，2023年。</p></blockquote><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><blockquote><p><a href="https://mp.weixin.qq.com/s/7yzyQHTyMYCatfPISzj5Fg">https://mp.weixin.qq.com/s/7yzyQHTyMYCatfPISzj5Fg</a></p></blockquote><!-- <div style="line-height:0"><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list1.jpg" alt=""><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list2.jpg" alt=""><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list3.jpg" alt=""><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list4.jpg" alt=""><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list5.jpg" alt=""><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list6.jpg" alt=""><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list7.jpg" alt=""><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list8.jpg" alt=""><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list9.jpg" alt=""></div> --><p><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list1.jpg" alt="Alt text"><br><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list2.jpg" alt="Alt text"><br><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list3.jpg" alt="Alt text"><br><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list4.jpg" alt="Alt text"><br><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list5.jpg" alt="Alt text"><br><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list6.jpg" alt="Alt text"><br><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list7.jpg" alt="Alt text"><br><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list8.jpg" alt="Alt text"><br><img src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_list9.jpg" alt="Alt text"></p><h1 id="再现·大师——沉浸式光影体验"><a href="#再现·大师——沉浸式光影体验" class="headerlink" title="再现·大师——沉浸式光影体验"></a>再现·大师——沉浸式光影体验</h1><p>NG TREASURES: Masters-Reborn </p><p>An Immersive Digital Experience</p><p><a href="https://mp.weixin.qq.com/s/c88ZeJXEgbDzjW7xu1c4xg">https://mp.weixin.qq.com/s/c88ZeJXEgbDzjW7xu1c4xg</a></p><blockquote><p>上海博物馆将与品源文化共同打造珍藏展的展外特展——“ NG200 再现•大师｜沉浸式光影特展”，展览将在上海博物馆4楼第三展厅同期举行，所有购买“从波提切利到梵高——英国国家美术馆珍藏展”门票（含购买数字藏品获得门票）的观众，预约参观当日皆可享受一票两展的权益，一次畅游珍藏展与光影特展，敬请期待！</p></blockquote><p>包括这次未能参展的英国国家美术馆馆藏珍品的梵高的《向日葵》、莫奈的《睡莲》、达芬奇的《岩间圣母》等，</p><p>本次光影体验分两大展区，经过打卡墙和序曲，进入第一展区，观众将欣赏到一场6分钟左右的沉浸光影体验，打通视觉与听觉，随着光影叙事，进入西方美术史的不同阶段与大师创作心路。</p><p>第一展区观影结束后，观众将穿过梵高向日葵万花筒打卡区，进入“对话大师”二创区，在这里可通过数字展示屏、打卡和互动的方式，来欣赏中国年轻设计力量向大师致敬的无限创意。</p><!-- 预测函数与函数之间的调用关系是否存在。训练一个 linkbert 。在代码上训练LinkBERT: Pretraining Language Models with Document Links数据集？AutoPruner: transformer-based call graph pruning --><blockquote><p>创建于 2023-02-15</p><p>更新于 2023-02-15</p></blockquote>]]></content>
    
    
    <summary type="html">2023年1月17日至5月7日，上海博物馆首度联手英国国家美术馆，推出“对话世界”文物艺术大展系列的第二个展览——“从波提切利到梵高：英国国家美术馆珍藏展”。展览通过 52 件大师杰作，为观众奉上一场视觉盛宴，讲述欧洲绘画的故事。</summary>
    
    
    
    <category term="艺术" scheme="https://luorongluorong.github.io/categories/%E8%89%BA%E6%9C%AF/"/>
    
    
    <category term="油画" scheme="https://luorongluorong.github.io/tags/%E6%B2%B9%E7%94%BB/"/>
    
    <category term="博物馆" scheme="https://luorongluorong.github.io/tags/%E5%8D%9A%E7%89%A9%E9%A6%86/"/>
    
  </entry>
  
  <entry>
    <title>动态规划总结及练习巩固</title>
    <link href="https://luorongluorong.github.io/2023/02/11/algorithms/dp_short/"/>
    <id>https://luorongluorong.github.io/2023/02/11/algorithms/dp_short/</id>
    <published>2023-02-11T11:39:15.000Z</published>
    <updated>2023-03-08T15:25:04.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dp-精要"><a href="#dp-精要" class="headerlink" title="dp 精要"></a>dp 精要</h1><p>在前两期中，我们介绍了动态规划的基本概念，线性动态规划，前缀和，区间动态规划，背包动态规划，状态压缩动态规划，计数动态规划，矩阵快速幂，数位动态规划。</p><p>本章我们简要回顾一下前两期的内容，首先总结一下基本概念，然后把各个题型下的题目列表整理成了思维导图方便大家回忆。如果要看详细内容或者刷题，可以翻阅动态规划精讲前两期的内容。</p><p>本期我们主要回顾线性动态规划，前缀和，区间动态规划，背包动态规划并给大家聚合题目列表。</p><p>状态压缩动态规划，计数动态规划，矩阵快速幂，数位动态规划的题目聚合列表在动态规划精讲第四期给到大家。</p><h1 id="dp-基本概念"><a href="#dp-基本概念" class="headerlink" title="dp 基本概念"></a>dp 基本概念</h1><p>在动态规划精讲第一期中，我们有介绍一些基本概念，但是欠缺一点系统性。这里我们参考《算法竞赛进阶指南》中关于动态规划的讲解，把动态规划的几个核心概念梳理一下，并做一个总结。</p><p>首先我们给出思维导图<br><img src="/static/algorithms/dp_s1.jpeg" alt="Alt text"></p><p>动态规划用一句话概括就是对各个状态维度进行分阶段、有顺序、无重复、决策性的遍历求解。</p><h2 id="阶段-子问题"><a href="#阶段-子问题" class="headerlink" title="阶段(子问题)"></a>阶段(子问题)</h2><p>动态规划把原问题视为若干个重叠子问题的逐层递进，每个子问题的求解过程都构成一个阶段。在完成前一个阶段的计算后，才会执行下一阶段的计算。</p><h2 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h2><p>【在完成前一个阶段的计算后，才会执行下一阶段的计算】</p><p>无后效性: 为了保证这些计算能够按顺序，不重复地进行，DP 要求已经求解的子问题不受后续阶段的影响。(后面的阶段对前面的阶段没有影响)</p><h2 id="状态-转移-决策"><a href="#状态-转移-决策" class="headerlink" title="状态,转移,决策"></a>状态,转移,决策</h2><p>由无后效性。DP 对状态空间的遍历构成 DAG，遍历顺序就是该 DAG 的一个拓扑序。DAG 中的节点对应问题的状态，边对应状态之间的转移，转移的选取是 DP 中的决策。</p><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>当动态规划用于求解最优化的问题时，下一阶段的最优解应该能由前面各阶段子问题的最优解导出。</p><h3 id="重复子问题"><a href="#重复子问题" class="headerlink" title="重复子问题"></a>重复子问题</h3><p>在阶段计算完成的时候，只会在每个状态上保留与最终解集相关的代表信息，这些信息具有可重复的求解过程，并且能够导出后续阶段的代表信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><em>状态，阶段，决策</em>是动态规划算法的三要素。</p><p>无后效性，最优子结构，重复子问题是问题能用 DP 求解的三个基本条件。</p><h1 id="分阶段"><a href="#分阶段" class="headerlink" title="分阶段"></a>分阶段</h1><p>动态规划是对各维状态进行分阶段，有顺序，无重复，决策性的遍历求解，其中对阶段进行划分后，每个阶段就是一个子问题。</p><p>动态规划算法有不同的阶段划分和推导的方式，常见的阶段划分方式如下:</p><p><strong>「线性 DP」</strong>: 具有线性阶段划分的 DP 问题<br><strong>「树形 DP」</strong>: 以节点的深度作为阶段的 DP 问题<br><strong>「图上 DP」</strong>: 以节点在图上的拓扑序作为阶段的 DP 问题<br>这是一个广义的概念，与线性空间类似，如果一个 DP 算法的状态包含多个维度，但是各个维度上具有线性变化的阶段，也是「线性 DP」，例如背包问题，「区间 DP」均属于这种情况。</p><p>下面我们看一下「线性 DP」中常见的阶段划分方式，以此作为对前两期内容的复习。</p><h2 id="（1）单串阶段划分"><a href="#（1）单串阶段划分" class="headerlink" title="（1）单串阶段划分"></a>（1）单串阶段划分</h2><p>代表问题：最长上升子序列；<br>状态表示：dp[i] := 以 s[i] 结尾的最长上升子序列长度；<br>阶段划分：子序列的结尾位置，从前到后。</p><h2 id="（2）双串阶段划分"><a href="#（2）双串阶段划分" class="headerlink" title="（2）双串阶段划分"></a>（2）双串阶段划分</h2><p>代表问题：最长公共子序列；<br>状态表示：dp[i][j] := s[0..i], t[0..j]的最长公共子序列长度；<br>阶段划分：s 和 t 分别已经处理的长度，二维。</p><h2 id="（3）棋盘阶段划分"><a href="#（3）棋盘阶段划分" class="headerlink" title="（3）棋盘阶段划分"></a>（3）棋盘阶段划分</h2><p>代表问题：数字三角形；<br>状态表示：dp[i][j] := 从 (0, 0) 走到 (i, j) 的最大的和；<br>阶段划分：路径的结尾位置（矩阵中的行列位置），二维。</p><h1 id="线性动态规划"><a href="#线性动态规划" class="headerlink" title="线性动态规划"></a>线性动态规划</h1><h2 id="「单串-DP」"><a href="#「单串-DP」" class="headerlink" title="「单串 DP」"></a>「单串 DP」</h2><p>对于「单串线性 DP」问题，i 是单串 s 上的位置。作为阶段具有时间或者位置等含义。有时只有单串上的位置不足以表示状态，需要同时附加一个维度 k，一般 k 有长度、个数、次数、颜色等含义。另，所附加的维度有时候可以是多个，如 k1, k2, …</p><h2 id="没有附加状态维度"><a href="#没有附加状态维度" class="headerlink" title="没有附加状态维度"></a>没有附加状态维度</h2><p><img src="/static/algorithms/dp_s2.png" alt="Alt text"></p><h2 id="附加一维状态"><a href="#附加一维状态" class="headerlink" title="附加一维状态"></a>附加一维状态</h2><p><img src="/static/algorithms/dp_s3.jpeg" alt="Alt text"></p><h2 id="附加多维状态"><a href="#附加多维状态" class="headerlink" title="附加多维状态"></a>附加多维状态</h2><p><img src="/static/algorithms/dp_s4.jpeg" alt="Alt text"></p><h2 id="「双串-DP」"><a href="#「双串-DP」" class="headerlink" title="「双串 DP」"></a>「双串 DP」</h2><p>dp[i][j]: i, j 分别是两个串上的位置。i, j 共同作为阶段，具有位置等含义。没有附加维度。<br><img src="/static/algorithms/dp_s5.jpeg" alt="Alt text"></p><h2 id="「棋盘-DP」"><a href="#「棋盘-DP」" class="headerlink" title="「棋盘 DP」"></a>「棋盘 DP」</h2><p>dp[i][j]: i, j 分别是棋盘（矩阵）的横纵坐标。阶段划分常见的两种情况分别为：</p><p>（1）i 作为阶段，具有位置等含义。j 是附加状态。<br>（2）i, j 共同作为阶段，具有位置等含义。没有附加维度。</p><p><img src="/static/algorithms/dp_s6.jpeg" alt="Alt text"></p><h2 id="「线性-DP」总结"><a href="#「线性-DP」总结" class="headerlink" title="「线性 DP」总结"></a>「线性 DP」总结</h2><p>下图是 Leetcode 上「线性 DP」的题目分类汇总，方便大家从整体上把握题目。其中不含「区间 DP」，「背包 DP」和前缀和。这三块将分别有专题汇总。</p><p><img src="/static/algorithms/dp_s7.png" alt="Alt text"></p><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p><img src="/static/algorithms/dp_s8.png" alt="Alt text"></p><h1 id="区间动态规划"><a href="#区间动态规划" class="headerlink" title="区间动态规划"></a>区间动态规划</h1><p>对于「区间 DP」，i, j 分别是区间的左右端点，其中阶段为区间长度(j - i + 1)，另外有一个是附加状态是区间左端点 i。</p><p>有的题会同时有附加维度 k。一般 k 会有长度，个数，次数，颜色等含义。</p><h2 id="减治型"><a href="#减治型" class="headerlink" title="减治型"></a>减治型</h2><p>dp[i][j] 仅与常数个更小规模子问题有关，不需要枚举分割点然后两边分别求解。</p><p>一般是与 dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1] 有关。</p><h2 id="分治型"><a href="#分治型" class="headerlink" title="分治型"></a>分治型</h2><p>dp[i][j] 仅与 O(n) 个更小规模子问题有关，需要枚举分割点然后两边分别求解。</p><p>一般是枚举 [i, j] 的分割点，将区间分为 [i, k] 和 [k+1, j]， 对每个 k 分别求解（下面公式的 f），再汇总（下面公式的 g）。</p><p><img src="/static/algorithms/dp_s9.png" alt="Alt text"></p><h1 id="背包动态规划"><a href="#背包动态规划" class="headerlink" title="背包动态规划"></a>背包动态规划</h1><p>对于背包问题，“已经处理的物品数”为阶段，“背包的总体积”为附加状态。</p><p>下面是 Leetcode 上与「背包 DP」相关的题目，一共十几道，分成了「01 背包」和「完全背包」、「组合问题」和「优化问题」两个维度，方便大家在刷题中感悟总结。<br><img src="/static/algorithms/dp_s10.png" alt="Alt text"></p>]]></content>
    
    
    <summary type="html">总结动态规划相关的基本概念，类别划分及具体练习，帮助读者加以理解和巩固。</summary>
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://luorongluorong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://luorongluorong.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="练习" scheme="https://luorongluorong.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>两类前缀和问题</title>
    <link href="https://luorongluorong.github.io/2023/01/16/algorithms/prefix_sum/"/>
    <id>https://luorongluorong.github.io/2023/01/16/algorithms/prefix_sum/</id>
    <published>2023-01-16T02:58:27.000Z</published>
    <updated>2023-03-10T04:55:49.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>下面给出两个例子。</p><ul><li>第一个是给定 target，计算和为 target 的子数组的数目；</li><li>第二个是给定 target，计算和为 target 的子数组的最短的长度。</li></ul><p>解题的核心思想都是一致的：</p><ol><li>使用 Map 记录出现过的 prefix_sum 的数目/最近下标。</li><li>处理特殊值，即将 0 放入 Map 中。</li><li>进入循环：<ol><li>查找 Map 中是否存在 prefix_sum - target 的值，更新 res。</li><li>把本轮循环的 prefix_sum 放入 Map 中。</li></ol></li><li>退出循环，返回 res。</li></ol><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">560. 和为 K 的子数组</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] presums = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            presums[i] = presums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 计算组成 target 的子数组的组合的数目</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; cnts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">// [presum, idx]        </span></span><br><span class="line">        cnts.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">presum</span> <span class="operator">=</span> presums[i];   </span><br><span class="line">            res += cnts.getOrDefault(presum - target, <span class="number">0</span>);  </span><br><span class="line">            <span class="comment">// 作为被比较的对象</span></span><br><span class="line">            cnts.put(presum, cnts.getOrDefault(presum, <span class="number">0</span>) + <span class="number">1</span>);       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1590-使数组和能被-P-整除"><a href="#1590-使数组和能被-P-整除" class="headerlink" title="1590. 使数组和能被 P 整除"></a><a href="https://leetcode.cn/problems/make-sum-divisible-by-p/description/">1590. 使数组和能被 P 整除</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] presums = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            presums[i + <span class="number">1</span>] = (presums[i] + nums[i]) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> presums[len]; </span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> len;  <span class="comment">// 组成 target 的子数组的最短长度</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; records = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();     </span><br><span class="line">        records.put(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; ++i) &#123;            </span><br><span class="line">            <span class="type">int</span> <span class="variable">presum</span> <span class="operator">=</span> presums[i];                     </span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">search</span> <span class="operator">=</span> ((presum - target) % p + p) % p;</span><br><span class="line">            <span class="keyword">if</span> (records.containsKey(search)) &#123;</span><br><span class="line">                res = Math.min(res, i - records.get(search));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 作为被比较的对象</span></span><br><span class="line">            records.put(presum, i);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == len ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><p>在求二维前缀和的时候，仅需注意两个点：</p><ul><li>presums 比 matrix 的长宽都大 1。</li><li>在计算子矩阵和的时候，rowbig 和 colbig 都要记得加 1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] presums;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="built_in">this</span>.presums = <span class="keyword">new</span> <span class="title class_">int</span>[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                presums[i + <span class="number">1</span>][j + <span class="number">1</span>] = presums[i][j + <span class="number">1</span>] + presums[i + <span class="number">1</span>][j] - presums[i][j] + matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> presums[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] + presums[row1][col1] - presums[row1][col2 + <span class="number">1</span>] - presums[row2 + <span class="number">1</span>][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/solutions/627420/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/">304 二维区域和检索 - 矩阵不可变 的官方题解</a></li></ul>]]></content>
    
    
    <summary type="html">总结常见前缀和问题及其解法。</summary>
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://luorongluorong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="前缀和" scheme="https://luorongluorong.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Git 规范</title>
    <link href="https://luorongluorong.github.io/2022/06/02/commands/git/"/>
    <id>https://luorongluorong.github.io/2022/06/02/commands/git/</id>
    <published>2022-06-02T11:21:41.000Z</published>
    <updated>2023-03-21T04:25:59.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-规范"><a href="#Git-规范" class="headerlink" title="Git 规范"></a>Git 规范</h1><p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>分支：master分支，每个任务一个分支（注意.gitignore）</p><ul><li>fix：修复了bug</li><li>docs：只修改了文档</li><li>style：调整代码格式，未修改代码逻辑（比如修改空格、格式化、缺少分号等）</li><li>refactor：代码重构，既没修复bug也没有添加新功能</li><li>perf：性能优化，提高性能的代码更改</li><li>test：添加或修改代码测试</li><li>chore：对构建流程或辅助工具和依赖库（如文档生成等）的更改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--pretty=oneline: commit 信息展示为行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--abbrev-commit: 仅显示 commit <span class="built_in">id</span> 的前几个标识符</span></span><br><span class="line">git log --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>git add的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区，</p><p>git commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。</p><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p><code>手动删除文件，然后使用git add &lt;file&gt;</code>和<code>git rm &lt;file&gt;</code>效果是一样的。</p><p>有时候，发现有不该提交的文件已经提交后，仅仅在<code>.gitignore</code>中加入忽略是不行的。这个时候需要执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached [被回收的文件]</span><br></pre></td></tr></table></figure><p>去掉已经托管的文件，然后重新提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#x27;&#x27;</span><br></pre></td></tr></table></figure><p>注意！<code>git rm -r --cached 文件/文件夹名字</code> 是高危操作，一定要指定文件名不能不写，否则 <code>git rm -r --cached</code> 会删除所有缓存，包括本地未提交的文件。</p><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到旧分支</span></span><br><span class="line">git checkout oldBranch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并切换至新分支</span></span><br><span class="line">git checkout -b luorong </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最新版本的Git提供了新的git switch命令来切换分支：</span></span><br><span class="line">git switch -c 新的分支名</span><br><span class="line">git switch 已有的分支名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新分支代码并提交</span></span><br><span class="line">git add *</span><br><span class="line">git commit -m &quot;init newBranch&quot;</span><br><span class="line">git push origin newBranch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有分支</span></span><br><span class="line">git branch -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前使用分支（结果列表前面*号，代表当前使用的分支)</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并分支</span></span><br><span class="line">git merge 分支名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除分支</span></span><br><span class="line">git branch -d 分支名</span><br><span class="line">git branch -D 分支名  # 强行删除</span><br></pre></td></tr></table></figure><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</span></span><br><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p><h2 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h2><p>执行 ADD 后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged [file] : 表示从暂存区将文件的状态修改成 unstage 状态。当然，也可以不指定确切的文件 ，例如：</span><br><span class="line">git restore --staged *.java 表示将所有暂存区的java文件恢复状态</span><br><span class="line">git restore --staged . 表示将当前目录所有暂存区文件恢复状态</span><br><span class="line">--staged 参数就是表示仅仅恢复暂存区的</span><br></pre></td></tr></table></figure><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 文件名</span><br></pre></td></tr></table></figure></p><p>git diff 时是分为两种情况的：暂存区为空和暂存区不为空。</p><p>首先我们明确知道git diff是比较工作区和暂存区的文件的，如果此时暂存区为空，那么稍微有点不同，即：</p><p>1 暂存区为空使用git diff：因为此时暂存区为空，此时使用git diff同样也是比较工作区和仓库，即和使用git diff HEAD结果相同</p><p>2 暂存区不为空使用git diff:因为此时暂存区不为空，此时使用git diff比较的就是工作区和暂存区</p><h2 id="reset-回退到某个版本"><a href="#reset-回退到某个版本" class="headerlink" title="reset: 回退到某个版本"></a>reset: 回退到某个版本</h2><p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本append GPL回退到上一个版本，就可以使用<code>git reset</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL</p><p><code>git reflog</code>用来记录你的每一次命令。</p><p><strong>现在总结一下：</strong></p><ul><li><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset —hard commit_id。</p></li><li><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p></li><li><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本</p></li></ul><p>注意：这里不会保存 add 后的文件。所以要用 stash。</p><h2 id="更新-commit-的信息"><a href="#更新-commit-的信息" class="headerlink" title="更新 commit 的信息"></a>更新 commit 的信息</h2><p>经常 commit 错误信息。如何修改？分为如下三种情况：</p><ol><li>刚刚 commit，还没有 push，使用 git commit —amend;</li><li>刚刚 push，要修改最近一个 push 的commit信息，使用 git commit —amend；</li><li>修改历史 push 的 commit 信息，使用 git rebase -i HEAD~n【其中的n为记录数】，配合2中的命令</li></ol><h2 id="stash-把当前工作现场“储藏”起来，等以后恢复现场后继续工作"><a href="#stash-把当前工作现场“储藏”起来，等以后恢复现场后继续工作" class="headerlink" title="stash: 把当前工作现场“储藏”起来，等以后恢复现场后继续工作"></a>stash: 把当前工作现场“储藏”起来，等以后恢复现场后继续工作</h2><p>出现一个 bug，但是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存当前分支 dev 的内容</span></span><br><span class="line">git stash </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回到主分支，新建 bug 修复分支，修复 bug，回到主分支，merge 后回到 dev 分支</span></span><br><span class="line">git switch master</span><br><span class="line">git checkout -b issue-101</span><br><span class="line">git add fixbug.txt</span><br><span class="line">git commit -m &quot;fix bug 101&quot;</span><br><span class="line">git switch master</span><br><span class="line">git merge --no-ff -m &quot;merge bug fix 101&quot; issue-101</span><br><span class="line">git switch dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看工作现场</span></span><br><span class="line">git stash list</span><br><span class="line">git stash apply stash@&#123;0&#125; # 第一种恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删</span><br><span class="line">git stash pop             # 第二种恢复，恢复的同时把stash内容也删了</span><br></pre></td></tr></table></figure><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>那怎么在dev分支上修复同样的bug？Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支</p><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打标签：git tag 标签名 commitId</span></span><br><span class="line">git tag v0.9 f52c633</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-a指定标签名，-m指定说明文字</span></span><br><span class="line">git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看标签，标签不是按时间顺序列出，而是按字母排序的</span></span><br><span class="line">git tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看标签的详细信息</span></span><br><span class="line">git show 标签名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除标签：</span></span><br><span class="line">git tag -d v0.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送某个标签到远程</span></span><br><span class="line">git push origin &lt;tagname&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一次性推送全部尚未推送到远程的本地标签</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>廖雪峰的 Git 教程</li><li>阿里巴巴 Git commit 规范</li></ul>]]></content>
    
    
    <summary type="html">记录 git 常用的命令。</summary>
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Git" scheme="https://luorongluorong.github.io/tags/Git/"/>
    
    <category term="命令" scheme="https://luorongluorong.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
