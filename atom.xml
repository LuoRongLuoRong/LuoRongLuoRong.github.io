<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LuoRongLuoRong</title>
  
  <subtitle>博客</subtitle>
  <link href="https://luorongluorong.github.io/atom.xml" rel="self"/>
  
  <link href="https://luorongluorong.github.io/"/>
  <updated>2023-02-18T12:41:59.741Z</updated>
  <id>https://luorongluorong.github.io/</id>
  
  <author>
    <name>LuoRongLuoRong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>格雷码</title>
    <link href="https://luorongluorong.github.io/2023/02/18/algorithms/binary_gray_code/"/>
    <id>https://luorongluorong.github.io/2023/02/18/algorithms/binary_gray_code/</id>
    <published>2023-02-18T11:21:41.000Z</published>
    <updated>2023-02-18T12:41:59.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h1><p><a href="https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858">格雷码</a>，在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格雷编码的生成过程, G(i) = i ^ (i/2);</span><br><span class="line">如 n = 3: </span><br><span class="line">G(0) = 000, </span><br><span class="line">G(1) = 1 ^ 0 = 001 ^ 000 = 001</span><br><span class="line">G(2) = 2 ^ 1 = 010 ^ 001 = 011 </span><br><span class="line">G(3) = 3 ^ 1 = 011 ^ 001 = 010</span><br><span class="line">G(4) = 4 ^ 2 = 100 ^ 010 = 110</span><br><span class="line">G(5) = 5 ^ 2 = 101 ^ 010 = 111</span><br><span class="line">G(6) = 6 ^ 3 = 110 ^ 011 = 101</span><br><span class="line">G(7) = 7 ^ 3 = 111 ^ 011 = 100</span><br></pre></td></tr></table></figure><h2 id="1-公式生成"><a href="#1-公式生成" class="headerlink" title="1. 公式生成"></a>1. 公式生成</h2><p>如果我们有一个二进制数序列，我们也可以将它直接转换成格雷码序列。假设第 n 个格雷码的对应规则如下：</p><p>G(n) = n xor (n &gt;&gt; 1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++) &#123;</span><br><span class="line">            ret.add((i &gt;&gt; <span class="number">1</span>) ^ i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-对称生成"><a href="#2-对称生成" class="headerlink" title="2. 对称生成"></a>2. 对称生成</h2><p>另一种方式是<a href="https://leetcode.cn/problems/gray-code/solutions/13637/gray-code-jing-xiang-fan-she-fa-by-jyd/">对称生成</a>。</p><p><img src="static/algorithms/binary_gray_code1.png" alt="Alt text"></p><p><img src="static/algorithms/binary_gray_code2.png" alt="Alt text"></p><p>样例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;() &#123;&#123; add(<span class="number">0</span>); &#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                res.add(head + res.get(j));</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ul><li><a href="https://leetcode.cn/problems/gray-code/">89. 格雷编码</a></li><li><a href="https://leetcode.cn/problems/circular-permutation-in-binary-representation/">1238. 循环码排列</a></li></ul>]]></content>
    
    
    <summary type="html">在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code）。</summary>
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://luorongluorong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="格雷码" scheme="https://luorongluorong.github.io/tags/%E6%A0%BC%E9%9B%B7%E7%A0%81/"/>
    
    <category term="练习" scheme="https://luorongluorong.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用 LaTex 书写符号</title>
    <link href="https://luorongluorong.github.io/2023/02/18/practices/latex_math/"/>
    <id>https://luorongluorong.github.io/2023/02/18/practices/latex_math/</id>
    <published>2023-02-18T11:21:41.000Z</published>
    <updated>2023-02-18T13:19:20.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、公式加粗、更改颜色、添加序号"><a href="#0、公式加粗、更改颜色、添加序号" class="headerlink" title="0、公式加粗、更改颜色、添加序号"></a>0、公式加粗、更改颜色、添加序号</h2><p>所有的LaTex的书写形式都是在 $…$ 之中，只不过对于嵌入在文章中间而言 是单对的$…$，而单独成行的LaTex表达式是双对的 <script type="math/tex">...</script>。</p><p>对公式加粗需要用 \bm{ …… }加之包含其中即可。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bm</span>&#123; .... &#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><blockquote><p>$\bm{ 加粗使用bm }$</p></blockquote><p>更改公式字母颜色：<br>如果只更改个别字母，那个后面的需要用黑色再改下</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\color</span>&#123;red&#125;  </span><br><span class="line"><span class="keyword">\color</span>&#123;green&#125;   </span><br><span class="line"><span class="keyword">\color</span>&#123;back&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\color</span>&#123;green&#125;。。。。。<span class="keyword">\color</span>&#123;back&#125;。。。。</span><br></pre></td></tr></table></figure><blockquote><p>$white\color{red} red\color{green}green\color{back}white\color{black}black$</p></blockquote><p>给公式添加序号：在公式最后添加 \tag{…}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span> ... <span class="keyword">\tag</span>1<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span> ... <span class="keyword">\tag</span>&#123;1.1&#125;<span class="built_in">$</span><span class="built_in">$</span><span class="params">#</span> 多位序号记得用&#123;&#125;扩起来</span><br></pre></td></tr></table></figure><blockquote><script type="math/tex; mode=display">tag来标序 \tag1</script></blockquote><h2 id="1、希腊字母"><a href="#1、希腊字母" class="headerlink" title="1、希腊字母"></a>1、希腊字母</h2><p>书写表达式，少不了使用希腊字母，但是LaTex 的希腊字母是什么呢？</p><div class="table-container"><table><thead><tr><th>LaTex 表达式</th><th>字体效果</th><th>LaTex 表达式</th><th>字体效果</th></tr></thead><tbody><tr><td>\alpha</td><td>$\alpha$</td><td>\Alpha</td><td>$\Alpha$</td></tr><tr><td>\beta</td><td>$\beta$</td><td>\Beta</td><td>$\Beta$</td></tr><tr><td>\gamma</td><td>$\gamma$</td><td>\Gamma</td><td>$\Gamma$</td></tr><tr><td>\delta</td><td>$\delta$</td><td>\Delta</td><td>$\Delta$</td></tr><tr><td>\epsilon</td><td>$\epsilon$</td><td>\Epsilon</td><td>$\Epsilon$</td></tr><tr><td>\zeta</td><td>$\zeta$</td><td>\Zeta</td><td>$\Zeta$</td></tr><tr><td>\eta</td><td>$\eta$</td><td>\Eta</td><td>$\Eta$</td></tr><tr><td>\theta</td><td>$\theta$</td><td>\Theta</td><td>$\Theta$</td></tr><tr><td>\iota</td><td>$\iota$</td><td>\Iota</td><td>$\Iota$</td></tr><tr><td>\kappa</td><td>$\kappa$</td><td>\Kappa</td><td>$\Kappa$</td></tr><tr><td>\lambda</td><td>$\lambda$</td><td>\Lambda</td><td>$\Lambda$</td></tr><tr><td>\mu</td><td>$\mu$</td><td>\Mu</td><td>$\Mu$</td></tr><tr><td>\nu</td><td>$\nu$</td><td>\Nu</td><td>$\Nu$</td></tr><tr><td>\xi</td><td>$\xi$</td><td>\Xi</td><td>$\Xi$</td></tr><tr><td>\omicron</td><td>$\omicron$</td><td>\Omicron</td><td>$\Omicron$</td></tr><tr><td>\pi</td><td>$\pi$</td><td>\Pi</td><td>$\Pi$</td></tr><tr><td>\rho</td><td>$\rho$</td><td>\Rho</td><td>$\Rho$</td></tr><tr><td>\sigma</td><td>$\sigma$</td><td>\Sigma</td><td>$\Sigma$</td></tr><tr><td>\tau</td><td>$\tau$</td><td>\Tau</td><td>$\Tau$</td></tr><tr><td>\upsilon</td><td>$\upsilon$</td><td>\Upsilon</td><td>$\Upsilon$</td></tr><tr><td>\varphi</td><td>$\varphi$</td><td>\Phi</td><td>$\Phi$</td></tr><tr><td>\chi</td><td>$\chi$</td><td>\Chi</td><td>$\Chi$</td></tr><tr><td>\psi</td><td>$\psi$</td><td>\Psi</td><td>$\Psi$</td></tr><tr><td>\omega</td><td>$\omega$</td><td>\Omega</td><td>$\Omega$</td></tr></tbody></table></div><h2 id="2、运算符-amp-空格"><a href="#2、运算符-amp-空格" class="headerlink" title="2、运算符 &amp; 空格"></a>2、运算符 &amp; 空格</h2><div class="table-container"><table><thead><tr><th>LaTex 表达式</th><th>字体效果</th></tr></thead><tbody><tr><td>单空格 ： a \quad b</td><td>$a \quad b$</td></tr><tr><td>双空格： a \qquad b</td><td>$a \qquad b$</td></tr><tr><td>乘号：\times</td><td>$x \times x$</td></tr><tr><td>\#</td><td>$#$</td></tr><tr><td>\$</td><td>$$$</td></tr><tr><td>\%</td><td>$\%$</td></tr><tr><td>\&amp;</td><td>$\&amp;$</td></tr><tr><td>\_</td><td>$_$</td></tr><tr><td>\–</td><td>$–$</td></tr></tbody></table></div><h2 id="3、上下标"><a href="#3、上下标" class="headerlink" title="3、上下标"></a>3、上下标</h2><p>对于上标使用 下划线表示 <code>_</code> ；对于上标使用<code>^</code>表示。</p><p>多于 1 位需要用 <code>&#123;&#125;</code> 包裹起来。</p><p>对于正上方和正下方的为 <code>\limits</code>。</p><div class="table-container"><table><thead><tr><th>LaTex 表达式</th><th>字体效果</th></tr></thead><tbody><tr><td>x_i^2</td><td>$x_i^2$</td></tr><tr><td>x_{2i}^{2+b}</td><td>$x_{2i}^{2+b}$</td></tr><tr><td>\hat{a}</td><td>$\hat{a}$</td></tr><tr><td>\acute{a}</td><td>$\acute{a}$</td></tr><tr><td>\breve{a}</td><td>$\breve{a}$</td></tr><tr><td>\grave{a}</td><td>$\grave{a}$</td></tr><tr><td>\bar{a}</td><td>$\bar{a}$</td></tr><tr><td>\widetilde{a}</td><td>$\widetilde{a}$</td></tr><tr><td>\check{a}</td><td>$\check{a}$</td></tr><tr><td>\tilde{a}</td><td>$\tilde{a}$</td></tr><tr><td>\dot{a}</td><td>$\dot{a}$</td></tr><tr><td>\ddot{a}</td><td>$\ddot{a}$</td></tr><tr><td>\vec{a}</td><td>$\vec{a}$</td></tr><tr><td>\widehat{a}</td><td>$\widehat{a}$</td></tr></tbody></table></div><h2 id="4、log"><a href="#4、log" class="headerlink" title="4、log"></a>4、log</h2><p>log的表达式会稍微简单点，<code>\log</code> 就是它的LaTex表达式，</p><div class="table-container"><table><thead><tr><th>LaTex 表达式</th><th>字体效果</th></tr></thead><tbody><tr><td>\log{21} {xy}</td><td>$\log_{21} {xy}$</td></tr></tbody></table></div><h2 id="5、括号"><a href="#5、括号" class="headerlink" title="5、括号"></a>5、括号</h2><div class="table-container"><table><thead><tr><th>LaTex 表达式</th><th>字体效果</th></tr></thead><tbody><tr><td>\left(…\right)</td><td>$\left(…\right)$</td></tr><tr><td>\vert</td><td>$\vert$</td></tr><tr><td>\Vert</td><td>$\Vert$</td></tr><tr><td>\langle</td><td>$\langle$</td></tr><tr><td>\rangle</td><td>$\rangle$</td></tr><tr><td>\lceil</td><td>$\lceil$</td></tr><tr><td>\rceil</td><td>$\rceil$</td></tr><tr><td>\lfloor</td><td>$\lfloor$</td></tr><tr><td>\rfloor</td><td>$\rfloor$</td></tr><tr><td>\Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr)</td><td>$\Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr)$</td></tr><tr><td>$\vert x \vert$</td><td><script type="math/tex">\vert x \vert</script></td></tr><tr><td>f(x)=\begin{cases} x = \cos(t) \y = \sin(t) \ z = \frac xy \end{cases}</td><td>$f(x)=\begin{cases} x = \cos(t) \y = \sin(t) \ z = \frac xy \end{cases}$</td></tr><tr><td>f(x)=\begin{cases} 0&amp; \text{x=0}\1&amp; \text{x!=0} \end{cases}</td><td>$f(x)=\begin{cases} 0&amp; \text{x=0}\1&amp; \text{x!=0} \end{cases}$</td></tr></tbody></table></div><p>对于个别符号，如 ()、[]等，如果想要变大，可以在 这些符号前面添加即可.</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\Biggl</span>   <span class="keyword">\biggl</span>   <span class="keyword">\Bigl</span>   <span class="keyword">\bigl</span>   左符号</span><br><span class="line"><span class="keyword">\Biggr</span>   <span class="keyword">\biggr</span>   <span class="keyword">\Bigr</span>   <span class="keyword">\bigr</span>   右符号</span><br></pre></td></tr></table></figure><h2 id="6、矩阵"><a href="#6、矩阵" class="headerlink" title="6、矩阵"></a>6、矩阵</h2><div class="table-container"><table><thead><tr><th>LaTex 表达式</th><th>字体效果</th></tr></thead><tbody><tr><td>\begin{matrix} 0 &amp; 1 \ 1 &amp; 0 \end{matrix}</td><td>$\begin{matrix} 0 &amp; 1 \ 1 &amp; 0 \end{matrix}$</td></tr><tr><td>\begin{pmatrix} 0 &amp; -i \ i &amp; 0 \end{pmatrix}\</td><td>$\begin{pmatrix} 0 &amp; -i \ i &amp; 0 \end{pmatrix}\$</td></tr><tr><td>\begin{bmatrix} 0 &amp; -1 \ 1 &amp; 0 \end{bmatrix}</td><td>$\begin{bmatrix} 0 &amp; -1 \ 1 &amp; 0 \end{bmatrix}$</td></tr><tr><td>\begin{Bmatrix} 1 &amp; 0 \ 0 &amp; -1 \end{Bmatrix}</td><td>$\begin{Bmatrix} 1 &amp; 0 \ 0 &amp; -1 \end{Bmatrix}$</td></tr><tr><td>\begin{vmatrix} a &amp; b \ c &amp; d \end{vmatrix}</td><td>$\begin{vmatrix} a &amp; b \ c &amp; d \end{vmatrix}$</td></tr><tr><td>\begin{Vmatrix} i &amp; 0 \ 0 &amp; -i \end{Vmatrix}</td><td>$\begin{Vmatrix} i &amp; 0 \ 0 &amp; -i \end{Vmatrix}$</td></tr></tbody></table></div><h2 id="7、求和与积分"><a href="#7、求和与积分" class="headerlink" title="7、求和与积分"></a>7、求和与积分</h2><div class="table-container"><table><thead><tr><th>LaTex 表达式</th><th>字体效果</th></tr></thead><tbody><tr><td>\sum</td><td>$\sum$</td></tr><tr><td>\int</td><td>$\int$</td></tr><tr><td>\sum_1^n</td><td>$\sum_1^n$</td></tr><tr><td>\sum_{i=0}^\infty i^2</td><td>$\sum_{i=0}^\infty i^2$</td></tr><tr><td>\prod_{k=1}^n k = n!</td><td>$\prod_{k=1}^n k = n!$</td></tr><tr><td>\infty</td><td>$\infty$</td></tr><tr><td>\bigcup</td><td>$\bigcup$</td></tr><tr><td>\bigcap</td><td>$\bigcap$</td></tr><tr><td>\iint</td><td>$\iint$</td></tr><tr><td>\iiint</td><td>$\iiint$</td></tr></tbody></table></div><h2 id="8、开方"><a href="#8、开方" class="headerlink" title="8、开方"></a>8、开方</h2><div class="table-container"><table><thead><tr><th>LaTex 表达式</th><th>字体效果</th></tr></thead><tbody><tr><td>\sqrt{x^3}</td><td>$\sqrt{x^3}$</td></tr><tr><td>\sqrt[3]{\frac xy}</td><td>$\sqrt[3]{\frac xy}$</td></tr></tbody></table></div><p>​</p><h2 id="9、分数"><a href="#9、分数" class="headerlink" title="9、分数"></a>9、分数</h2><div class="table-container"><table><thead><tr><th>LaTex 表达式</th><th>字体效果</th></tr></thead><tbody><tr><td>\frac ab</td><td>$\frac ab$</td></tr><tr><td>\frac{a+1}{b+1}</td><td>$\frac{a+1}{b+1}$</td></tr><tr><td>{a+1\over b+1}</td><td>${a+1\over b+1}$</td></tr><tr><td>\cfrac{a}{b}</td><td>$\cfrac{a}{b}$</td></tr></tbody></table></div><h2 id="10、特殊函数"><a href="#10、特殊函数" class="headerlink" title="10、特殊函数"></a>10、特殊函数</h2><div class="table-container"><table><thead><tr><th>LaTex 表达式</th><th>字体效果</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h2 id="11、导数、极限、积分"><a href="#11、导数、极限、积分" class="headerlink" title="11、导数、极限、积分"></a>11、导数、极限、积分</h2><div class="table-container"><table><thead><tr><th>LaTex 表达式</th><th>字体效果</th></tr></thead><tbody><tr><td></td><td>$$</td></tr></tbody></table></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/ViatorSun/article/details/82826664">超详细 LaTex 数学公式</a></li><li><a href="https://www.cnblogs.com/G-Aurora/p/13760672.html">Typora 数学公式</a></li></ul>]]></content>
    
    
    <summary type="html">使用 LaTex 书写数学公式中的符号。</summary>
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="LaTex" scheme="https://luorongluorong.github.io/tags/LaTex/"/>
    
    <category term="写作" scheme="https://luorongluorong.github.io/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【论文精读】AutoPruner, Transformer-Based Call Graph Pruning</title>
    <link href="https://luorongluorong.github.io/2023/02/17/papers/FSE&#39;22_AutoPruner_Transformer_Based_Call_Graph_Pruning/"/>
    <id>https://luorongluorong.github.io/2023/02/17/papers/FSE&#39;22_AutoPruner_Transformer_Based_Call_Graph_Pruning/</id>
    <published>2023-02-17T09:11:23.000Z</published>
    <updated>2023-02-17T12:07:53.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AutoPruner-Transformer-Based-Call-Graph-Pruning"><a href="#AutoPruner-Transformer-Based-Call-Graph-Pruning" class="headerlink" title="AutoPruner: Transformer-Based Call Graph Pruning"></a>AutoPruner: Transformer-Based Call Graph Pruning</h1><p>本文 2022 年发表于 FSE。</p><h2 id="（一）论文总结"><a href="#（一）论文总结" class="headerlink" title="（一）论文总结"></a>（一）论文总结</h2><p>构造一个静态调用图需要在可靠性和精度之间进行权衡。不幸的是，用于构造调用图的程序分析技术通常并不精确。为了解决这个问题，研究人员最近提出了由机器学习授权的调用图剪枝到由静态分析构建的后处理调用图。通过提取随机森林分类器的结构特征，建立机器学习模型从调用图中获取信息。然后，它会删除那些被预测为假阳性的边缘。尽管机器学习模型显示了一些改进，但它们仍然有限，因为它们没有考虑源代码的语义，因此往往不能有效地区分真阳性和假阳性。</p><blockquote><p>作者要解决的问题是对的吗？是合适的吗？</p></blockquote><p>在本文中，我们提出了一种新的调用图剪枝技术，自动剪枝器，通过统计语义和结构分析来消除调用图中的假阳性。给定一个由传统静态分析工具构造的调用图，AutoPruner采用一种基于转换器的方法来捕获与调用图中每条边相关的调用者和被调用者函数之间的语义关系。为此，自动修剪器对在大型语料库上预先训练的代码模型进行微调，以根据其语义的描述来表示源代码。接下来，该模型用于从调用图中与每条边相关的函数中提取语义特征。自动剪枝器使用这些语义特征以及从调用图中提取的结构特征，通过前馈神经网络对每条边进行分类。我们对真实世界程序的基准数据集进行的实证评估表明，自动修剪器优于最先进的基线，在识别静态调用图中的假阳性边方面，在f测度上提高了高达13%。此外，自动剪枝器在两个客户端分析上取得了改进，包括将空指针分析的误报率减半，对单态调用站点检测提高了10%以上。此外，我们的消融研究和定性分析表明，由自动修剪器提取的语义特征捕获了大量的信息来区分真阳性和假阳性。</p><h2 id="（二）论文大纲"><a href="#（二）论文大纲" class="headerlink" title="（二）论文大纲"></a>（二）论文大纲</h2><h3 id="1-假设"><a href="#1-假设" class="headerlink" title="1. 假设"></a>1. 假设</h3><h3 id="2-论点"><a href="#2-论点" class="headerlink" title="2. 论点"></a>2. 论点</h3><h3 id="3-数据"><a href="#3-数据" class="headerlink" title="3. 数据"></a>3. 数据</h3><h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h3><h2 id="（三）局限或拓展"><a href="#（三）局限或拓展" class="headerlink" title="（三）局限或拓展"></a>（三）局限或拓展</h2><h2 id="（四）个人感想"><a href="#（四）个人感想" class="headerlink" title="（四）个人感想"></a>（四）个人感想</h2><h3 id="1-针对论文-idea-的看法"><a href="#1-针对论文-idea-的看法" class="headerlink" title="1. 针对论文 idea 的看法"></a>1. 针对论文 idea 的看法</h3><h3 id="2-论文的潜在影响力"><a href="#2-论文的潜在影响力" class="headerlink" title="2. 论文的潜在影响力"></a>2. 论文的潜在影响力</h3><hr><ul><li><p>批判性阅读</p><ul><li>作者要解决的问题是对的吗？是合适的吗？</li><li>作者是否忽视了更简单的解决问题的方法？</li><li>该方法的局限在哪？作者有没有承认？</li><li>作者的假设真的是合理的吗？</li><li>论文的逻辑清晰吗？合法吗？通过假设能推理出结果吗？有逻辑漏洞吗？</li><li>数据准确吗？收集数据的方式正确吗？</li><li>收集的数据证实了该文论点吗？</li><li>论文解释数据的方式合理吗？</li><li>有没有更有说服力的数据呢？</li></ul></li><li><p>创造性地阅读</p><ul><li>论文的 idea 好在哪儿？</li><li>这些 idea 有其它应用或者拓展吗？</li><li>这些 idea 可以 be generalized 吗？</li><li>是否存在可能的改善产生重大的不同？</li><li>如果你想从这篇论文着手开始研究，你接下来该开始做什么呢？</li></ul></li><li>做笔记<ul><li>标记重点内容。</li><li>记下问题和批判。</li><li>标记重要的数据或者有问题的数据。</li></ul></li><li><p>总结</p><ul><li>读完一遍后，用一两句话总结这篇文章。</li><li>第二遍阅读可以在把握大纲的基础上了解更多细节。</li><li>如果可以用简介的话表示 points，那么就可以总结三到四个重要的 subpoints</li></ul></li><li><p>将该文与其它工作进行比较</p><ul><li>总结论文是为了发现它的贡献。但总结一篇文章贡献的最好的方式还是和同领域内其它的文章进行比较。</li><li>该文的观点之前出现过吗？</li><li>不同文章的贡献呈现出不同的模式，比如观点新颖，比如实现新颖，比如组合方式新颖。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文是阅读《AutoPruner：基于 Transformer 的函数调用图优化》的学习笔记。</summary>
    
    
    
    <category term="学术" scheme="https://luorongluorong.github.io/categories/%E5%AD%A6%E6%9C%AF/"/>
    
    
    <category term="论文" scheme="https://luorongluorong.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="程序分析" scheme="https://luorongluorong.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    <category term="复现" scheme="https://luorongluorong.github.io/tags/%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="论文精读" scheme="https://luorongluorong.github.io/tags/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"/>
    
    <category term="深度学习" scheme="https://luorongluorong.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="预训练语言模型" scheme="https://luorongluorong.github.io/tags/%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="Transformer" scheme="https://luorongluorong.github.io/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>TODO_Java Arrays.sort() 源码分析</title>
    <link href="https://luorongluorong.github.io/2023/02/16/source_codes/java_arrays_sort/"/>
    <id>https://luorongluorong.github.io/2023/02/16/source_codes/java_arrays_sort/</id>
    <published>2023-02-16T11:02:10.000Z</published>
    <updated>2023-02-17T02:30:48.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="脉络"><a href="#脉络" class="headerlink" title="脉络"></a>脉络</h1><p>Arrays.sort() 函数可以分为两类：</p><ul><li>对基本类型的排序（int、long、short、char、byte、float、double）</li><li>对非基本类型的排序（Object、T）</li></ul><p>对基本类型的排序是通过调用对应的双轴快排 <strong>DualPivotQuicksort.sort()</strong> 函数完成的。</p><p>对非基本类型的排序采用的是 <strong>TimSort</strong> 或者<strong>归并排序</strong>，在 JDK 1.7 之前，默认采用归并排序，JDK 1.7 及之后，默认采用 TimSort，但可以通过设置 JVM 参数 <code>-Djava.util.Arrays.useLegacyMergeSort=true</code> 继续使用归并排序。</p><h2 id="双轴快排"><a href="#双轴快排" class="headerlink" title="双轴快排"></a>双轴快排</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sorts the specified range of the array using the given</span></span><br><span class="line"><span class="comment"> * workspace array slice if possible for merging</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a the array to be sorted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left the index of the first element, inclusive, to be sorted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right the index of the last element, inclusive, to be sorted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> work a workspace array (slice)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workBase origin of usable space in work array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workLen usable size of work array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right,</span></span><br><span class="line"><span class="params">                 <span class="type">int</span>[] work, <span class="type">int</span> workBase, <span class="type">int</span> workLen)</span> &#123;</span><br><span class="line">    <span class="comment">// Use Quicksort on small arrays</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">        sort(a, left, right, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Index run[i] is the start of i-th run</span></span><br><span class="line"><span class="comment">     * (ascending or descending sequence).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>[] run = <span class="keyword">new</span> <span class="title class_">int</span>[MAX_RUN_COUNT + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; run[<span class="number">0</span>] = left;</span><br><span class="line">    <span class="comment">// Check if the array is nearly sorted</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[k] &lt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// ascending</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &lt;= a[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] &gt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// descending</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &gt;= a[k]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> run[count] - <span class="number">1</span>, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[lo]; a[lo] = a[hi]; a[hi] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// equal</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] == a[k]; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m == <span class="number">0</span>) &#123;</span><br><span class="line">                    sort(a, left, right, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The array is not highly structured,</span></span><br><span class="line"><span class="comment">         * use Quicksort instead of merge sort.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">            sort(a, left, right, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check special cases</span></span><br><span class="line">    <span class="comment">// Implementation note: variable &quot;right&quot; is increased by 1.</span></span><br><span class="line">    <span class="keyword">if</span> (run[count] == right++) &#123; <span class="comment">// The last run contains one element</span></span><br><span class="line">        run[++count] = right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123; <span class="comment">// The array is already sorted</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Determine alternation base for merge</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">odd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>; (n &lt;&lt;= <span class="number">1</span>) &lt; count; odd ^= <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Use or create temporary array b for merging</span></span><br><span class="line">    <span class="type">int</span>[] b;                 <span class="comment">// temp array; alternates with a</span></span><br><span class="line">    <span class="type">int</span> ao, bo;              <span class="comment">// array offsets from &#x27;left&#x27;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">blen</span> <span class="operator">=</span> right - left; <span class="comment">// space needed for b</span></span><br><span class="line">    <span class="keyword">if</span> (work == <span class="literal">null</span> || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">        work = <span class="keyword">new</span> <span class="title class_">int</span>[blen];</span><br><span class="line">        workBase = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (odd == <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">        b = a;</span><br><span class="line">        bo = <span class="number">0</span>;</span><br><span class="line">        a = work;</span><br><span class="line">        ao = workBase - left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = work;</span><br><span class="line">        ao = <span class="number">0</span>;</span><br><span class="line">        bo = workBase - left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Merging</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> last; count &gt; <span class="number">1</span>; count = last) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (last = <span class="number">0</span>) + <span class="number">2</span>; k &lt;= count; k += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> run[k], mi = run[k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> run[k - <span class="number">2</span>], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                    b[i + bo] = a[p++ + ao];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    b[i + bo] = a[q++ + ao];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            run[++last] = hi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right, lo = run[count - <span class="number">1</span>]; --i &gt;= lo;</span><br><span class="line">                b[i + bo] = a[i + ao]</span><br><span class="line">            );</span><br><span class="line">            run[++last] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] t = a; a = b; b = t;</span><br><span class="line">        <span class="type">int</span> <span class="variable">o</span> <span class="operator">=</span> ao; ao = bo; bo = o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sorts the specified range of the array by Dual-Pivot Quicksort.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a the array to be sorted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left the index of the first element, inclusive, to be sorted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right the index of the last element, inclusive, to be sorted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> leftmost indicates if this part is the leftmost in the range</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">boolean</span> leftmost)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Use insertion sort on tiny arrays</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftmost) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Traditional (without sentinel) insertion sort,</span></span><br><span class="line"><span class="comment">             * optimized for server VM, is used in case of</span></span><br><span class="line"><span class="comment">             * the leftmost part.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ai</span> <span class="operator">=</span> a[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (ai &lt; a[j]) &#123;</span><br><span class="line">                    a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                    <span class="keyword">if</span> (j-- == left) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[j + <span class="number">1</span>] = ai;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Skip the longest ascending sequence.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a[++left] &gt;= a[left - <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Every element from adjoining part plays the role</span></span><br><span class="line"><span class="comment">             * of sentinel, therefore this allows us to avoid the</span></span><br><span class="line"><span class="comment">             * left range check on each iteration. Moreover, we use</span></span><br><span class="line"><span class="comment">             * the more optimized algorithm, so called pair insertion</span></span><br><span class="line"><span class="comment">             * sort, which is faster (in the context of Quicksort)</span></span><br><span class="line"><span class="comment">             * than traditional implementation of insertion sort.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> a[k], a2 = a[left];</span><br><span class="line">                <span class="keyword">if</span> (a1 &lt; a2) &#123;</span><br><span class="line">                    a2 = a1; a1 = a[left];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (a1 &lt; a[--k]) &#123;</span><br><span class="line">                    a[k + <span class="number">2</span>] = a[k];</span><br><span class="line">                &#125;</span><br><span class="line">                a[++k + <span class="number">1</span>] = a1;</span><br><span class="line">                <span class="keyword">while</span> (a2 &lt; a[--k]) &#123;</span><br><span class="line">                    a[k + <span class="number">1</span>] = a[k];</span><br><span class="line">                &#125;</span><br><span class="line">                a[k + <span class="number">1</span>] = a2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> a[right];</span><br><span class="line">            <span class="keyword">while</span> (last &lt; a[--right]) &#123;</span><br><span class="line">                a[right + <span class="number">1</span>] = a[right];</span><br><span class="line">            &#125;</span><br><span class="line">            a[right + <span class="number">1</span>] = last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Inexpensive approximation of length / 7</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">seventh</span> <span class="operator">=</span> (length &gt;&gt; <span class="number">3</span>) + (length &gt;&gt; <span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Sort five evenly spaced elements around (and including) the</span></span><br><span class="line"><span class="comment">     * center element in the range. These elements will be used for</span></span><br><span class="line"><span class="comment">     * pivot selection as described below. The choice for spacing</span></span><br><span class="line"><span class="comment">     * these elements was empirically determined to work well on</span></span><br><span class="line"><span class="comment">     * a wide variety of inputs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">e3</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// The midpoint</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">e2</span> <span class="operator">=</span> e3 - seventh;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e1</span> <span class="operator">=</span> e2 - seventh;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e4</span> <span class="operator">=</span> e3 + seventh;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e5</span> <span class="operator">=</span> e4 + seventh;</span><br><span class="line">    <span class="comment">// Sort these elements using insertion sort</span></span><br><span class="line">    <span class="keyword">if</span> (a[e2] &lt; a[e1]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e2]; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[e3] &lt; a[e2]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e3]; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[e4] &lt; a[e3]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e4]; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[e5] &lt; a[e4]) &#123; <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[e5]; a[e5] = a[e4]; a[e4] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e3]) &#123; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">                <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pointers</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">less</span>  <span class="operator">=</span> left;  <span class="comment">// The index of the first element of center part</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">great</span> <span class="operator">=</span> right; <span class="comment">// The index before the first element of right part</span></span><br><span class="line">    <span class="keyword">if</span> (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Use the second and fourth of the five sorted elements as pivots.</span></span><br><span class="line"><span class="comment">         * These values are inexpensive approximations of the first and</span></span><br><span class="line"><span class="comment">         * second terciles of the array. Note that pivot1 &lt;= pivot2.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot1</span> <span class="operator">=</span> a[e2];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot2</span> <span class="operator">=</span> a[e4];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The first and the last elements to be sorted are moved to the</span></span><br><span class="line"><span class="comment">         * locations formerly occupied by the pivots. When partitioning</span></span><br><span class="line"><span class="comment">         * is complete, the pivots are swapped back into their final</span></span><br><span class="line"><span class="comment">         * positions, and excluded from subsequent sorting.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a[e2] = a[left];</span><br><span class="line">        a[e4] = a[right];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Skip elements, which are less or greater than pivot values.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (a[++less] &lt; pivot1);</span><br><span class="line">        <span class="keyword">while</span> (a[--great] &gt; pivot2);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Partitioning:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   left part           center part                   right part</span></span><br><span class="line"><span class="comment">         * +--------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">         * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span></span><br><span class="line"><span class="comment">         * +--------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">         *               ^                          ^       ^</span></span><br><span class="line"><span class="comment">         *               |                          |       |</span></span><br><span class="line"><span class="comment">         *              less                        k     great</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Invariants:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *              all in (left, less)   &lt; pivot1</span></span><br><span class="line"><span class="comment">         *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span></span><br><span class="line"><span class="comment">         *              all in (great, right) &gt; pivot2</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Pointer k is the first index of ?-part.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> less - <span class="number">1</span>; ++k &lt;= great; ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ak</span> <span class="operator">=</span> a[k];</span><br><span class="line">            <span class="keyword">if</span> (ak &lt; pivot1) &#123; <span class="comment">// Move a[k] to left part</span></span><br><span class="line">                a[k] = a[less];</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Here and below we use &quot;a[i] = b; i++;&quot; instead</span></span><br><span class="line"><span class="comment">                 * of &quot;a[i++] = b;&quot; due to performance issue.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                a[less] = ak;</span><br><span class="line">                ++less;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ak &gt; pivot2) &#123; <span class="comment">// Move a[k] to right part</span></span><br><span class="line">                <span class="keyword">while</span> (a[great] &gt; pivot2) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (great-- == k) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[great] &lt; pivot1) &#123; <span class="comment">// a[great] &lt;= pivot2</span></span><br><span class="line">                    a[k] = a[less];</span><br><span class="line">                    a[less] = a[great];</span><br><span class="line">                    ++less;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// pivot1 &lt;= a[great] &lt;= pivot2</span></span><br><span class="line">                    a[k] = a[great];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Here and below we use &quot;a[i] = b; i--;&quot; instead</span></span><br><span class="line"><span class="comment">                 * of &quot;a[i--] = b;&quot; due to performance issue.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                a[great] = ak;</span><br><span class="line">                --great;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Swap pivots into their final positions</span></span><br><span class="line">        a[left]  = a[less  - <span class="number">1</span>]; a[less  - <span class="number">1</span>] = pivot1;</span><br><span class="line">        a[right] = a[great + <span class="number">1</span>]; a[great + <span class="number">1</span>] = pivot2;</span><br><span class="line">        <span class="comment">// Sort left and right parts recursively, excluding known pivots</span></span><br><span class="line">        sort(a, left, less - <span class="number">2</span>, leftmost);</span><br><span class="line">        sort(a, great + <span class="number">2</span>, right, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If center part is too large (comprises &gt; 4/7 of the array),</span></span><br><span class="line"><span class="comment">         * swap internal pivot values to ends.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Skip elements, which are equal to pivot values.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (a[less] == pivot1) &#123;</span><br><span class="line">                ++less;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (a[great] == pivot2) &#123;</span><br><span class="line">                --great;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Partitioning:</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *   left part         center part                  right part</span></span><br><span class="line"><span class="comment">             * +----------------------------------------------------------+</span></span><br><span class="line"><span class="comment">             * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span></span><br><span class="line"><span class="comment">             * +----------------------------------------------------------+</span></span><br><span class="line"><span class="comment">             *              ^                        ^       ^</span></span><br><span class="line"><span class="comment">             *              |                        |       |</span></span><br><span class="line"><span class="comment">             *             less                      k     great</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Invariants:</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *              all in (*,  less) == pivot1</span></span><br><span class="line"><span class="comment">             *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span></span><br><span class="line"><span class="comment">             *              all in (great, *) == pivot2</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Pointer k is the first index of ?-part.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            outer:</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> less - <span class="number">1</span>; ++k &lt;= great; ) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ak</span> <span class="operator">=</span> a[k];</span><br><span class="line">                <span class="keyword">if</span> (ak == pivot1) &#123; <span class="comment">// Move a[k] to left part</span></span><br><span class="line">                    a[k] = a[less];</span><br><span class="line">                    a[less] = ak;</span><br><span class="line">                    ++less;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ak == pivot2) &#123; <span class="comment">// Move a[k] to right part</span></span><br><span class="line">                    <span class="keyword">while</span> (a[great] == pivot2) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (great-- == k) &#123;</span><br><span class="line">                            <span class="keyword">break</span> outer;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (a[great] == pivot1) &#123; <span class="comment">// a[great] &lt; pivot2</span></span><br><span class="line">                        a[k] = a[less];</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Even though a[great] equals to pivot1, the</span></span><br><span class="line"><span class="comment">                         * assignment a[less] = pivot1 may be incorrect,</span></span><br><span class="line"><span class="comment">                         * if a[great] and pivot1 are floating-point zeros</span></span><br><span class="line"><span class="comment">                         * of different signs. Therefore in float and</span></span><br><span class="line"><span class="comment">                         * double sorting methods we have to use more</span></span><br><span class="line"><span class="comment">                         * accurate assignment a[less] = a[great].</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        a[less] = pivot1;</span><br><span class="line">                        ++less;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// pivot1 &lt; a[great] &lt; pivot2</span></span><br><span class="line">                        a[k] = a[great];</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[great] = ak;</span><br><span class="line">                    --great;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Sort center part recursively</span></span><br><span class="line">        sort(a, less, great, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Partitioning with one pivot</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Use the third of the five sorted elements as pivot.</span></span><br><span class="line"><span class="comment">         * This value is inexpensive approximation of the median.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> a[e3];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Partitioning degenerates to the traditional 3-way</span></span><br><span class="line"><span class="comment">         * (or &quot;Dutch National Flag&quot;) schema:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   left part    center part              right part</span></span><br><span class="line"><span class="comment">         * +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">         * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span></span><br><span class="line"><span class="comment">         * +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">         *              ^              ^        ^</span></span><br><span class="line"><span class="comment">         *              |              |        |</span></span><br><span class="line"><span class="comment">         *             less            k      great</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Invariants:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   all in (left, less)   &lt; pivot</span></span><br><span class="line"><span class="comment">         *   all in [less, k)     == pivot</span></span><br><span class="line"><span class="comment">         *   all in (great, right) &gt; pivot</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Pointer k is the first index of ?-part.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> less; k &lt;= great; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[k] == pivot) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ak</span> <span class="operator">=</span> a[k];</span><br><span class="line">            <span class="keyword">if</span> (ak &lt; pivot) &#123; <span class="comment">// Move a[k] to left part</span></span><br><span class="line">                a[k] = a[less];</span><br><span class="line">                a[less] = ak;</span><br><span class="line">                ++less;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// a[k] &gt; pivot - Move a[k] to right part</span></span><br><span class="line">                <span class="keyword">while</span> (a[great] &gt; pivot) &#123;</span><br><span class="line">                    --great;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[great] &lt; pivot) &#123; <span class="comment">// a[great] &lt;= pivot</span></span><br><span class="line">                    a[k] = a[less];</span><br><span class="line">                    a[less] = a[great];</span><br><span class="line">                    ++less;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// a[great] == pivot</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Even though a[great] equals to pivot, the</span></span><br><span class="line"><span class="comment">                     * assignment a[k] = pivot may be incorrect,</span></span><br><span class="line"><span class="comment">                     * if a[great] and pivot are floating-point</span></span><br><span class="line"><span class="comment">                     * zeros of different signs. Therefore in float</span></span><br><span class="line"><span class="comment">                     * and double sorting methods we have to use</span></span><br><span class="line"><span class="comment">                     * more accurate assignment a[k] = a[great].</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    a[k] = pivot;</span><br><span class="line">                &#125;</span><br><span class="line">                a[great] = ak;</span><br><span class="line">                --great;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Sort left and right parts recursively.</span></span><br><span class="line"><span class="comment">         * All elements from center part are equal</span></span><br><span class="line"><span class="comment">         * and, therefore, already sorted.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sort(a, left, less - <span class="number">1</span>, leftmost);</span><br><span class="line">        sort(a, great + <span class="number">1</span>, right, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码的整体思路的流程图。<br><img src="static/algorithms/sort6-Arrays.sort%E6%96%B9%E6%B3%95%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86.png" alt="Alt text"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://leetcode.cn/leetbook/read/sort-algorithms">排序算法图文学</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;脉络&quot;&gt;&lt;a href=&quot;#脉络&quot; class=&quot;headerlink&quot; title=&quot;脉络&quot;&gt;&lt;/a&gt;脉络&lt;/h1&gt;&lt;p&gt;Arrays.sort() 函数可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对基本类型的排序（int、long、short、char、byte</summary>
      
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://luorongluorong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://luorongluorong.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="源码" scheme="https://luorongluorong.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>TODO_十大排序算法</title>
    <link href="https://luorongluorong.github.io/2023/02/16/algorithms/sort/"/>
    <id>https://luorongluorong.github.io/2023/02/16/algorithms/sort/</id>
    <published>2023-02-16T01:59:11.000Z</published>
    <updated>2023-02-17T02:31:00.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十大排序算法"><a href="#十大排序算法" class="headerlink" title="十大排序算法"></a>十大排序算法</h1><p>选泡插：选择排序、冒泡排序、插入排序</p><p>快归希堆：快速排序、归并排序、希尔排序、堆排序</p><p>桶计基：桶排序、计数排序、基数排序</p><p>8种常见排序中（快排、希尔、堆排、归并、冒泡、选择、插入、基数排序）=&gt; <code>快些（希尔）选堆不稳定</code></p><ul><li>冒泡排序（Bubble Sort）</li><li>插入排序（Insertion Sort）</li><li>希尔排序（Shell Sort）</li><li>选择排序（Selection Sort）</li><li>快速排序（Quick Sort）</li><li>归并排序（Merge Sort）</li><li>堆排序（Heap Sort）</li><li>计数排序（Counting Sort）</li><li>桶排序（Bucket Sort）</li><li>基数排序（Radix Sort）</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="时间复杂度-O-n-2-的排序算法"><a href="#时间复杂度-O-n-2-的排序算法" class="headerlink" title="时间复杂度 O(n^2) 的排序算法"></a>时间复杂度 O(n^2) 的排序算法</h3><p>冒泡排序<br>冒泡排序有两种优化方式：</p><p>记录当前轮次是否发生过交换，没有发生过交换表示数组已经有序；<br>记录上次发生交换的位置，下一轮排序时只比较到此位置。<br>选择排序<br>选择排序可以演变为二元选择排序：</p><p>二元选择排序：一次遍历选出两个值——最大值和最小值；<br>二元选择排序剪枝优化：当某一轮遍历出现最大值和最小值相等，表示数组中剩余元素已经全部相等。<br>插入排序<br>插入排序有两种写法：</p><p>交换法：新数字通过不断交换找到自己合适的位置；<br>移动法：旧数字不断向后移动，直到新数字找到合适的位置。<br>相同点<br>时间复杂度都是  O(n^2) ，空间复杂度都是 O(1)。</p><p>都需要采用两重循环。</p><p>不同点<br>选择排序是不稳定的，冒泡排序、插入排序是稳定的；<br>在这三个排序算法中，选择排序交换的次数是最少的；<br>在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。</p><h3 id="时间复杂度-O-n-log-n-的排序算法"><a href="#时间复杂度-O-n-log-n-的排序算法" class="headerlink" title="时间复杂度 O(n log n) 的排序算法"></a>时间复杂度 O(n log n) 的排序算法</h3><p>希尔排序<br>希尔排序是一个承上启下的算法，通过交换间隔较远的元素，使得一次交换能消除一个以上的逆序对，打破了在空间复杂度为 O(1) 的情况下，时间复杂度 O(n^2) 的魔咒。它启发出了后续一系列时间复杂度为 O(nlogn)，空间复杂度为 O(1) 的排序算法。<br>希尔排序本质上是插入排序的优化，先对间隔较大的元素进行插入排序，完成宏观调控，然后逐步缩小间隔，最后一轮一定是间隔为<br>1<br>1 的排序，也就是插入排序。间隔在希尔排序中被称为「增量」，增量序列不同，希尔排序的效率也不同。<br>堆排序<br>堆排序分为两步：初始化建堆、重建堆。排序过程是：</p><p>用数列构建出一个大顶堆，取出堆顶的数字；<br>调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字；<br>循环往复，完成整个排序。<br>快速排序<br>快速排序算法是面试中考察的重点，也是应用最广泛的排序算法。排序过程是：</p><p>从数组中取出一个数，称之为基数（pivot）；<br>遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域；<br>将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。<br>快速排序中最重要的是分区算法，最常用的分区算法是双指针分区算法，优点是一次交换可以完成两个数的分区。</p><p>归并排序<br>归并排序分为两步：二分拆数组、不断合并两个有序列表。<br>归并的优化主要在于减少临时空间的开辟。<br>不存在空间复杂度为 O(1) 的归并排序。<br>相同点<br>平均时间复杂度都在 O(n) 到 O(n^2) 之间。<br>不同点<br>希尔排序、堆排序、快速排序是不稳定的，归并排序是稳定的。<br>希尔排序的平均复杂度界于 O(n) 到 O(n^2) 之间，普遍认为它最好的时间复杂度为 O(n^1.3)，希尔排序的空间复杂度为 O(1)；堆排序的时间复杂度为 O(nlogn)，空间复杂度为 O(1)，快速排序的平均时间复杂度为 O(nlogn)，平均空间复杂度为 O(logn)；归并排序的时间复杂度是 O(nlogn)，空间复杂度是 O(n)。</p><h3 id="时间复杂度-O-n-的排序算法"><a href="#时间复杂度-O-n-的排序算法" class="headerlink" title="时间复杂度 O(n) 的排序算法"></a>时间复杂度 O(n) 的排序算法</h3><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>通常来说，冒泡排序有三种写法：</p><ul><li>一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位；</li><li>经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序；</li><li>进一步优化的写法：除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始时 swapped 为 true，否则排序过程无法启动</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果没有发生过交换，说明剩余部分已经有序，排序完成</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 设置 swapped 为 false，如果发生交换，则将其置为 true</span></span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 表示发生了交换</span></span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 最后一个没有经过排序的元素的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">indexOfLastUnsortedElement</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 上次发生交换的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">swappedIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; indexOfLastUnsortedElement; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 表示发生了交换</span></span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 更新交换的位置</span></span><br><span class="line">                swappedIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置</span></span><br><span class="line">        indexOfLastUnsortedElement = swappedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序的空间复杂度为 O(1)，时间复杂度为 O(n^2)，第二种、第三种冒泡排序由于经过优化，最好的情况下只需要 O(n) 的时间复杂度。</p><p>但优化后的冒泡排序平均时间复杂度仍然是 O(n^2)，所以这些优化对算法的性能并没有质的提升。正如 Donald E. Knuth（1974 年图灵奖获得者）所言：“冒泡排序法除了它迷人的名字和导致了某些有趣的理论问题这一事实外，似乎没有什么值得推荐的。”</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。</p><p>思考一下，选择排序算法如何实现稳定排序呢？</p><p>实现的方式有很多种，这里给出一种最简单的思路：新开一个数组，将每轮找出的最小值依次添加到新数组中，选择排序算法就变成稳定的了。</p><h2 id="二元选择排序"><a href="#二元选择排序" class="headerlink" title="二元选择排序"></a>二元选择排序</h2><p>选择排序算法也是可以优化的，既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想。</p><p>使用二元选择排序，每轮选择时记录最小值和最大值，可以把数组需要遍历的范围缩小一倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> minIndex, maxIndex;</span><br><span class="line">    <span class="comment">// i 只需要遍历一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最大值的下标</span></span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">        <span class="comment">// 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) maxIndex = minIndex;</span><br><span class="line">        <span class="comment">// 将最大元素交换至末尾</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> arr.length - <span class="number">1</span> - i;</span><br><span class="line">        temp = arr[lastIndex];</span><br><span class="line">        arr[lastIndex] = arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的思想非常简单，生活中有一个很常见的场景：在打扑克牌时，我们一边抓牌一边给扑克牌排序，每次摸一张牌，就将它插入手上已有的牌中合适的位置，逐渐完成整个排序。</p><p>插入排序是稳定的。</p><p>插入排序有两种写法：</p><ul><li>交换法：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。</li><li>移动法：在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。</li></ul><p>在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span></span><br><span class="line">        <span class="comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = currentNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序本质上是对插入排序的一种优化，它利用了插入排序的简单，又克服了插入排序每次只交换相邻两个元素的缺点。它的基本思想是：</p><ul><li>将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组</li><li>逐渐缩小间隔进行下一轮排序</li><li>最后一轮时，取间隔为 1，也就相当于直接使用插入排序。但这时经过前面的「宏观调控」，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成</li></ul><p>其中，每一遍排序的间隔在希尔排序中被称之为增量，所有的增量组成的序列称之为增量序列。增量依次递减，最后一个增量必须为 1，所以希尔排序又被称之为「缩小增量排序」。要是以专业术语来描述希尔排序，可以分为以下两个步骤：</p><ul><li>定义增量序列 </li><li>对每个增量序列进行插入排序</li></ul><p>增量序列的选择会极大地影响希尔排序的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 间隔序列，在希尔排序中我们称之为增量序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">groupStartIndex</span> <span class="operator">=</span> <span class="number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;</span><br><span class="line">            <span class="comment">// 插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> groupStartIndex + gap; currentIndex &lt; arr.length; currentIndex += gap) &#123;</span><br><span class="line">                <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> arr[currentIndex];</span><br><span class="line">                <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> currentIndex - gap;</span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= groupStartIndex &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                    <span class="comment">// 向后挪位置</span></span><br><span class="line">                    arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                    preIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">                arr[preIndex + gap] = currentNumber;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，这段代码可以优化一下。我们现在的处理方式是：处理完一组间隔序列后，再回来处理下一组间隔序列，这非常符合人类思维。但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式。虽然这个过程看起来是在不同的间隔序列中不断跳跃，但站在计算机的角度，它是在访问一段连续数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 间隔序列，在希尔排序中我们称之为增量序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="comment">// 该组前一个数字的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                <span class="comment">// 向后挪位置</span></span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">            arr[preIndex + gap] = currentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增量元素不互质，则小增量可能根本不起作用。</p><p>事实上，希尔排序的增量序列如何选择是一个数学界的难题，但它也是希尔排序算法的核心优化点。数学界有不少的大牛做过这方面的研究。比较著名的有 Hibbard 增量序列、Knuth 增量序列、Sedgewick 增量序列。</p><p><img src="static/algorithms/sort1.png" alt="Alt text"></p><p>以 Knuth 增量序列为例，Knuth 就是上篇文章中吐槽冒泡算法的那个数学家 Donald E. Knuth，使用 Knuth 序列进行希尔排序的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSortByKnuth</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到当前数组需要用到的 Knuth 序列中的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxKnuthNumber</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxKnuthNumber &lt;= arr.length / <span class="number">3</span>) &#123;</span><br><span class="line">        maxKnuthNumber = maxKnuthNumber * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增量按照 Knuth 序列规则依次递减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> maxKnuthNumber; gap &gt; <span class="number">0</span>; gap = (gap - <span class="number">1</span>) / <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="comment">// 该组前一个数字的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                <span class="comment">// 向后挪位置</span></span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">            arr[preIndex + gap] = currentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先根据数组的长度，计算出需要用到的 Knuth 序列中的最大增量值，然后根据 Knuth 序列的规则依次缩小增量，从高增量到低增量分别进行排序。</p><p>使用 Knuth 序列的希尔排序，时间复杂度已经降到了 O(n^2) 以下。但具体时间复杂度是多少，尚未有明确的证明，数学界仅仅是猜想它的平均时间复杂度为 O(n ^ 3/2)。</p><p>虽然插入排序是稳定的排序算法，但<strong>希尔排序是不稳定的</strong>。在增量较大时，排序过程可能会破坏原有数组中相同关键字的相对次序。</p><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><p>事实上，希尔排序时间复杂度非常难以分析，它的平均复杂度界于 O(n) 到 O(n^2) 之间，普遍认为它最好的时间复杂度为 O(n ^ 1.3)。</p><p>希尔排序的空间复杂度为 O(1)，只需要常数级的临时变量。</p><h2 id="希尔排序与-O-n-2-级排序算法的本质区别"><a href="#希尔排序与-O-n-2-级排序算法的本质区别" class="headerlink" title="希尔排序与 O(n^2) 级排序算法的本质区别"></a>希尔排序与 O(n^2) 级排序算法的本质区别</h2><p>相对于前面介绍的冒泡排序、选择排序、插入排序来说，希尔排序的排序过程显得较为复杂，希望读者还没有被绕晕。接下来我们来分析一个有趣的问题：希尔排序凭什么可以打破时间复杂度 O(n^2) 的魔咒呢？它和之前介绍的 O(n^2) 级排序算法的本质区别是什么？</p><p>只要理解了这一点，我们就能知道为什么希尔排序能够承上启下，启发出之后的一系列 O(n^2) 级以下的排序算法。</p><p>这个问题我们可以用逆序对来理解。</p><p>当我们从小到大排序时，在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。</p><p>排序算法本质上就是一个消除逆序对的过程。</p><p>对于随机数组，逆序对的数量是 O(n^2) 级的，如果采用「交换相邻元素」的办法来消除逆序对，每次最多只能消除一组逆序对，因此必须执行 O(n^2) 级的交换次数，这就是为什么冒泡、插入、选择算法只能到 O(n^2) 级的原因。反过来说，基于交换元素的排序算法要想突破 O(n^2) 级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。</p><p>希尔排序算法就是通过这种方式，打破了在空间复杂度为 O(1) 的情况下，时间复杂度为 O(n^2) 的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。</p><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>数组、链表都是一维的数据结构，相对来说比较容易理解，而堆是二维的数据结构，对抽象思维的要求更高，所以许多程序员「谈堆色变」。但堆又是数据结构进阶必经的一步，我们不妨静下心来，将其梳理清楚。</p><p>堆：符合以下两个条件之一的完全二叉树：</p><ul><li>根节点的值 ≥ 子节点的值，这样的堆被称之为最大堆，或大顶堆；</li><li>根节点的值 ≤ 子节点的值，这样的堆被称之为最小堆，或小顶堆。</li></ul><p>堆排序过程如下：</p><ul><li>用数列构建出一个大顶堆，取出堆顶的数字；</li><li>调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字；</li><li><p>循环往复，完成整个排序。<br>整体的思路就是这么简单，我们需要解决的问题有两个：</p></li><li><p>如何用数列构建出一个大顶堆；</p></li><li>取出堆顶的数字后，如何将剩余的数字调整成新的大顶堆。</li></ul><h2 id="构建大顶堆-amp-调整堆"><a href="#构建大顶堆-amp-调整堆" class="headerlink" title="构建大顶堆 &amp; 调整堆"></a>构建大顶堆 &amp; 调整堆</h2><p>构建大顶堆有两种方式：</p><p>方案一：从 0 开始，将每个数字依次插入堆中，一边插入，一边调整堆的结构，使其满足大顶堆的要求；<br>方案二：将整个数列的初始状态视作一棵完全二叉树，自底向上调整树的结构，使其满足大顶堆的要求。<br>方案二更为常用，动图演示如下：</p><p><img src="static/algorithms/sort2.gif" alt="Alt text"></p><p><img src="static/algorithms/sort3.gif" alt="Alt text"></p><p>在介绍堆排序具体实现之前，我们先要了解完全二叉树的几个性质。将根节点的下标视为 0，则完全二叉树有如下性质：</p><p>对于完全二叉树中的第 i 个数，它的左子节点下标：left = 2i + 1<br>对于完全二叉树中的第 i 个数，它的右子节点下标：right = left + 1<br>对于有 n 个元素的完全二叉树 (n≥2)，它的最后一个非叶子结点的下标：n/2 - 1</p><p>堆排序代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建初始大顶堆</span></span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将最大值交换到数组最后</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, i);</span><br><span class="line">        <span class="comment">// 调整剩余数组，使其满足大顶堆</span></span><br><span class="line">        maxHeapify(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建初始大顶堆</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        maxHeapify(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 左子结点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右子结点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 记录根结点、左子树结点、右子树结点三者中的最大值下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="comment">// 与左子树结点比较</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与右子树结点比较</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="comment">// 将最大值交换为根结点</span></span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        <span class="comment">// 再次调整交换数字后的大顶堆</span></span><br><span class="line">        maxHeapify(arr, largest, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>堆排序的第一步就是构建大顶堆，对应代码中的 buildMaxHeap 函数。我们将数组视作一颗完全二叉树，从它的最后一个非叶子结点开始，调整此结点和其左右子树，使这三个数字构成一个大顶堆。</p><p>调整过程由 maxHeapify 函数处理， maxHeapify 函数记录了最大值的下标，根结点和其左右子树结点在经过比较之后，将最大值交换到根结点位置。这样，这三个数字就构成了一个大顶堆。</p><p>需要注意的是，如果根结点和左右子树结点任何一个数字发生了交换，则还需要保证调整后的子树仍然是大顶堆，所以子树会执行一个递归的调整过程。</p><p>当构建出大顶堆之后，就要把冠军交换到数列最后，深藏功与名。来到冠军宝座的新人又要开始向下比较，找到自己的真实位置，使得剩下的 n−1 个数字构建成新的大顶堆。这就是 heapSort 方法的 for 循环中，调用 maxHeapify 的原因。</p><p>变量 heapSize 用来记录还剩下多少个数字没有排序完成，每当交换了一个堆顶的数字，heapSize 就会减 1。在 maxHeapify 方法中，使用 heapSize 来限制剩下的选手，不要和已经躺在数组最后最大的值比较。</p><p>这就是堆排序的思想。学习时我们采用的是最简单的代码实现，在熟练掌握了之后我们就可以加一些小技巧以获得更高的效率。比如我们知道计算机采用二进制来存储数据，数字左移一位表示乘以 2<br>2，右移一位表示除以 2。所以堆排序代码中的arr.length / 2 - 1 可以修改为 (arr.length &gt;&gt; 1) - 1，左子结点下标2 * i + 1可以修改为(i &lt;&lt; 1) + 1。需要注意的是，位运算符的优先级比加减运算的优先级低，所以必须给位运算过程加上括号。</p><blockquote><p>注：在有的文章中，作者将堆的根节点下标视为 1，这样做的好处是使得第 i 个结点的左子结点下标为 2i，右子结点下标为 2i + 1，与 2i + 1 和 2i + 2 相比，计算量会少一点，本文未采取这种实现，但两种实现思路的核心思想都是一致的。</p></blockquote><p>分析可知，堆排序是不稳定的排序算法。</p><p>时间复杂度 &amp; 空间复杂度<br>堆排序分为两个阶段：初始化建堆（buildMaxHeap）和重建堆（maxHeapify，直译为大顶堆化）。所以时间复杂度要从这两个方面分析。</p><p>根据数学运算可以推导出初始化建堆的时间复杂度为 O(n)，重建堆的时间复杂度为 O(nlogn) ，所以堆排序总的时间复杂度为 O(nlogn) 。推导过程较为复杂，故不再给出证明过程。</p><p>堆排序的空间复杂度为 O(1)，只需要常数级的临时变量。</p><p>堆排序是一个优秀的排序算法，但是在实际应用中，快速排序的性能一般会优于堆排序，我们将在下一节介绍快速排序的思想。</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序算法由 C. A. R. Hoare 在 1960 年提出。它的时间复杂度也是 O(nlogn) ，但它在时间复杂度为 O(nlogn)  级的几种排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。</p><p>快速排序算法的基本思想是：</p><ul><li>从数组中取出一个数，称之为基数（pivot）</li><li>遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域</li><li>将左右两个区域视为两个数组，重复前两个步骤，直到排序完成<br>事实上，快速排序的每一次遍历，都将基数摆到了最终位置上。第一轮遍历排好 1 个基数，第二轮遍历排好 2 个基数（每个区域一个基数，但如果某个区域为空，则此轮只能排好一个基数），第三轮遍历排好 4 个基数（同理，最差的情况下，只能排好一个基数），以此类推。总遍历次数为 logn～n 次，每轮遍历的时间复杂度为 O(n)，所以很容易分析出快速排序的时间复杂度为 O(nlogn)  ～ O(n ^ 2)，平均时间复杂度为 O(nlogn) 。</li></ul><p>根据我们分析出的思路，先搭出快速排序的架子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>partition 意为“划分”，我们期望 partition 函数做的事情是：将 arr 从 start 到 end 这一区间的值分成两个区域，左边区域的每个数都比基数小，右边区域的每个数都比基数大，然后返回中间值的下标。</p><p>只要有了这个函数，我们就能写出快速排序的递归函数框架。首先调用 partition 函数得到中间值的下标 middle，然后对左边区域执行快速排序，也就是递归调用 quickSort(arr, start, middle - 1)，再对右边区域执行快速排序，也就是递归调用 quickSort(arr, middle + 1, end)。</p><p>现在还有一个问题，何时退出这个递归函数呢？</p><p>很容易想到，当某个区域只剩下一个数字的时候，自然不需要排序了，此时退出递归函数。实际上还有一种情况，就是某个区域只剩下 0 个数字时，也需要退出递归函数。当 middle 等于 start 或者 end 时，就会出现某个区域剩余数字为 0。</p><p>所以我们可以通过这种方式退出递归函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 当左边区域中至少有 2 个数字时，对左边区域快速排序</span></span><br><span class="line">    <span class="keyword">if</span> (start != middle &amp;&amp; start != middle - <span class="number">1</span>) quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 当右边区域中至少有 2 个数字时，对右边区域快速排序</span></span><br><span class="line">    <span class="keyword">if</span> (middle != end &amp;&amp; middle != end - <span class="number">1</span>) quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在递归之前，先判断此区域剩余数字是否为 0 个或者 1 个，当数字至少为 2 个时，才执行这个区域的快速排序。因为我们知道 middle &gt;= start &amp;&amp; middle &lt;= end 必然成立，所以判断剩余区域的数字为 0 个或者 1 个也就是指 start 或 end 与 middle 相等或相差 1。</p><p>我们来分析一下这四个判断条件：</p><p>当 start == middle 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end + 1<br>当 start == middle - 1 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end<br>当 middle == end 时，相当于 quickSort(arr, middle + 1, end) 中的 start == end + 1<br>当 middle == end -1 时，相当于 quickSort(arr, middle + 1, end) 中的 start == end</p><p>综上，我们可以将此边界条件统一移到 quickSort 函数之前：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果区域内的数字少于 2 个，退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (start == end || start == end + <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>更进一步，由上文所说的 middle &gt;= start &amp;&amp; middle &lt;= end 可以推出，除了start == end || start == end + 1这两个条件之外，其他的情况下 start 都小于 end。所以我们可以将这个判断条件再次简写为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果区域内的数字少于 2 个，退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样我们就写出了最简洁版的边界条件，我们需要知道，这里的 start &gt;= end 实际上只有两种情况：</p><p>start == end: 表明区域内只有一个数字<br>start == end + 1: 表明区域内一个数字也没有</p><p>不会存在 start 比 end 大 2 或者大 3 之类的。</p><h2 id="分区算法实现"><a href="#分区算法实现" class="headerlink" title="分区算法实现"></a>分区算法实现</h2><p>快速排序中最重要的便是分区算法，也就是 partition 函数。大多数人都能说出快速排序的整体思路，但实现起来却很难一次写对。主要问题就在于分区时存在的各种边界条件，需要读者亲自动手实践才能加深体会。</p><p>上文已经说到，partition 函数需要做的事情就是将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标。那么首先我们要做的事情就是选择一个基数，基数我们一般称之为 pivot，意为“轴”。整个数组就像围绕这个轴进行旋转，小于轴的数字旋转到左边，大于轴的数字旋转到右边。（所谓的双轴快排就是一次选取两个基数，将数组分为三个区域进行旋转，关于双轴快排的内容我们将在后续章节讲解。）</p><p>基数的选择<br>基数的选择没有固定标准，随意选择区间内任何一个数字做基数都可以。通常来讲有三种选择方式：</p><p>选择第一个元素作为基数<br>选择最后一个元素作为基数<br>选择区间内一个随机元素作为基数</p><p>选择的基数不同，算法的实现也不同。实际上第三种选择方式的平均时间复杂度是最优的，待会分析时间复杂度时我们会详细说明。</p><p>本文通过第一种方式来讲解快速排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 取第一个数为基数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[start];</span><br><span class="line">    <span class="comment">// 从第二个数开始分区</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最简单的分区算法"><a href="#最简单的分区算法" class="headerlink" title="最简单的分区算法"></a>最简单的分区算法</h3><p>分区的方式也有很多种，最简单的思路是：从 left 开始，遇到比基数大的数，就交换到数组最后，并将 right 减一，直到 left 和 right 相遇，此时数组就被分成了左右两个区域。再将基数和中间的数交换，返回中间值的下标即可。</p><p>按照这个思路，我们敲出了如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果区域内的数字少于 2 个，退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 取第一个数为基数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[start];</span><br><span class="line">    <span class="comment">// 从第二个数开始分区</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="comment">// left、right 相遇时退出循环</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于基数的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;</span><br><span class="line">        <span class="comment">// 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数</span></span><br><span class="line">        <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">            exchange(arr, left, right);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span></span><br><span class="line">    <span class="keyword">if</span> (left == right &amp;&amp; arr[right] &gt; pivot) right--;</span><br><span class="line">    <span class="comment">// 将基数和中间数交换</span></span><br><span class="line">    <span class="keyword">if</span> (right != start) exchange(arr, start, right);</span><br><span class="line">    <span class="comment">// 返回中间值的下标</span></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双指针分区算法"><a href="#双指针分区算法" class="headerlink" title="双指针分区算法"></a>双指针分区算法</h3><p>除了上述的分区算法外，还有一种双指针的分区算法更为常用：从 left 开始，遇到比基数大的数，记录其下标；再从 right 往前遍历，找到第一个比基数小的数，记录其下标；然后交换这两个数。继续遍历，直到 left 和 right 相遇。然后就和刚才的算法一样了，交换基数和中间值，并返回中间值的下标。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果区域内的数字少于 2 个，退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 取第一个数为基数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[start];</span><br><span class="line">    <span class="comment">// 从第二个数开始分区</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于基数的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;</span><br><span class="line">        <span class="comment">// 找到第一个小于基数的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) right--;</span><br><span class="line">        <span class="comment">// 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            exchange(arr, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span></span><br><span class="line">    <span class="keyword">if</span> (left == right &amp;&amp; arr[right] &gt; pivot) right--;</span><br><span class="line">    <span class="comment">// 将基数和轴交换</span></span><br><span class="line">    exchange(arr, start, right);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样地，我们需要在退出循环后，单独比较 left 和 right 的值。</p><p>从代码实现中可以分析出，快速排序是一种不稳定的排序算法，在分区过程中，相同数字的相对顺序可能会被修改。</p><h2 id="时间复杂度-amp-空间复杂度-1"><a href="#时间复杂度-amp-空间复杂度-1" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><p>快速排序的时间复杂度上文已经提到过，平均时间复杂度为 O(nlogn) ，最坏的时间复杂度为 O(n ^ 2)，空间复杂度与递归的层数有关，每层递归会生成一些临时变量，所以空间复杂度为 O(logn)  ~ O(n)，平均空间复杂度为 O(logn) 。</p><p>回到前文提到的那个问题，为什么说随机选择剩余数组中的一个元素作为基数的方案平均复杂度是最优的呢？要理清这个问题，我们先来看一下什么情况下快速排序算法的时间复杂度最高，一共有两种情况。</p><p>数组为正序或逆序</p><p>理想中的快速排序在第 k 轮遍历中，可以排好 2 ^ k−1 个基数。但我们发现，当数组原本为正序或逆序时，我们将第一个数作为基数的话，每轮分区后，都有一个区域是空的，也就是说数组中剩下的数字都被分到了同一个区域！这就导致了每一轮遍历只能排好一个基数。所以总的比较次数为 (n - 1) + (n - 2) + (n - 3) + … + 1 次，由等差数列求和公式可以计算出总的比较次数为 n(n - 1)/2 次，此时快速排序的时间复杂度达到了 O(n ^ 2) 级。</p><p>有的读者可能会疑惑，既然数组已经有序了，为什么还要再对其排序呢？这个操作看起来毫无意义。但事实可能让你大吃一惊，因为在实际工作中，这种重复排序的需求非常常见。</p><p>设想一个场景，前端程序员从第三方平台提供的接口中获取一列数据，并且产品部门要求前端必须保证这一列数据在展示给用户时是有序的。在测试环境下，前端程序员发现从第三方平台获取到的数据总是有序的，但为了保险起见，他还是不得不对收到的数据再次进行排序。因为第三方平台提供的数据是不可控的，他不能选择相信后台，否则万一哪天后台提供的数据变成了无序的，给用户展示数据时就会出现问题。于是这里就发生了重复排序，此时如果直接使用快速排序就可能出现排序速度很慢，拖慢程序性能的问题。</p><p>如何解决这样的问题呢？其实思路也很简单，只要我们每轮选择的基数不是剩余数组中最大或最小的值就可以了。具体方案有很多种，其中较常用的有三种。</p><p>快速排序的优化思路<br>第一种就是我们在前文中提到的，每轮选择基数时，从剩余的数组中随机选择一个数字作为基数。这样每轮都选到最大或最小值的概率就会变得很低了。所以我们才说用这种方式选择基数，其平均时间复杂度是最优的</p><p>第二种解决方案是在排序之前，先用洗牌算法将数组的原有顺序打乱，以防止原数组正序或逆序。</p><p>Java 已经将洗牌算法封装到了集合类中，即 Collections.shuffle() 函数。洗牌算法由 Ronald A.Fisher 和 Frank Yates 于 1938 年发明，思路是每次从未处理的数据中随机取出一个数字，然后把该数字放在数组中所有未处理数据的尾部。 Collections.shuffle() 函数源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUFFLE_THRESHOLD</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list, Random rnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; SHUFFLE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(list, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object arr[] = list.toArray();</span><br><span class="line">        <span class="comment">// Shuffle array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">        <span class="comment">// Dump array back into list</span></span><br><span class="line">        <span class="comment">// instead of using a raw type here, it&#x27;s possible to capture</span></span><br><span class="line">        <span class="comment">// the wildcard but it will require a call to a supplementary</span></span><br><span class="line">        <span class="comment">// private method</span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">it</span> <span class="operator">=</span> list.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.set(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// instead of using a raw type here, it&#x27;s possible to capture</span></span><br><span class="line">    <span class="comment">// the wildcard but it will require a call to a supplementary</span></span><br><span class="line">    <span class="comment">// private method</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">List</span> <span class="variable">l</span> <span class="operator">=</span> list;</span><br><span class="line">    l.set(i, l.set(j, l.get(i)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Object[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源码中可以看出，对于数据量较小的列表（少于 5 个值），shuffle 函数直接通过列表的 set 方法进行洗牌，否则先将 list 转换为 array，再进行洗牌，以提高交换效率，洗牌完成后再将 array 转成 list 返回。</p><p>还有一种解决方案，既然数组重复排序的情况如此常见，那么我们可以在快速排序之前先对数组做个判断，如果已经有序则直接返回，如果是逆序则直接倒序即可。在 Java 内部封装的 Arrays.sort() 的源码中就采用了此解决方案。</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>核心思路是将两个有序的列表合并成一个有序的列表。</p><p>我们排序时用的都是无序数组，那么上哪里去找这两个有序的数组呢？</p><p>答案是 —— 自己拆分，我们可以把数组不断地拆成两份，直到只剩下一个数字时，这一个数字组成的数组我们就可以认为它是有序的。</p><p>然后通过上述合并有序列表的思路，将 1 个数字组成的有序数组合并成一个包含 2 个数字的有序数组，再将 2 个数字组成的有序数组合并成包含 4 个数字的有序数组…直到整个数组排序完成，这就是归并排序（Merge Sort）的思想。</p><p>为了减少在递归过程中不断开辟空间的问题，我们可以在归并排序之前，先开辟出一个临时空间，在递归过程中统一使用此空间进行归并即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 arr 的 [start, end] 区间归并排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] result)</span> &#123;</span><br><span class="line">    <span class="comment">// 只剩下一个数字，停止拆分</span></span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间</span></span><br><span class="line">    mergeSort(arr, start, middle, result);</span><br><span class="line">    <span class="comment">// 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间</span></span><br><span class="line">    mergeSort(arr, middle + <span class="number">1</span>, end, result);</span><br><span class="line">    <span class="comment">// 合并左右区域到 result 的 [start, end] 区间</span></span><br><span class="line">    merge(arr, start, end, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] result)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end1</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start2</span> <span class="operator">=</span> end1 + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 用来遍历数组的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> start2;</span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= end1 &amp;&amp; index2 &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[index1] &lt;= arr[index2]) &#123;</span><br><span class="line">            result[index1 + index2 - start2] = arr[index1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[index1 + index2 - start2] = arr[index2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余数字补到结果数组之后</span></span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= end1) &#123;</span><br><span class="line">        result[index1 + index2 - start2] = arr[index1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index2 &lt;= end) &#123;</span><br><span class="line">        result[index1 + index2 - start2] = arr[index2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        arr[start] = result[start++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原地归并排序？</p><p>现在的归并排序看起来仍”美中不足”，那就是仍然需要开辟额外的空间，能不能实现不开辟额外空间的归并排序呢？好像是可以做到的。在一些文章中，将这样的归并排序称之为 In-Place Merge Sort，直译为原地归并排序。</p><p>所谓的原地归并排序事实上并不存在，它打着归并排序的幌子，卖的是插入排序的思想，实际排序效率比归并排序低得多。</p><h2 id="时间复杂度-amp-空间复杂度-2"><a href="#时间复杂度-amp-空间复杂度-2" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><p>归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分 logn 次，每层执行的比较次数都约等于 n 次，所以时间复杂度是 O(nlogn)。</p><p>空间复杂度是 O(n)，主要占用空间的就是我们在排序前创建的长度为 n 的 result 数组。</p><p>分析归并的过程可知，归并排序是一种稳定的排序算法。其中，对算法稳定性非常重要的一行代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr[index1] &lt;= arr[index2]) &#123;</span><br><span class="line">    result[index1 + index2 - start2] = arr[index1++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们通过arr[index1] &lt;= arr[index2]来合并两个有序数组，保证了原数组中，相同的元素相对顺序不会变化，如果这里的比较条件写成了arr[index1] &lt; arr[index2]，则归并排序将变得不稳定。</p><p>总结起来，归并排序分成两步，一是拆分数组，二是合并数组，它是分治思想的典型应用。分治的意思是“分而治之”，分的时候体现了二分的思想，“一尺之棰，日取其半，logn 世竭”，治是一个滚雪球的过程，将 1 个数字组成的有序数组合并成一个包含 2 个数字的有序数组，再将 2 个数字组成的有序数组合并成包含 4 个数字的有序数组…如《活着》一书中的经典名句：“小鸡长大了就变成了鹅；鹅长大了，就变成了羊；羊再长大了，就变成了牛…”</p><p>由于性能较好，且排序稳定，归并排序应用非常广泛，Arrays.sort() 源码中的 TimSort就是归并排序的优化版。</p><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>O(n) 级的排序算法存在已久，但他们只能用于特定的场景。</p><p>计数排序就是一种时间复杂度为 O(n)  的排序算法，该算法于 1954 年由 Harold H. Seward 提出。在对一定范围内的整数排序时，它的复杂度为 O(n+k)（其中 k 是整数的范围大小）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 判空及防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="type">int</span>[] counting = <span class="keyword">new</span> <span class="title class_">int</span>[range];</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        counting[element - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录前面比自己小的数字的总数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preCounts</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前的数字比下一个数字小，累计到 preCounts 中</span></span><br><span class="line">        preCounts += counting[i];</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的起始下标位置。位置 = 前面比自己小的数字的总数。</span></span><br><span class="line">        counting[i] = preCounts - counting[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// counting[element - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[element - min]] = element;</span><br><span class="line">        <span class="comment">// 更新 counting[element - min]，指向此元素的下一个下标</span></span><br><span class="line">        counting[element - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>倒序遍历的计数排序，性能更好。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="type">int</span>[] counting = <span class="keyword">new</span> <span class="title class_">int</span>[range];</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        counting[element - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个元素在结果数组中的最后一个下标位置 = 前面比自己小的数字的总数 + 自己的数量 - 1。我们将 counting[0] 先减去 1，后续 counting 直接累加即可</span></span><br><span class="line">    counting[<span class="number">0</span>]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的最后一个下标位置。位置 = 前面比自己小的数字的总数 + 自己的数量 - 1</span></span><br><span class="line">        <span class="comment">// 由于 counting[0] 已经减了 1，所以后续的减 1 可以省略。</span></span><br><span class="line">        counting[i] += counting[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="comment">// 从后往前遍历数组，通过 counting 中记录的下标位置，将 arr 中的元素放到 result 数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// counting[arr[i] - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[arr[i] - min]] = arr[i];</span><br><span class="line">        <span class="comment">// 更新 counting[arr[i] - min]，指向此元素的前一个下标</span></span><br><span class="line">        counting[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="时间复杂度-amp-空间复杂度-3"><a href="#时间复杂度-amp-空间复杂度-3" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><p>从计数排序的实现代码中，可以看到，每次遍历都是进行 n 次或者 k 次，所以计数排序的时间复杂度为 O(n+k) ，k 表示数据的范围大小。</p><p>用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 O(n+k) 。</p><p>需要注意的是，一般我们分析时间复杂度和空间复杂度时，常数项都是忽略不计的。但计数排序的常数项可能非常大，以至于我们无法忽略。</p><p>计数排序只适用于数据范围不大的场景。例如对考试成绩排序就非常适合计数排序，如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。</p><h2 id="计数排序与-O-nlogn-级排序算法的本质区别"><a href="#计数排序与-O-nlogn-级排序算法的本质区别" class="headerlink" title="计数排序与 O(nlogn)  级排序算法的本质区别"></a>计数排序与 O(nlogn)  级排序算法的本质区别</h2><p>计数排序凭什么能够突破 O(nlogn)  的下界呢？它和之前介绍的 O(nlogn)  级排序算法的本质区别是什么？</p><p>这个问题我们可以从决策树的角度和概率的角度来理解。</p><p>决策树<br>决策树是一棵完全二叉树，它可以反映比较排序算法中对所有元素的比较操作。</p><p>以包含三个整数的数组 [a,b,c] 为例，基于比较的排序算法的排序过程可以抽象为这样一棵 决策树：</p><p>这棵决策树上的每一个叶结点都对应了一种可能的排列，从根结点到任意一个叶结点之间的最短路径（也称为「简单路径」）的长度，表示的是完成对应排列的比较次数。所以从根结点到叶结点之间的最长简单路径的长度，就表示比较排序算法中最坏情况下的比较次数。</p><p>设决策树的高度为 h，叶结点的数量为 l，排序元素总数为 n 。</p><p>因为叶结点最多有 n! 个，所以我们可以得到：n! ≤ l，又因为一棵高度为 h 的二叉树，叶结点的数量最多为 2 ^ h，所以我们可以得到：n!≤l≤2 ^ h</p><p>对该式两边取对数，可得：h≥log(n!)</p><p>由斯特林（Stirling）近似公式，可知 lg(n!)=O(nlogn)</p><p>所以 h≥log(n!)=O(nlogn)</p><p>于是我们可以得出以下定理：</p><blockquote><p>《算法导论》定理 8.1：在最坏情况下，任何比较排序算法都需要做 O(nlogn)  次比较。</p></blockquote><p>由此我们还可以得到以下推论：</p><blockquote><p>《算法导论》推论 8.2：堆排序和归并排序都是渐进最优的比较排序算法。</p></blockquote><p>到这里我们就可以得出结论了，如果基于比较来进行排序，无论怎么优化都无法突破 O(nlogn)  的下界。计数排序和基于比较的排序算法相比，根本区别就在于：它不是基于比较的排序算法，而是利用了数字本身的属性来进行的排序。整个计数排序算法中没有出现任何一次比较。</p><p>概率<br>相信大家都玩过「猜数字」游戏：一方从 [1, 100] 中随机选取一个数字，另一方来猜。每次猜测都会得到「高了」或者「低了」的回答。怎样才能以最少的次数猜中呢？</p><p>答案很简单：二分。</p><p>二分算法能够保证每次都排除一半的数字。每次猜测不会出现惊喜（一次排除了多于一半的数字），也不会出现悲伤（一次只排除了少于一半的数字），因为答案的每一个分支都是等概率的，所以它在最差的情况下表现是最好的，猜测的一方在 logn 次以内必然能够猜中。</p><p>基于比较的排序算法与「猜数字」是类似的，每次比较，我们只能得到 a&gt;b 或者 a≤b 两种结果，如果我们把数组的全排列比作一块区域，那么每次比较都只能将这块区域分成两份，也就是说每次比较最多排除掉 1/2 的可能性。</p><p>再来看计数排序算法，计数排序时申请了长度为 k 的计数数组，在遍历每一个数字时，这个数字落在计数数组中的可能性共有 k 种，但通过数字本身的大小属性，我们可以「一次」把它放到正确的位置上。相当于一次排除了 (k−1)/k 种可能性。</p><p>这就是计数排序算法比基于比较的排序算法更快的根本原因。</p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>想一下我们是怎么对日期进行排序的。这种利用多关键字进行排序的思想就是基数排序，和计数排序一样，这也是一种线性时间复杂度的排序算法。其中的每个关键字都被称作一个基数。</p><p>比如我们对 999,997,866,666 这四个数字进行基数排序，过程如下：</p><ul><li>先看第一位基数：6 最小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系。</li><li>再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系</li><li>再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999</li></ul><p>基数排序有两种实现方式。本例属于「最高位优先法」，简称 MSD (Most significant digital)，思路是从最高位开始，依次对基数进行排序。</p><p>与之对应的是「最低位优先法」，简称 LSD (Least significant digital)。思路是从最低位开始，依次对基数进行排序。使用 LSD 必须保证对基数进行排序的过程是稳定的。</p><p>通常来讲，LSD 比 MSD 更常用。以上述排序过程为例，因为使用的是 MSD，所以在第二步比较两个以 9 开头的数字时，其他基数开头的数字不得不放到一边。体现在计算机中，这里会产生很多临时变量。</p><p>但在采用 LSD 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 LSD 的基数排序更符合计算机的操作习惯。</p><p>基数排序最早是用在卡片排序机上的，一张卡片有 80 列，类似一个 80 位的整数。机器通过在卡片不同位置上穿孔表示当前基数的大小。卡片排序机的排序过程就是采用的 LSD 的基数排序。</p><p><img src="static/algorithms/sort5.gif" alt="Alt text"></p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://leetcode.cn/leetbook/read/sort-algorithms">排序算法图文学</a></li></ul>]]></content>
    
    
    <summary type="html">十大排序算法包括选择排序、冒泡排序、插入排序、快速排序、归并排序、希尔排序、堆排序、桶排序、计数排序、基数排序。</summary>
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://luorongluorong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://luorongluorong.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>从波提切利到梵高——英国国家美术馆珍藏展</title>
    <link href="https://luorongluorong.github.io/2023/02/15/diaries/museum_exhibition_bottlicelli_to_van_gogh/"/>
    <id>https://luorongluorong.github.io/2023/02/15/diaries/museum_exhibition_bottlicelli_to_van_gogh/</id>
    <published>2023-02-15T09:21:11.000Z</published>
    <updated>2023-02-16T13:57:49.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从波提切利到梵高——英国国家美术馆珍藏展"><a href="#从波提切利到梵高——英国国家美术馆珍藏展" class="headerlink" title="从波提切利到梵高——英国国家美术馆珍藏展"></a>从波提切利到梵高——英国国家美术馆珍藏展</h1><blockquote><p><a href="https://mp.weixin.qq.com/s/tRktZH3iKV2wWOFyKq2g3w">https://mp.weixin.qq.com/s/tRktZH3iKV2wWOFyKq2g3w</a></p></blockquote><p>Botticelli to Van Gogh</p><p>Masterpieces from the National Gallery, London</p><blockquote><p>2023年1月17日至5月7日，上海博物馆首度联手英国国家美术馆，推出“对话世界”文物艺术大展系列的第二个展览——“从波提切利到梵高：英国国家美术馆珍藏展”。展览通过 52 件大师杰作，为观众奉上一场视觉盛宴，讲述欧洲绘画的故事。<br>本次展览中，观众可以欣赏到波提切利、拉斐尔、提香、戈塞特、卡拉瓦乔、普桑、克劳德、凡·代克，伦勃朗、卡纳莱托、康斯特布尔、透纳、塞尚、高更、马奈、莫奈以及梵高等艺术史中如雷贯耳的大师杰作；了解到意大利文艺复兴、北方文艺复兴、威尼斯画派、样式主义、巴洛克、荷兰画派、洛可可、古典主义、浪漫主义、印象派、后印象派等熠熠生辉的艺术流派。这也是上海博物馆馆庆70周年为公众奉上的重磅展览。观众们无需前往伦敦,便可欣赏到欧洲艺术巨匠的绘画杰作。</p></blockquote><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_1_poster.jpg" alt="Alt text"></p><p>漫步展厅，眼前呈现的仿佛是一片欧洲油画史的缩影。展览第一至第五单元，主要展现了从早期文艺复兴至巴洛克时期（15世纪至17世纪）的绘画作品。那么绘画是如何成为艺术的？欧洲油画的技法从何而来？当时艺术行业的生产模式又是怎样？透过作品，亲近艺术史，本期我们将与大家一起细读欣赏英国国家美术馆珍藏展前五单元的内容。</p><blockquote><p>找一找本次展览的植物和屋顶。</p></blockquote><p><a href="https://mp.weixin.qq.com/s/m5Lpz6fwBrgzZLTfCs8Z2A">https://mp.weixin.qq.com/s/m5Lpz6fwBrgzZLTfCs8Z2A</a></p><h1 id="追溯欧洲绘画传统"><a href="#追溯欧洲绘画传统" class="headerlink" title="追溯欧洲绘画传统"></a>追溯欧洲绘画传统</h1><p>欧洲早在古希腊、古罗马时期就有类似于今日的绘画艺术，但岁月悠远，盛况难以悉知。今人所熟悉的欧洲绘画传统，兴起于15-16世纪的意大利及欧洲北方。这一时期艺术家开始为公众所瞩目，出现了艺术收藏，有人撰写画论和艺术家传记，欧洲最早的美术学院也应运而生，简而言之，绘画开始从手艺转变为艺术。</p><p>伴随着艺术的觉醒，绘画技术突飞猛进，油画逐渐取代坦培拉（即蛋彩画，Tempera）成为优势画种，速写也首次被艺术家用来记录灵感，这时期有许多艺术家投入到对透视和解剖的研究中，迫不及待地把新知识用于创作。就在短短的两三百年间，欧洲社会对绘画的态度、画家的精神风貌以及绘画技术都发生了惊人的改变，后世怀着敬畏之心把这一时期称为“文艺复兴”（Renaissance），是不无道理的。</p><p>在本次展览第一单元中，波提切利、梅西那等画家展现了15世纪意大利早期文艺复兴的生机勃勃。若对比梅西那《书房中的圣哲罗姆》与前代画作，不难看出经过15世纪大师们的努力，两个绘画问题已经得到了开创性的解决。首先是单个人物的造型问题，即怎么把一个人物画得浑圆立体、有呼吸、有质感；然后是画面空间问题，即怎么把人物与背景之间的关系画得令人信服的问题。 </p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_2.jpg" alt="Alt text"></p><p>《书房中的圣哲罗姆》安托内罗·达·梅西那</p><p>约1475年，石灰板油画</p><p>© The National Gallery, London</p><h1 id="从坦培拉（蛋彩画）到油画"><a href="#从坦培拉（蛋彩画）到油画" class="headerlink" title="从坦培拉（蛋彩画）到油画"></a>从坦培拉（蛋彩画）到油画</h1><p>文艺复兴时期的大量画作都是依附于建筑和器物的壁画、祭坛画等，能来到中国观众面前的架上绘画杰作尚属少数，其基材是木板与画布兼用，技法是坦培拉与油画兼用，这一时期是坦培拉技法最为辉煌的时期，也是坦培拉向油画过渡的时期。</p><p><strong>坦培拉技法</strong>是主要以蛋黄加水作为媒介剂来调和颜料的一种作画技法，它色彩透明，干燥后坚固稳定，很适合湿壁画（Fresco）的要求，但由于干燥速度太快，使用时难以调色，只能通过往单一颜色中调白、调黑来控制明度的变化，像素描排线那样描绘，逐笔依次形成明暗过渡的素描关系。这种技法在佛罗伦萨有很强的传统，由于它天然倾向于用素描和线条来建构画面，因此<em>佛罗伦萨画派</em>也被称为“<strong>素描派</strong>”。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_3.jpg" alt="Alt text"></p><p>《圣泽诺比乌斯的三个奇迹》 桑德罗·波提切利</p><p>约1500年，木板蛋彩画</p><p>© The National Gallery, London</p><p>油画是以油作为媒介来调和颜料的作画技法，用于罩染和厚涂均合适，且干燥速度适当，便于调色，经得住反复修改和塑造。油画是北方的传统技法，本次参展的戈塞特、昆廷·马西斯等北方大师都用油画技法，他们的作品往往色彩饱满，刻画精细，对皮毛、布料、砖石等材料的质感表现也属一流。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_4.jpg" alt="Alt text"></p><p>《年轻公主（丹麦多萝西娅？）》 扬·戈塞特</p><p>约1530-1532年，橡木板油画</p><p>© The National Gallery, London</p><p>大约自15世纪中期以后，意大利画家为了拓展坦培拉的表现力，普遍在坦培拉底色之上罩染油性色层，发展出<strong>坦培拉与油画技术相结合</strong>的技法。当时威尼斯与北方画家接触较密切，是南方最喜欢布面油画的地区，<em>威尼斯画派</em>的代表人物提香、丁托列托等强调肌肤色彩的生动感，对轮廓线和服饰进行虚实处理，也开始注意笔触的表现力，形成了与讲求素描的佛罗伦萨派不同的艺术取向，被称为“<strong>色彩派</strong>”，两派艺术取向不同，由此开启了持续至19世纪的素描与色彩之争。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_5.jpg" alt="Alt text"></p><p>《女子肖像》提香</p><p>约1510-1512年，布面油画</p><p>© The National Gallery, London</p><h1 id="行业的模式：作坊与委托订制"><a href="#行业的模式：作坊与委托订制" class="headerlink" title="行业的模式：作坊与委托订制"></a>行业的模式：作坊与委托订制</h1><p>在文艺复兴社会的普遍观念中，艺术家仍保留着手艺人的大部分特点。当时展览、拍卖等艺术市场机制还没有出现，艺术家的主要行业模式是<strong>委托订制</strong>（Commission），即先由委托人（Patron）提出要求，画家再根据要求完成画作。画家多半是本地行会的注册师傅，他组建自己的作坊，招收学徒作为助手。学徒平日里磨制颜料，熬胶放稿，从事各种杂务，也练习作画，他们的目标是有朝一日也成为独立行业的师傅。作坊既是生产单位，也是教学单位，大型绘画尤其依赖学徒的协助，最终交付的作品，有些只有关键部分是师傅亲笔所作，其他部分常常交由学徒完成。观念转变是一个漫长的过程，从16世纪开始，大约经过三百年的时间，作坊师傅变成了画室里单打独斗的艺术家，不过委托订制从未消失。在15世纪大师的作坊里，走出了文艺复兴盛期的诸位巨匠。米开朗基罗出自吉兰达约的作坊；拉斐尔出自佩鲁吉诺的作坊；提香出自乔瓦尼·贝利尼的作坊。</p><p>16世纪，米开朗基罗和拉斐尔先后前往罗马，为天主教世界最大的委托人、拥有最重要古典雕刻收藏的教皇工作。本次展出的拉斐尔《圣母子与施洗者圣约翰（加瓦圣母）》，大约作于他到达罗马不久后，当时他正处于风格转变的关头，在随后几年中他以稳健有力、和谐典雅的新风格完成了签字厅（Stanza della Segnatura）壁画，成为照耀百代的艺术伟迹。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_6.jpg" alt="Alt text"></p><p>《圣母子与施洗者圣约翰（加瓦圣母）》 拉斐尔</p><p>约1510-1511年，木板油画</p><p>© The National Gallery, London</p><h1 id="17-世纪欧洲艺术中心"><a href="#17-世纪欧洲艺术中心" class="headerlink" title="17 世纪欧洲艺术中心"></a>17 世纪欧洲艺术中心</h1><p>17世纪的艺术家面对文艺复兴的巨大遗产，也面对着天主教和新教分裂的欧洲。意大利已经成为欧洲艺术的中心，法国和西班牙王室很久以来就礼聘意大利艺术家服务于自己的宫廷，两国的年轻艺术家也把游学意大利看作成才的必由之路。</p><p>普桑毕生的大部分时间都在罗马度过，他虽是法国人，却只有待在意大利的古典废墟中才觉得回到了家，他是17世纪古典主义和素描派的代表人物，他的画有种永恒的秩序感，得到后印象主义大师塞尚的盛赞。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_7.jpg" alt="Alt text"></p><p>《酒神的养育》 尼古拉·普桑</p><p>约1628年，布面油画</p><p>© The National Gallery, London</p><p>另一位人称“克劳德·洛兰”的法国人同样以意大利为家，他是风景画发展中的一个重要人物，探索过户外作画，还把废墟引入画中，他擅长用晨曦和落霞赋予画面一层滤镜般的色调，“克劳德式的风景”成了一个特定的审美意象，强烈地影响了18世纪的英国美学。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_8.jpg" alt="Alt text"></p><p>《圣乌苏拉登船的海港》 克劳德</p><p>1641年，布面油画</p><p>© The National Gallery, London</p><h1 id="油画语言的发展：笔触与表现"><a href="#油画语言的发展：笔触与表现" class="headerlink" title="油画语言的发展：笔触与表现"></a>油画语言的发展：笔触与表现</h1><p>17世纪北方新教地区的艺术家失去了天主教会的大宗订件，一部分画家离开本地前往国外，鲁本斯的学生<strong>凡·代克</strong>即在英国为朝臣贵族画肖像。刚刚独立的荷兰共和国是这旧世界中的新国家，在那里，新的委托人饶有兴致地欣赏着风景、静物、室内景和风俗画等新题材。17世纪，<strong>布面油画</strong>取代木板坦培拉成为具有统治地位的画种，正是在这个世纪里，荷兰最具有影响的画家<strong>伦勃朗</strong>与<strong>鲁本斯</strong>、<strong>委拉斯贵兹</strong>一道，发扬了油画笔触的表现力，完善了油画语言的武库。</p><p>委拉斯贵兹以“直接画法”出名，所谓直接画法就是彻底抛弃三百年来的坦培拉底色，用纯粹的油画颜料直接作画，他第一个这样做，使得油画完全摆脱了坦培拉。委拉斯贵兹在画家生涯的各个时期用过不同画法，他四十多岁效力于西班牙费利佩四世宫廷时，用<strong>直接画法</strong>画了一批名作，包括本次参展的《费尔南多总主教像》。此画以黑红两个大色块衬托出人物的面容，摒弃精致的线条，略去服饰和衬布的细部，痛快地画出而不是制作出主教的神情，潇洒的笔触留在画面上，成为欣赏的对象。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_9.jpg" alt="Alt text"></p><p>《费尔南多总主教肖像》 迭戈·委拉斯贵兹</p><p>1640-1645年，布面油画</p><p>© The National Gallery, London</p><p>伦勃朗是整个绘画史上最杰出的肖像画家之一，他年轻时候有过一段称心岁月，中年迭遭变故，晚岁贫病交加，人们相信他的苦难经历给他的肖像画注入了忧患和深沉。他一生留下多幅自画像，本次参展的《63岁的自画像》以强烈的光影对比突出面容，用阔大的笔触和厚涂法（Impasto），寥寥数笔便塑造出结实的块面。其利用光影对比来建构画面的手法，可以通过卡拉瓦乔，追溯到莱奥纳尔多·达·芬奇的明暗法（Chiaroscuro）。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_10.jpg" alt="Alt text"><br>《63岁的自画像》 伦勃朗</p><p>1669年，布面油画</p><p>© The National Gallery, London</p><p>16世纪威尼斯画派的画家就意识到笔触的表现力，但直到伦勃朗和委拉斯贵兹的时代，笔触才广泛为画家所接受。笔触的模糊性有时比清晰的刻画更有余味，它什么都不像，却又什么都像，它调动观众的想象参与到欣赏中去，补充画家实际上并没有画出的东西。这是一种高超的艺术手法，优秀的文学家也都知道怎么用。除此之外，有意识地把笔触留在画面上，留下作画过程的痕迹，承认这是一幅画而非画中所描绘的现实，让观众体验艺术与现实之间的来回转换——这种态度使绘画超越了再现而成为表现。<strong>绘画语言本身成为欣赏对象，这正是艺术成为艺术的关键所在。</strong></p><h1 id="雅游时代"><a href="#雅游时代" class="headerlink" title="雅游时代"></a>雅游时代</h1><p>一个年轻人只有经历过意大利旅行，瞻仰过那里的古典遗迹和艺术杰作，才算完成了教育——17世纪就有英国人怀着这样的想法踏上旅程，到18世纪这终于成为社会共识，成千上万的英国富家子弟带着家人的叮嘱，在称职或不称职的“伴游导师”（Tutor）陪同下，启程汇入雅游（即壮游，Grand Tour）的洪流。雅游最初主要是英国青年前往意大利的教育旅行，但后来欧洲大陆人和美国人也都参加进来。雅游的内涵一直在变化，但在18世纪的雅游中，艺术成为一个突出的主题。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_11.jpg" alt="Alt text"></p><p>《约翰·斯图亚特勋爵与其兄弟伯纳德·斯图亚特勋爵》 安东尼·凡·代克</p><p>约1638年，布面油画</p><p>© The National Gallery, London</p><p>典型的雅游路线是从英国多弗尔渡海至法国加莱，从那里换乘驿马车前往巴黎，向南经瑞士、萨伏伊一带翻越阿尔卑斯山来到波河平原，随后前往威尼斯游历一段时间，再取道佛罗伦萨抵达旅行的目的地罗马。回程不走原路的，或经德国、荷兰再返回英国。通常完成一次这样的雅游要一年半左右时间，长的可达三年。早在17世纪，英国早期收藏艺术的一位重要人物，阿伦德尔勋爵（Earl of Arundel）就曾命建筑师伊尼戈·琼斯（Inigo Jones）陪同他前往意大利考察艺术和建筑。至雅游大盛的18世纪，英国文艺名流普遍成行，其中不乏以伴游导师的身份，趁便旅行的。雅游经历成了谈论艺术的敲门砖，伦敦著名的古典艺术家和鉴赏家团体爱好者协会（Society of Dilettanti），其入会条件就是完成一次雅游。</p><p>雅游给艺术家带来了机会，本次参展的好几位艺术家都仰仗旅行者的订件为生。意大利画家卡纳莱托笔下的威尼斯运河风光令人赏心悦目，大受英国客户的欢迎，他后来索性移居伦敦，在那里画了十年风景；</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_12.jpg" alt="Alt text"></p><p>《威尼斯：城堡区圣伯多禄圣殿》 卡纳莱托</p><p>18世纪30年代，布面油画</p><p>© The National Gallery, London</p><p>法国人韦尔内长年旅居罗马，向旅行者销售带有古典题材的海景画；</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_13.jpg" alt="Alt text"></p><p>《有渔民的河流》</p><p>克劳德-约瑟夫·韦尔内</p><p>1751年，布面油画</p><p>© The National Gallery, London</p><p>威尼斯人巴托尼则是雅游时代最著名肖像画家之一。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_14.jpg" alt="Alt text"></p><p>《班克斯费的约翰·斯科特（？）肖像》</p><p>庞贝奥·吉罗拉莫·巴托尼</p><p>1774年，布面油画</p><p>© The National Gallery, London</p><h1 id="英国画派的崛起"><a href="#英国画派的崛起" class="headerlink" title="英国画派的崛起"></a>英国画派的崛起</h1><p>18世纪也是英国画派蓬勃兴起的时期。自文艺复兴以来，英国惯于招引欧洲大陆的杰出艺术家前来服务，17世纪前期在位的英王查理一世热爱艺术，是当时欧洲最重要的收藏家之一。查理一世身边围绕着一个鉴赏团体，研究者称之为“白厅圈子”（Whitehall Groupe），前文提到的阿伦德尔勋爵就是这个团体中颇具眼力的一位，这批鉴赏家手下还掌控着一群像伊尼戈·琼斯这样的行家里手，并经常把他们派往欧洲各地发掘艺术品。</p><p>在与欧洲大陆艺术的长期交往中，英国本土艺术家成长起来，他们效仿巴黎美术学院，于18世纪中期创立了英国皇家美术学院（Royal Academy of Arts），其创院会员囊括了英国本土的优秀艺术家，本次参展的庚斯博罗就赫然在列。<strong>庚斯博罗</strong>是极富个性的肖像画大师，在温泉疗养胜地巴斯为人画了不少肖像，他的手法非常巧妙，不做过多的细节刻画，却让人感到很“像”，英国皇家美术学院的首任院长约书亚·雷诺兹曾评价庚斯博罗的高超手法，认为他深谙“传神”的要诀，省略了不必要画出的地方，任凭观众的想象力去补充。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_15.jpg" alt="Alt text"><br>《拉尔夫·朔姆贝格医生》</p><p>托马斯·庚斯博罗</p><p>约1770年，布面油画</p><p>© The National Gallery, London</p><p>18世纪的英国艺术圈子颇有几分像中国明清的文人圈子，画家与学者之间过从甚密，一位名流时常有数位画家朋友为之画像，这让英国画家经常讨论谁画得更像以及什么是“像”。<strong>他们普遍意识到传神的秘诀不在于造型准确，而在于捕捉最能反映性格的瞬间，以及留有想象余地的表现手法。</strong>这类讨论提醒我们，再现从来就不是模仿现实，<strong>再现的本质其实就是表现</strong>。因为有这样的见识，英国肖像画达到了很高成就，这在两位苏格兰画家<strong>亨利·雷班</strong>爵士和<strong>大卫·威尔基</strong>的作品中也能感受到。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_16.jpg" alt="Alt text"><br>《弓箭手》</p><p>亨利·雷班爵士</p><p>约1789-1790年，布面油画</p><p>© The National Gallery, London</p><p><strong>康斯特布尔</strong>的《干草车》曾让法国浪漫主义大师德拉克洛瓦深受启发，并为之改了自己的画。本次参展的《史特拉福磨坊》与《干草车》属于同期作品，天空高远清澈，充满光和大气的感觉。康斯特布尔笔下的风雨晴霁不是拼凑而成，而是完整的观察记录。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_17.jpg" alt="Alt text"><br>《史特拉福磨坊》</p><p>约翰·康斯特布尔</p><p>1820年，布面油画</p><p>© The National Gallery, London</p><p>晚些时候另一位英国画家<strong>约翰·拉斯金</strong>也用同样的精神观察风景，他首次记录了因工业污染而产生的一种暴雨云，还曾深入阿尔卑斯山长期考察，写下厚厚一卷书，那是画家论山的最佳著作之一。拉斯金对<strong>透纳</strong>推崇备至，赞扬后者的风景画不盲从自然却更加真实地体现了自然的精神。与这时期英国风景画的细致观察不同，法国画家<strong>柯罗</strong>追求的是风景的诗意。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_18.jpg" alt="Alt text"></p><p>《倾斜的树干》</p><p>让-巴蒂斯塔-卡米耶·柯罗</p><p>约1860-1865年，布面油画</p><p>© The National Gallery, London</p><h1 id="印象派与后印象派"><a href="#印象派与后印象派" class="headerlink" title="印象派与后印象派"></a>印象派与后印象派</h1><p>19世纪艺术家热衷于思考的一个问题是怎样画出户外的真实光效。因为户外光线非常明亮，传统绘画遇到外光一般都采用降调处理，把户外的色彩关系转换成室内的灰调子。<strong>德拉克洛瓦</strong>不满足于这种处理方式，想要发展出一套适于描绘户外光线的新的色彩体系。因为传统绘画一直把暗部处理为黑色，所以他从研究暗部的色彩开始找突破口。德拉克洛瓦的探索方向感召了一代青年画家，他们画了一幅《向德拉克洛瓦致敬》的群像表达敬意，马奈正是群像中的一员。</p><p><strong>马奈</strong>的《咖啡厅演奏会的一角》是一幅色彩斑斓、阳光明媚的快乐的画，画中的主角是位特别能干的女招待，但整幅画的气氛才是真正的主题。马奈也有改革绘画的雄心，他借鉴17世纪荷兰大师<strong>哈尔斯</strong>的活泼笔触，放弃了结实的素描——那种效果只出现在室内侧光下，而处于户外强光照射下的形体，都会失去立体感，显得扁平。一边是得自知识和理解的素描造型，一边是得自观察和感受的形体表象，马奈抛弃了所知而选择了所见，这使他成为印象派的先驱。马奈沿着德拉克洛瓦的方向更进一步，他加强了对补色的研究，画中男子的蓝色衣服与啤酒杯及背景中的黄色相互强化，拉宽了画面的色域。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_19.jpg" alt="Alt text"></p><p>《咖啡厅演奏会的一角》</p><p>爱德华·马奈</p><p>约1878-1880年，布面油画</p><p>© The National Gallery, London</p><p>19世纪，现代工业颜料丰富了画家的调色板，取代了一些原先十分昂贵的矿物颜料，例如拉斐尔画中圣母衣服所用的群青，当时价比黄金，常常在合同中单独规定成色和用量，现在则被廉价的工业群青所替代。数百年来，由于制成的颜料不能长时间保存，只能在作画前准备，19世纪中期，管装颜料的发明结束了这一局面，颜料随用随取，画家现在可以背着轻便的画箱走出户外，随地作画，这有力推动了印象派画家的探索。</p><p><strong>莫奈、雷诺阿、塞尚、高更</strong>和<strong>梵高</strong>等人先后都参加过青年画家联合展览会，展览会举办过八届，“<strong>印象派</strong>”这个名字即得自莫奈于首届展览会上展出的作品，因此上述几位画家都曾被认为是印象派画家。印象派并无自己的宣言，画风也很不一致，只是早期多作风景写生，强调在户外完成画作，<strong>抛开所知，仅画所见</strong>，在画面上捕捉到所谓“视网膜印象”。为此，他们作画时严守光照条件，当光照条件变化时，他们就停笔，等光照条件恢复了再继续画。虽然组织上非常松散，但印象派画家怀抱理想、贫贱不移的早期经历，给后世留下了一幅感人的画面。</p><p>莫奈和雷诺阿晚年见到了自己的成功，塞尚、高更和梵高则一早离开了印象派——他们都不甘于仅描绘所见。塞尚继承家产后，退隐家乡埃克斯独自作画，他在世纪末被人重新发现，其雄伟坚实的风格迷住了他过去的同道们，本次展出的是他早期一张作品。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_20.jpg" alt="Alt text"><br>《画室中的火炉》</p><p>保罗·塞尚</p><p>约1865年，布面油画</p><p>© The National Gallery, London</p><p>梵高在巴黎经历了乌托邦的破灭，只身前往法国南部小镇阿尔，燃烧生命的最后十年，成为我们时代的大师。《长草地与蝴蝶》是他罹患精神疾病，在圣雷米医院即将结束疗养时所作，画的正是医院的花园，梵高没有画出地平线，完全凭他标志性的笔触和漂亮的色彩支撑起画面，他的色彩极富表现力，热烈率直但并不简单，其复杂的黄-蓝、红-绿补色系统可以看作自马奈以来艺术家努力的成果。梵高像拉斐尔一样卒于37岁，他传奇的一生定义了现代艺术家的形象，其影响远远超乎艺术界。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_21.jpg" alt="Alt text"></p><p>《长草地与蝴蝶》</p><p>文森特·梵高</p><p>1890年，布面油画</p><p>© The National Gallery, London</p><p>高更受到原始主义和自然主义的影响，对人在现代社会中的异化深恶痛绝，他曾尝试与梵高结伴作画，又前往荒凉的布列塔尼寻求世外桃源，末了他来到南太平洋的法属殖民地塔西提岛，最后死在岛上。</p><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_22.jpg" alt="Alt text"><br>《窗前果盆和啤酒杯》</p><p>保罗·高更</p><p>可能作于1890年，布面油画</p><p>© The National Gallery, London</p><p>1910年，罗杰·弗莱在英国举办“马奈与后印象主义画家”展览，从那时起，人们开始把塞尚、高更和梵高归为一派，称他们是后印象主义画家。这三位艺术家站在传统艺术与现代艺术的转折点，其中塞尚对后世的影响尤其巨大，被尊为“现代主义之父”。</p><p><hr><br>绘画是人类普遍具有的冲动，但在大多数文明中，绘画一直停留在实用的层面上，只有屈指可数的几个文明超越了实用性，视绘画为值得宝藏的精神价值，中国和欧洲恰都属于这样的文明。中国与欧洲对待绘画的态度具有惊人的相似性——我们都认为艺术性不在“画什么”而在“怎么画”；都不惜千金收藏画作，为之著录，并发展起颇为相近的鉴定传统；我们都崇敬画家，就连津津乐道的画家故事也如出一辙——天才的无师自通、惊人表演和自由不羁；我们也都通过绘画来窥探人性，陶冶情操，并留下连篇累牍的著作。每当想起中国和欧洲文明不约而同竟有如此相似的艺术传统，心中都不禁涌起一股惊奇感！欧洲画史群星闪耀，岂能遍数？观其大略，本次展览的52幅杰作已经足够。</p><blockquote><p>*本文选编自《欧洲油画五百年：英国国家美术馆珍藏展简介》，有删节。作者：万木春（中国美术学院教授）<br>原文刊于上海博物馆编，《从波提切利到梵高：英国国家美术馆珍藏集》，上海书画出版社，2023年。</p></blockquote><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><blockquote><p><a href="https://mp.weixin.qq.com/s/7yzyQHTyMYCatfPISzj5Fg">https://mp.weixin.qq.com/s/7yzyQHTyMYCatfPISzj5Fg</a></p></blockquote><!-- <div style="line-height:0"><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list1.jpg" alt=""><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list2.jpg" alt=""><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list3.jpg" alt=""><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list4.jpg" alt=""><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list5.jpg" alt=""><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list6.jpg" alt=""><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list7.jpg" alt=""><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list8.jpg" alt=""><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list9.jpg" alt=""></div> --><p><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list1.jpg" alt="Alt text"><br><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list2.jpg" alt="Alt text"><br><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list3.jpg" alt="Alt text"><br><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list4.jpg" alt="Alt text"><br><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list5.jpg" alt="Alt text"><br><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list6.jpg" alt="Alt text"><br><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list7.jpg" alt="Alt text"><br><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list8.jpg" alt="Alt text"><br><img src="static/museums/museum_exhibition_bottlicelli_to_van_gogh_list9.jpg" alt="Alt text"></p><h1 id="再现·大师——沉浸式光影体验"><a href="#再现·大师——沉浸式光影体验" class="headerlink" title="再现·大师——沉浸式光影体验"></a>再现·大师——沉浸式光影体验</h1><p>NG TREASURES: Masters-Reborn </p><p>An Immersive Digital Experience</p><p><a href="https://mp.weixin.qq.com/s/c88ZeJXEgbDzjW7xu1c4xg">https://mp.weixin.qq.com/s/c88ZeJXEgbDzjW7xu1c4xg</a></p><blockquote><p>上海博物馆将与品源文化共同打造珍藏展的展外特展——“ NG200 再现•大师｜沉浸式光影特展”，展览将在上海博物馆4楼第三展厅同期举行，所有购买“从波提切利到梵高——英国国家美术馆珍藏展”门票（含购买数字藏品获得门票）的观众，预约参观当日皆可享受一票两展的权益，一次畅游珍藏展与光影特展，敬请期待！</p></blockquote><p>包括这次未能参展的英国国家美术馆馆藏珍品的梵高的《向日葵》、莫奈的《睡莲》、达芬奇的《岩间圣母》等，</p><p>本次光影体验分两大展区，经过打卡墙和序曲，进入第一展区，观众将欣赏到一场6分钟左右的沉浸光影体验，打通视觉与听觉，随着光影叙事，进入西方美术史的不同阶段与大师创作心路。</p><p>第一展区观影结束后，观众将穿过梵高向日葵万花筒打卡区，进入“对话大师”二创区，在这里可通过数字展示屏、打卡和互动的方式，来欣赏中国年轻设计力量向大师致敬的无限创意。</p><!-- 预测函数与函数之间的调用关系是否存在。训练一个 linkbert 。在代码上训练LinkBERT: Pretraining Language Models with Document Links数据集？AutoPruner: transformer-based call graph pruning --><blockquote><p>创建于 2023-02-15</p><p>更新于 2023-02-15</p></blockquote>]]></content>
    
    
    <summary type="html">2023年1月17日至5月7日，上海博物馆首度联手英国国家美术馆，推出“对话世界”文物艺术大展系列的第二个展览——“从波提切利到梵高：英国国家美术馆珍藏展”。展览通过 52 件大师杰作，为观众奉上一场视觉盛宴，讲述欧洲绘画的故事。</summary>
    
    
    
    <category term="艺术" scheme="https://luorongluorong.github.io/categories/%E8%89%BA%E6%9C%AF/"/>
    
    
    <category term="油画" scheme="https://luorongluorong.github.io/tags/%E6%B2%B9%E7%94%BB/"/>
    
    <category term="博物馆" scheme="https://luorongluorong.github.io/tags/%E5%8D%9A%E7%89%A9%E9%A6%86/"/>
    
  </entry>
  
  <entry>
    <title>动态规划总结及练习巩固</title>
    <link href="https://luorongluorong.github.io/2023/02/11/algorithms/dp_short/"/>
    <id>https://luorongluorong.github.io/2023/02/11/algorithms/dp_short/</id>
    <published>2023-02-11T11:39:15.000Z</published>
    <updated>2023-02-16T16:46:07.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dp-精要"><a href="#dp-精要" class="headerlink" title="dp 精要"></a>dp 精要</h1><p>在前两期中，我们介绍了动态规划的基本概念，线性动态规划，前缀和，区间动态规划，背包动态规划，状态压缩动态规划，计数动态规划，矩阵快速幂，数位动态规划。</p><p>本章我们简要回顾一下前两期的内容，首先总结一下基本概念，然后把各个题型下的题目列表整理成了思维导图方便大家回忆。如果要看详细内容或者刷题，可以翻阅动态规划精讲前两期的内容。</p><p>本期我们主要回顾线性动态规划，前缀和，区间动态规划，背包动态规划并给大家聚合题目列表。</p><p>状态压缩动态规划，计数动态规划，矩阵快速幂，数位动态规划的题目聚合列表在动态规划精讲第四期给到大家。</p><h1 id="dp-基本概念"><a href="#dp-基本概念" class="headerlink" title="dp 基本概念"></a>dp 基本概念</h1><p>在动态规划精讲第一期中，我们有介绍一些基本概念，但是欠缺一点系统性。这里我们参考《算法竞赛进阶指南》中关于动态规划的讲解，把动态规划的几个核心概念梳理一下，并做一个总结。</p><p>首先我们给出思维导图<br><img src="static/algorithms/dp_s1.jpeg" alt="Alt text"></p><p>动态规划用一句话概括就是对各个状态维度进行分阶段、有顺序、无重复、决策性的遍历求解。</p><p>阶段(子问题)<br>动态规划把原问题视为若干个重叠子问题的逐层递进，每个子问题的求解过程都构成一个阶段。在完成前一个阶段的计算后，才会执行下一阶段的计算。</p><p>无后效性<br>【在完成前一个阶段的计算后，才会执行下一阶段的计算】</p><p>无后效性: 为了保证这些计算能够按顺序，不重复地进行，DP 要求已经求解的子问题不受后续阶段的影响。(后面的阶段对前面的阶段没有影响)</p><p>状态,转移,决策<br>由无后效性。DP 对状态空间的遍历构成 DAG，遍历顺序就是该 DAG 的一个拓扑序。DAG 中的节点对应问题的状态，边对应状态之间的转移，转移的选取是 DP 中的决策。</p><p>最优子结构<br>当动态规划用于求解最优化的问题时，下一阶段的最优解应该能由前面各阶段子问题的最优解导出。</p><p>重复子问题<br>在阶段计算完成的时候，只会在每个状态上保留与最终解集相关的代表信息，这些信息具有可重复的求解过程，并且能够导出后续阶段的代表信息。</p><p>总结<br>状态，阶段，决策是动态规划算法的三要素。</p><p>无后效性，最优子结构，重复子问题是问题能用 DP 求解的三个基本条件。</p><h1 id="分阶段"><a href="#分阶段" class="headerlink" title="分阶段"></a>分阶段</h1><p>动态规划是对各维状态进行分阶段，有顺序，无重复，决策性的遍历求解，其中对阶段进行划分后，每个阶段就是一个子问题。</p><p>动态规划算法有不同的阶段划分和推导的方式，常见的阶段划分方式如下:</p><p>「线性 DP」: 具有线性阶段划分的 DP 问题<br>「树形 DP」: 以节点的深度作为阶段的 DP 问题<br>「图上 DP」: 以节点在图上的拓扑序作为阶段的 DP 问题<br>这是一个广义的概念，与线性空间类似，如果一个 DP 算法的状态包含多个维度，但是各个维度上具有线性变化的阶段，也是「线性 DP」，例如背包问题，「区间 DP」均属于这种情况。</p><p>下面我们看一下「线性 DP」中常见的阶段划分方式，以此作为对前两期内容的复习。</p><p>（1）单串阶段划分</p><p>代表问题：最长上升子序列；<br>状态表示：dp[i] := 以 s[i] 结尾的最长上升子序列长度；<br>阶段划分：子序列的结尾位置，从前到后。<br>（2）双串阶段划分</p><p>代表问题：最长公共子序列；<br>状态表示：dp[i][j] := s[0..i], t[0..j]的最长公共子序列长度；<br>阶段划分：s 和 t 分别已经处理的长度，二维。<br>（3）棋盘阶段划分</p><p>代表问题：数字三角形；<br>状态表示：dp[i][j] := 从 (0, 0) 走到 (i, j) 的最大的和；<br>阶段划分：路径的结尾位置（矩阵中的行列位置），二维。</p><h1 id="线性动态规划"><a href="#线性动态规划" class="headerlink" title="线性动态规划"></a>线性动态规划</h1><p>「单串 DP」<br>对于「单串线性 DP」问题，i 是单串 s 上的位置。作为阶段具有时间或者位置等含义。有时只有单串上的位置不足以表示状态，需要同时附加一个维度 k，一般 k 有长度、个数、次数、颜色等含义。另，所附加的维度有时候可以是多个，如 k1, k2, …</p><p>没有附加状态维度<br><img src="static/algorithms/dp_s2.png" alt="Alt text"></p><p>附加一维状态<br><img src="static/algorithms/dp_s3.jpeg" alt="Alt text"></p><p>附加多维状态<br><img src="static/algorithms/dp_s4.jpeg" alt="Alt text"></p><p>「双串 DP」<br>dp[i][j]: i, j 分别是两个串上的位置。i, j 共同作为阶段，具有位置等含义。没有附加维度。<br><img src="static/algorithms/dp_s5.jpeg" alt="Alt text"></p><p>「棋盘 DP」<br>dp[i][j]: i, j 分别是棋盘（矩阵）的横纵坐标。阶段划分常见的两种情况分别为：</p><p>（1）i 作为阶段，具有位置等含义。j 是附加状态。<br>（2）i, j 共同作为阶段，具有位置等含义。没有附加维度。</p><p><img src="static/algorithms/dp_s6.jpeg" alt="Alt text"></p><p>「线性 DP」总结<br>下图是 Leetcode 上「线性 DP」的题目分类汇总，方便大家从整体上把握题目。其中不含「区间 DP」，「背包 DP」和前缀和。这三块将分别有专题汇总。</p><p><img src="static/algorithms/dp_s7.png" alt="Alt text"></p><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p><img src="static/algorithms/dp_s8.png" alt="Alt text"></p><h1 id="区间动态规划"><a href="#区间动态规划" class="headerlink" title="区间动态规划"></a>区间动态规划</h1><p>对于「区间 DP」，i, j 分别是区间的左右端点，其中阶段为区间长度(j - i + 1)，另外有一个是附加状态是区间左端点 i。</p><p>有的题会同时有附加维度 k。一般 k 会有长度，个数，次数，颜色等含义。</p><p>减治型<br>dp[i][j] 仅与常数个更小规模子问题有关，不需要枚举分割点然后两边分别求解。</p><p>一般是与 dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1] 有关。</p><p>分治型<br>dp[i][j] 仅与 O(n) 个更小规模子问题有关，需要枚举分割点然后两边分别求解。</p><p>一般是枚举 [i, j] 的分割点，将区间分为 [i, k] 和 [k+1, j]， 对每个 k 分别求解（下面公式的 f），再汇总（下面公式的 g）。</p><p><img src="static/algorithms/dp_s9.png" alt="Alt text"></p><h1 id="背包动态规划"><a href="#背包动态规划" class="headerlink" title="背包动态规划"></a>背包动态规划</h1><p>对于背包问题，“已经处理的物品数”为阶段，“背包的总体积”为附加状态。</p><p>下面是 Leetcode 上与「背包 DP」相关的题目，一共十几道，分成了「01 背包」和「完全背包」、「组合问题」和「优化问题」两个维度，方便大家在刷题中感悟总结。<br><img src="static/algorithms/dp_s10.png" alt="Alt text"></p>]]></content>
    
    
    <summary type="html">总结动态规划相关的基本概念，类别划分及具体练习，帮助读者加以理解和巩固。</summary>
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://luorongluorong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="练习" scheme="https://luorongluorong.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="动态规划" scheme="https://luorongluorong.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>每周周赛复盘记录</title>
    <link href="https://luorongluorong.github.io/2023/01/15/algorithms/contest_record/"/>
    <id>https://luorongluorong.github.io/2023/01/15/algorithms/contest_record/</id>
    <published>2023-01-15T04:59:14.000Z</published>
    <updated>2023-02-16T16:47:16.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="力扣竞赛复盘记录"><a href="#力扣竞赛复盘记录" class="headerlink" title="力扣竞赛复盘记录"></a>力扣竞赛复盘记录</h1><h1 id="第-332-场力扣周赛"><a href="#第-332-场力扣周赛" class="headerlink" title="第 332 场力扣周赛"></a><a href="https://leetcode.cn/contest/weekly-contest-332/">第 332 场力扣周赛</a></h1><blockquote><p>2022 年 2 月 12 日</p></blockquote><h2 id="1-简单：数组前后相加"><a href="#1-简单：数组前后相加" class="headerlink" title="1 简单：数组前后相加"></a>1 简单：数组前后相加</h2><p>我花了 7 分钟完成这道简单题。主要是我写了一个 while 循环，设置的条件有点多。</p><p>看了别人的答案，有的人用的方法是 Integer.valueOf(“” + str1 + str2)，这样就省去了转换数位的方法，比较快速。</p><p>总结：简单题一定也不能轻视，要先把题意读懂，然后把边界条件确立清楚，每一次调试都需要至少消耗半分钟的时间。</p><h2 id="2-中等：求公平数对的数目，lower-lt-nums-i-nums-j-lt-upper"><a href="#2-中等：求公平数对的数目，lower-lt-nums-i-nums-j-lt-upper" class="headerlink" title="2 中等：求公平数对的数目，lower &lt;= nums[i] + nums[j] &lt;= upper"></a>2 中等：求公平数对的数目，lower &lt;= nums[i] + nums[j] &lt;= upper</h2><p>这题做了将近一个小时。</p><p>最近在刷动态规划专题，所以看到这种题，下意识就以为是子数组，然后想了半天的前缀和。但是不知道该怎么处理 [lower, upper] 区间</p><p>后来看到有好几百个人通过了这道题，所以我觉得应该没有那么难。在浏览器查到了类似的题，是力扣 <a href="https://leetcode.cn/problems/count-of-range-sum/">327. 区间和的个数</a>，问的是子数组的和位于 [lower, upper] 区间的个数。我就意识到，327 题是我以为的题意，今天竞赛考的题其实比较简单，是求任意两个数的和落在区间。</p><p>暴力做法的时间复杂度为 O(n^2)，提交一看，果然超时。</p><p>327 题的官方题解给了我提示，说是用双指针法。于是我在尝试了二十分钟后，终于在离竞赛结束只剩 8 秒把题解交上去了。</p><p>但我在慌乱之中，解法的时间复杂度还是挺高的。所以得再看看这道题。</p><p>总结：</p><ul><li>[ ] 补题</li><li>[ ] 327. 区间和的个数</li><li>[ ] 再做十道二分题。</li></ul><h1 id="3-中等：子字符串异或查询，第-i-个查询的答案是子字符串-lefti-righti-的两个端点（下标从-0-开始）"><a href="#3-中等：子字符串异或查询，第-i-个查询的答案是子字符串-lefti-righti-的两个端点（下标从-0-开始）" class="headerlink" title="3 中等：子字符串异或查询，第 i 个查询的答案是子字符串 [lefti, righti] 的两个端点（下标从 0 开始）"></a>3 中等：子字符串异或查询，第 i 个查询的答案是子字符串 [lefti, righti] 的两个端点（下标从 0 开始）</h1><p>我花了大约半小时做这道题。把它想成了动态规划，实际上确实也是动态规划+哈希，就是我的做法的空间复杂度比较高。</p><p>更直观的做法是遍历整个数组，然后查找以 i 开头的 32 位的字符串的值。</p><p>总结：</p><ul><li>总体来说我的表现还是可以的，希望能再快点。</li><li>难以分辨一道题是否应该使用 dp</li></ul><h1 id="4-困难："><a href="#4-困难：" class="headerlink" title="4 困难："></a>4 困难：</h1><p>前面三道题花了一个半小时，后面就没时间做这道题了。</p><p>看题解说要用前后缀分解。大概理解了该怎么做了。</p><p>总结：</p><ul><li>[ ] 补题</li><li>[ ] 前后缀分解<ul><li>[ ] Q3 <a href="https://leetcode.cn/problems/minimum-penalty-for-a-shop/solutions/1993077/qian-hou-zhui-fen-jie-o1-kong-jian-by-en-c2m5/">https://leetcode.cn/problems/minimum-penalty-for-a-shop/solutions/1993077/qian-hou-zhui-fen-jie-o1-kong-jian-by-en-c2m5/</a></li><li>[ ] Q4 <a href="https://leetcode.cn/problems/count-palindromic-subsequences/solutions/1993115/qian-hou-zhui-fen-jie-o100-chang-shu-kon-51cv/">https://leetcode.cn/problems/count-palindromic-subsequences/solutions/1993115/qian-hou-zhui-fen-jie-o100-chang-shu-kon-51cv/</a></li></ul></li></ul><h1 id="第-329-场力扣周赛"><a href="#第-329-场力扣周赛" class="headerlink" title="第 329 场力扣周赛"></a><a href="https://leetcode.cn/contest/weekly-contest-329/">第 329 场力扣周赛</a></h1><blockquote><p>2023 年 1 月 22 日</p></blockquote><h2 id="2-中等：Java-二维数组排序不会写"><a href="#2-中等：Java-二维数组排序不会写" class="headerlink" title="2 中等：Java 二维数组排序不会写"></a>2 中等：Java 二维数组排序不会写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] sortTheStudents(<span class="type">int</span>[][] score, <span class="type">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(score, (a, b) -&gt; b[k] - a[k]);</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：XingHe</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode.cn/problems/sort-the-students-by-their-kth-score/solutions/2072924/cpython3java-1-by-xinghe_xinghe-2mqj/</span></span><br><span class="line"><span class="comment">// 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><h2 id="3-中等：执行逐位运算使字符串相等"><a href="#3-中等：执行逐位运算使字符串相等" class="headerlink" title="3 中等：执行逐位运算使字符串相等"></a>3 中等：执行逐位运算使字符串相等</h2><p>前两题用 8 分钟写完，这一题花了50 分钟，并且 WA 了 4 发。大无语了。</p><ul><li>首先是看到题目没思路。</li><li>然后把 0 和 0 异或的结果想成了 1。</li><li>最后想换个思路写，终于发现了自己的眼瞎。</li></ul><h2 id="4-困难：2547-拆分数组的最小代价"><a href="#4-困难：2547-拆分数组的最小代价" class="headerlink" title="4 困难：2547. 拆分数组的最小代价"></a>4 困难：<a href="https://leetcode.cn/problems/minimum-cost-to-split-an-array/">2547. 拆分数组的最小代价</a></h2><p>是个动态规划题</p><p>结论：</p><ul><li>[ ] 补题。</li><li>[ ] 《剑指 offer》第 13 章和 14 章。</li></ul><h1 id="第-96-场力扣双周赛"><a href="#第-96-场力扣双周赛" class="headerlink" title="第 96 场力扣双周赛"></a><a href="https://leetcode.cn/contest/biweekly-contest-96/">第 96 场力扣双周赛</a></h1><blockquote><p>2023 年 1 月 21 日</p></blockquote><h2 id="2-中等"><a href="#2-中等" class="headerlink" title="2 中等"></a>2 中等</h2><p>看上去感觉很简单，但是一直没有调整好写题状态。</p><ul><li>一开始是把题目中要修改的数组看错了。</li><li>然后就是要加减的变量一直没搞清楚。</li></ul><p>最后导致，这个非常简单的题目，居然写了 18 分钟！不可原谅！</p><p>下次写题目的时候，一定要先想清楚，再下笔！</p><h2 id="3-中等：最大子序列的分数，第一个数组是加法，第二数组是最小值，二者相乘。"><a href="#3-中等：最大子序列的分数，第一个数组是加法，第二数组是最小值，二者相乘。" class="headerlink" title="3 中等：最大子序列的分数，第一个数组是加法，第二数组是最小值，二者相乘。"></a>3 中等：最大子序列的分数，第一个数组是加法，第二数组是最小值，二者相乘。</h2><p>这道题想了好几分钟，最终决定用最小堆 + 滑动窗口。</p><p>写题的过程中，因为思路一直在跳来跳去，所以有些语句的顺序忘记修改了，WA 了两发。</p><p>由于对使用的数据结构也不怎么熟悉，这题写了 43 分钟。</p><p>一开始选择用 Java 写题解，但是发现我不会写 Java 的排序 QAQ，于是马上换成 CPP。</p><p>结论：</p><ul><li>[ ] 总结 Java 的各大排序规则！排序只认<strong>对象</strong>。</li></ul><ol><li><p>对象数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，ids 必须是 Integer</span></span><br><span class="line">Integer[] ids = <span class="keyword">new</span> <span class="title class_">Integer</span>[n]; </span><br><span class="line">Arrays.sort(ids, (i, j) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] - nums[j];  <span class="comment">// 升序排列</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>基本数据类型——一维数组</p></li></ol><p>对于基本类型的数组如int[], double[], char[], Arrays类只提供了默认的升序排列，没有降序，需要传入自定义比较器，使用Arrays.sort(num,c)，传入一个实现了Comparator接口的类的对象c。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> b - a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>基本数据类型——二维数组</li></ol><p>二维数组，传进去的是 int[]，算是对象了。</p><ul><li>[x] 总结 Java 中 id 数组的排序。排序只认<strong>对象</strong>数组。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] ids = <span class="keyword">new</span> <span class="title class_">Integer</span>[n];  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) ids[i] = i;</span><br><span class="line">Arrays.sort(ids, (i, j) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[j] - nums[i];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-困难：从-1-1-出发，返回是否能到达-x-y-点。"><a href="#4-困难：从-1-1-出发，返回是否能到达-x-y-点。" class="headerlink" title="4 困难：从 (1, 1) 出发，返回是否能到达 (x, y) 点。"></a>4 困难：从 (1, 1) 出发，返回是否能到达 (x, y) 点。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">每一步 ，你可以从点 (x, y) 移动到以下点之一：</span><br><span class="line"></span><br><span class="line">(x, y - x)</span><br><span class="line">(x - y, y)</span><br><span class="line">(2 * x, y)</span><br><span class="line">(x, 2 * y)</span><br><span class="line"></span><br><span class="line">数据范围是从 1 到 1e9。</span><br></pre></td></tr></table></figure><p>首先，很明显可以看出来，这道题能移动的方向是 (0, -x), (-y, 0), (x, 0), (0, y)。</p><p>这道题，对我最大的困扰在于，y 改变后会影响接下来 x 改变的量。我想不明白，到底会有什么规律。</p><p>大佬的结论：<code>(1,1)(1, 1)(1,1) 能走到 (x,y)(x, y)(x,y)，当且仅当 xxx 和 yyy 的最大公因数是 222 的若干次方。</code></p><p>根据：Binary GCD algorithm。</p><p>前两个移动很像辗转相除法，最大公因数不变；后两个移动可以让 最大公因数 乘上 2。</p><p>判断一个数是不是 2 的幂次：<code>g&amp;(g−1) 是否为 0</code></p><p>结论：多看看构造题吧（在必应上搜 <code>构造题</code> 可以得出很多结论）</p><ul><li>[ ] <a href="https://oi-wiki.org/basic/construction/">https://oi-wiki.org/basic/construction/</a></li></ul><h1 id="第-328-场力扣周赛"><a href="#第-328-场力扣周赛" class="headerlink" title="第 328 场力扣周赛"></a><a href="https://leetcode.cn/contest/weekly-contest-328/">第 328 场力扣周赛</a></h1><blockquote><p>2023 年 1 月 15 日</p></blockquote><h2 id="1-简单：返回-元素和-与-数字和-的绝对差。"><a href="#1-简单：返回-元素和-与-数字和-的绝对差。" class="headerlink" title="1 简单：返回 元素和 与 数字和 的绝对差。"></a>1 简单：返回 元素和 与 数字和 的绝对差。</h2><ul><li>原以为一分钟能写完，结果因为手抖导致括号、标点符号什么的，还有 C++ 的绝对值函数，一直没写好。</li><li>元素和一定 &gt;= 数字和。</li></ul><h2 id="2-中等：子矩阵元素加-1"><a href="#2-中等：子矩阵元素加-1" class="headerlink" title="2 中等：子矩阵元素加 1"></a>2 中等：子矩阵元素加 1</h2><ul><li>一开始用了 row 和 col 两个数组存储差分数组，但结果总是比预想的多。</li><li>然后用二维数组存储差分数组，和上面的结果一样。</li><li>发现还是过不了，于是用暴力。果然超时了。</li><li>在纸上画了一下，发现可以把二维矩阵当成多个垒起来的差分数组。</li></ul><p>复盘：这道题其实我一眼看出来要用差分数组，但是对<code>二维差分数组</code>不太熟悉，所以手忙脚乱，导致最后花了 30 分钟才写完。</p><p>结论：</p><ul><li>[ ] 再刷两道二维差分的题目。<ul><li>[x] 304. 二维区域和检索 - 矩阵不可变</li><li>[ ] <a href="https://leetcode.cn/problems/stamping-the-grid/description/">2132. 用邮票贴满网格图</a></li></ul></li></ul><h1 id="3-中等"><a href="#3-中等" class="headerlink" title="3 中等"></a>3 中等</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中 好 子数组的数目。</span><br><span class="line"></span><br><span class="line">一个子数组 arr 如果有 至少 k 对下标 (i, j) 满足 i &lt; j 且 arr[i] == arr[j] ，那么称它是一个 好 子数组。</span><br></pre></td></tr></table></figure><ul><li>这题第一眼看过去，毫无思路。</li><li>想想是不是可以逆序，求出数组中 k-1, k-2, …, 1 对的下标，然后再用总数减去。看了一眼数据范围，觉得特别不可行。</li><li>数据范围是 1e9，是不是要用二分？想了想，还是不对。</li><li>墨迹了十来分钟，感觉可以用滑动窗口。</li><li>debug de 了十来分钟，总耗时 30 分钟。</li></ul><p>复盘：首先想思路想了很久，其次写代码写了很久。</p><p>结论：</p><ol><li>思路：这个没办法，只能靠经验积累。</li><li>代码：滑动窗口再做十道题。</li></ol><h1 id="4-困难：无向无环图找价值最大的路径，但是要删去一个节点"><a href="#4-困难：无向无环图找价值最大的路径，但是要删去一个节点" class="headerlink" title="4 困难：无向无环图找价值最大的路径，但是要删去一个节点"></a>4 困难：无向无环图找价值最大的路径，但是要删去一个节点</h1><ul><li>首先自然是对图论来自内心深处的恐惧。</li><li>其次想到了一个暴力法，从每个叶子节点出发，找到答案想要的路径。</li><li>时间不够，答案还错了。</li></ul><p>复盘：过于害怕是因为自己确实对图论没有总结。实际上，这道题的本质是 dp！</p><p>结论：</p><ul><li>[x] 先补题</li><li>[ ] 做完<a href="https://leetcode.cn/circle/discuss/WR1MJP/">灵神总结的图论题</a><ul><li>[x] 2308. 受限条件下可到达节点的数目</li><li>[x] 2385. 感染二叉树需要的总时间</li><li>[ ] 2370. 找到离给定两个节点最近的节点    </li><li>[ ] 2371. 图中的最长环    </li><li>[x] 2509. 查询树中环的长度</li><li>[ ] 2373. 给定条件下构造矩阵</li><li>[ ] 2374. 树上最大得分和路径 </li><li>[ ] 2375. 将节点分成尽可能多的组</li></ul></li></ul>]]></content>
    
    
    <summary type="html">复盘周赛的考试状态，为下一次比赛总结经验，争取再接再厉。</summary>
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://luorongluorong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="练习" scheme="https://luorongluorong.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="周赛" scheme="https://luorongluorong.github.io/tags/%E5%91%A8%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>TODO_使用图可达抽象程序分析问题</title>
    <link href="https://luorongluorong.github.io/2022/11/06/papers/program_analysis_via_graph_reachability/"/>
    <id>https://luorongluorong.github.io/2022/11/06/papers/program_analysis_via_graph_reachability/</id>
    <published>2022-11-06T05:59:24.000Z</published>
    <updated>2023-02-17T02:29:41.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Program-Analysis-via-Graph-Reachability"><a href="#Program-Analysis-via-Graph-Reachability" class="headerlink" title="Program Analysis via Graph Reachability"></a>Program Analysis via Graph Reachability</h1><blockquote><p>2022-11-16</p></blockquote><p>Thomas Reps</p><p>University of Wisconsin</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ul><li>本文描述了程序分析问题（program-analysis problems）是如何转换为图可达问题（graph-reachability problems）。</li><li>这样的程序分析问题包括：<ul><li>程序切片（program slicing）。</li><li>某些数据流分析问题（certain dataflow-analysis problems）。</li><li>one version of the problem of approximating the possible “shapes” that heap-allocated structures in a program can take on<blockquote><p>这句话是真没看懂。</p></blockquote></li><li>流不敏感的指针分析（flow-insensitive points-to analysis）。</li></ul></li><li>本文描述了图可达和其它解决程序分析问题的方法。</li><li>本文还讨论了除了纯粹图可达问题之外的技巧（techniques）。</li></ul><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>程序分析（program analysis）的目的是在不运行程序的前提下获取程序的相关信息。举例如，imperative programs 的经典的数据流分析的目的是为每个程序点（program point）找出一个合适的“数据流事实（dataflow facts）”的集合。程序点包括赋值语句、调用语句、I/O 语句、循环的谓词（predicate）、条件语句等等。数据流事实表示在执行程序时，当程序到达 <em>p</em> 点时，程序的状态（execution state）保持不变。</p><p>程序分析框架对程序问题的类的公共特征进行了抽象。存在一个“分析引擎（analysis engine）”，在该框架里面，所有的程序分析问题都被建模。只需在其上加一些插件就可以分析具体的问题。</p><p>程序分析框架针对某一特定程序分析问题的初始化会产生等式（equation）的集合。分析引擎的目的就是解决一组等式的集合。比如，每个前向的 gen/kill 数据流问题示例都会生成一个等式集合，等式的形式如下所示：</p><script type="math/tex; mode=display">val_p=(( \bigcup\limits_{q\in pred(p)} val_q) - kill_p)\cup gen_p</script><p>$kill_p$ 和 $gen_p$ 是和程序点 <em>p</em> 相关的常量：$kill_p$ 表示在 <em>p</em> 点删掉数据流事实，$gen_p$ 表示在 <em>p</em> 点生成数据流事实。</p><p>本文中，程序分析问题被认为是图可达问题：上下文无关语言可达性问题（context-free-language reachability problems, CFL-reachability problems）。</p><blockquote><p>我没看出来和之前的有什么不一样555。</p></blockquote><p>CFL-reachability 可以解决的程序分析问题有：</p><ul><li>过程间程序切片</li><li>过程间数据流问题</li><li>A method for approximating the possible “shapes” that heap-allocated structures can take on</li><li>流不敏感的指针分析</li></ul><p>There are a number of <strong>benefits</strong> to be gained from using graph reachability as a vantage point for studying<br>program-analysis problems.</p><h1 id="2-Context-Free-Language-Reachability-Problems"><a href="#2-Context-Free-Language-Reachability-Problems" class="headerlink" title="2. Context-Free-Language Reachability Problems"></a>2. Context-Free-Language Reachability Problems</h1><p>定义 CFL-reachability problem。</p><p><em>CFL-reachability</em>: A path is considered to connect two nodes A and B, or <strong>B is reachable from A</strong>, only if the concatenation of the labels on the edges of the path is a word in a specified context-free language.</p><p>A context-free language is a language generate by a context-free grammar(CFG).</p><h1 id="3-Algorithms-for-Solving-CFL-Reachability-Problems"><a href="#3-Algorithms-for-Solving-CFL-Reachability-Problems" class="headerlink" title="3. Algorithms for Solving CFL-Reachability Problems"></a>3. Algorithms for Solving CFL-Reachability Problems</h1><h1 id="4-Four-Examples"><a href="#4-Four-Examples" class="headerlink" title="4. Four Examples"></a>4. Four Examples</h1><p>本文展示了 4 个程序分析问题是如何转换成 CFL-reachability 问题的。</p><h2 id="4-1-Interprocedural-Dataflow-Analysis"><a href="#4-1-Interprocedural-Dataflow-Analysis" class="headerlink" title="4.1. Interprocedural Dataflow Analysis"></a>4.1. Interprocedural Dataflow Analysis</h2><h1 id="5-Solving-Demand-Versions-of-Program-Analysis-Problems"><a href="#5-Solving-Demand-Versions-of-Program-Analysis-Problems" class="headerlink" title="5. Solving Demand Versions of Program-Analysis Problems"></a>5. Solving Demand Versions of Program-Analysis Problems</h1><h1 id="6-Program-Analysis-Using-More-Than-Graph-Reachability"><a href="#6-Program-Analysis-Using-More-Than-Graph-Reachability" class="headerlink" title="6. Program Analysis Using More Than Graph Reachability"></a>6. Program Analysis Using More Than Graph Reachability</h1><h1 id="7-Related-Work"><a href="#7-Related-Work" class="headerlink" title="7. Related Work"></a>7. Related Work</h1><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><p>Programming paradigms are a way to classify programming languages based on their features. Languages can be classified into multiple paradigms. Common programming paradigms include:</p><ul><li>imperative in which the programmer instructs the machine how to change its state,<ul><li><strong>procedural</strong> which groups instructions into procedures,</li><li><strong>object-oriented</strong> which groups instructions with the part of the state they operate on,</li></ul></li><li>declarative in which the programmer merely declares properties of the desired result, but not how to compute it<ul><li><strong>functional</strong> in which the desired result is declared as the value of a series of function applications,</li><li><strong>logic</strong> in which the desired result is declared as the answer to a question about a system of facts and rules,</li><li><strong>mathematical</strong> in which the desired result is declared as the solution of an optimization problem</li><li><strong>reactive</strong> in which the desired result is declared with data streams and the propagation of change</li></ul></li></ul><p><img src="static/papers/Programming_paradigms.svg" alt="Programming_paradigms"></p><h2 id="data-flow-fact"><a href="#data-flow-fact" class="headerlink" title="data flow fact"></a>data flow fact</h2><p>What is a <strong>data flow fact</strong>? For constant propagation, an individual dataflow fact is a set of pairs of the form (var, val), so the domain of dataflow facts is the set of all such sets of pairs (the power set). For live-variable analysis, it is the power set of the set of variables in the program.</p><h2 id="敏感与不敏感"><a href="#敏感与不敏感" class="headerlink" title="敏感与不敏感"></a>敏感与不敏感</h2><blockquote><p>来自南京大学程序分析课程李樾、谭添老师的<a href="https://pascal-group.bitbucket.io/teaching.html">《软件分析》课程</a> PPT（08-PTA.pdf）第三部分。</p></blockquote><p>影响指针分析准确度（precision）和效率（efficiency）的关键因素：</p><div class="table-container"><table><thead><tr><th>因素</th><th>问题</th><th>方法</th></tr></thead><tbody><tr><td>Heap abstraction</td><td>How to model heap memory?</td><td>• <strong>Allocation-site</strong> <br>• Storeless</td></tr><tr><td>Context sensitivity</td><td>How to model calling contexts?</td><td>• Context-sensitive<br>• Context-insensitive</td></tr><tr><td>Flow sensitivity</td><td>How to model control flow?</td><td>• Flow-sensitive（遵循时间顺序） <br>• <strong>Flow-insensitive</strong>（不遵循时间顺序）</td></tr><tr><td>Analysis scope</td><td>Which parts of program should be analyzed?</td><td>• <strong>Whole-program</strong> <br>• Demand-driven</td></tr></tbody></table></div><blockquote><p>Heap abstraction </p></blockquote><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><blockquote><p>创建于 2022-11-16</p><p>更新于 2022-11-17</p></blockquote>]]></content>
    
    
    <summary type="html">本文描述了程序分析问题（program-analysis problems）是如何转换为图可达问题（graph-reachability problems），描述了图可达和其它解决程序分析问题的方法，还讨论了除了纯粹图可达问题之外的技巧（techniques）。</summary>
    
    
    
    <category term="学术" scheme="https://luorongluorong.github.io/categories/%E5%AD%A6%E6%9C%AF/"/>
    
    
    <category term="论文" scheme="https://luorongluorong.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="程序分析" scheme="https://luorongluorong.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    <category term="软件工程" scheme="https://luorongluorong.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用 LaTex 书写符号</title>
    <link href="https://luorongluorong.github.io/2022/11/05/practices/md/"/>
    <id>https://luorongluorong.github.io/2022/11/05/practices/md/</id>
    <published>2022-11-05T11:21:41.000Z</published>
    <updated>2023-02-18T11:51:26.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><blockquote><p>VSCode 的官方文档：<a href="https://code.visualstudio.com/docs/languages/markdown">https://code.visualstudio.com/docs/languages/markdown</a></p></blockquote><h2 id="Markdown-All-in-One-——-书写-Markdown-利器"><a href="#Markdown-All-in-One-——-书写-Markdown-利器" class="headerlink" title="Markdown All in One —— 书写 Markdown 利器"></a>Markdown All in One —— 书写 Markdown 利器</h2><p>特点</p><ol><li>提供了常用操作便利的快捷键</li><li>支持目录</li><li>一边书写一边预览(Ctrl + Shift + V or Ctrl + K V)</li><li>可轻松转换为HTML文件和PDF文件</li><li>优化了List editing的编辑</li><li>可格式化table (Alt + Shift + F) 以及Task list (use Alt + C to check/uncheck a list item)</li><li>支持特殊数学符号渲染</li></ol><h3 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="1. 快捷键"></a>1. 快捷键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + B    粗体</span><br><span class="line">Ctrl + I    斜体</span><br><span class="line">Alt + S    删除线</span><br><span class="line">Ctrl + Shift + ]    标题(uplevel)</span><br><span class="line">Ctrl + Shift + [    标题(downlevel)</span><br><span class="line">Ctrl + M    Toggle math environment</span><br><span class="line">Alt + C    Check/Uncheck task list item</span><br></pre></td></tr></table></figure><h3 id="2-其它"><a href="#2-其它" class="headerlink" title="2. 其它"></a>2. 其它</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Alt+↓ / ↑ \downarrow / \uparrow↓/↑：将当前行内容，下移或者上移。</span><br><span class="line">Shift+Ctrl+K:删除光标所在行。</span><br><span class="line">Ctrl+\: 横向重复打开当前编辑窗口。（目前只在mardown编辑窗口试过）</span><br><span class="line">Shift+Ctrl+Enter：在光标所在行之前，插入一个空行。</span><br><span class="line">Ctrl+]/[: 缩进/回退制表符，相当于tab键。</span><br><span class="line">Shift+Ctrl+]/[: 改变此行的目录结构。</span><br><span class="line">Ctrl+M:插入数学公式。</span><br><span class="line">Alt+Click:可以在多个地方插入光标。</span><br><span class="line">Shift+Alt+↑ o r ↓ \uparrow or \downarrow↑or↓:将当前内容向下复制。</span><br><span class="line">Ctrl+L or F2:选中光标所在行，可以进行重新编辑。</span><br><span class="line">Ctrl+w:关闭当前的编辑窗口。</span><br><span class="line">Ctrl+N:重新创建一个新的文档。</span><br><span class="line">Ctrl+Tab:选择下一个切换的窗口。（顺序从上往下）</span><br><span class="line">Ctrl+Shift+Tab:选择下一个切换的窗口。（顺序从下往上）</span><br><span class="line">文章知识点与官方知识档案匹配，可进一步学习相关知识</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「心儿痒痒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/aiboom/article/details/119852206</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">使用 LaTex 书写数学公式中的符号。</summary>
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="写作" scheme="https://luorongluorong.github.io/tags/%E5%86%99%E4%BD%9C/"/>
    
    <category term="Markdown" scheme="https://luorongluorong.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 + Element3 学习过程简单记录</title>
    <link href="https://luorongluorong.github.io/2022/03/21/practices/vue3_elementplus/"/>
    <id>https://luorongluorong.github.io/2022/03/21/practices/vue3_elementplus/</id>
    <published>2022-03-21T10:19:19.000Z</published>
    <updated>2023-02-17T05:04:19.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3-Element3-学习过程简单记录"><a href="#Vue3-Element3-学习过程简单记录" class="headerlink" title="Vue3 + Element3 学习过程简单记录"></a>Vue3 + Element3 学习过程简单记录</h1><blockquote><p>两周前，师兄要我完成一个前端的任务。因此我选择了较为熟悉的前端框架 Vue3 和配套的 UI 框架 ElementPlus，原型设计工具是 Figma。我最终实现的界面如下所示：</p></blockquote><p> <img src="static/practices/vue3_results.png" alt="front_result"></p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-框架选择原因"><a href="#1-1-框架选择原因" class="headerlink" title="1.1 框架选择原因"></a>1.1 框架选择原因</h3><h4 id="1-选择-Vue3-的原因有如下几点："><a href="#1-选择-Vue3-的原因有如下几点：" class="headerlink" title="(1) 选择 Vue3 的原因有如下几点："></a>(1) 选择 Vue3 的原因有如下几点：</h4><ul><li>方便搭建。依照官方给出的<a href="https://v3.cn.vuejs.org/guide/installation.html">安装教程</a>，</li><li>上手简单。只需要会一些 JavaScript 等前端开发的基础知识。</li><li>轻量级。越简单越好，这是我们的项目需求使然。我们的目标是创建一个简单的前端搜索和展示页面，不需要进行页面之间的跳转。虽然像 Vue 这样的框架构建的网页本质上就是单页面，但实际上对于复杂项目来说，Vue 也需要进行许多代码的编写。</li></ul><p>在可视化前端中，除了像 Vue 和 Angular 这样的前端框架之外，还有 D3 这种小巧的 js 库。由于我对 D3 不熟悉，所以我最终还是选择了 Vue。<br>由于 Vue3 相对 Vue2 来说更加新，所以 Vue3 的教程会相对来说少一些，面对一些 Error 什么的，还是不好弄。</p><h4 id="2-选择-ElementPlus-的原因有如下几点："><a href="#2-选择-ElementPlus-的原因有如下几点：" class="headerlink" title="(2) 选择 ElementPlus 的原因有如下几点："></a>(2) 选择 ElementPlus 的原因有如下几点：</h4><ul><li>和 Vue3 配套。</li><li>有许多方便使用的组件。</li><li>风格统一。</li></ul><p>当然，Element 存在许多便捷的组件，这也意味着它的灵活性大大降低。我在开发的过程中，花费了 60% 的时间调整组件带给我的不灵活之处。</p><h3 id="1-2-个人习惯"><a href="#1-2-个人习惯" class="headerlink" title="1.2 个人习惯"></a>1.2 个人习惯</h3><p>英文报错搜<strong>谷歌</strong>，谷歌搜不到就搜 ElementPlus 在 Github 的 <strong><a href="https://github.com/element-plus/element-plus/issues">issues</a></strong>。除了本次项目我尝试使用 issues 来进行调试外，在使用很多其他开源项目时，如果我们碰到 BUG 或者一些安装方面的问题，我们都可以尝试去项目的 issues 部分进行查询或者直接提问。一般而言，生命力比较旺盛的开源项目都会有工作人员进行维护。在这里就不吐槽那些为了发论文所以开放项目地址但从不回应 issues 的人。</p><p>代码的基本写法搜<strong>必应</strong>，必应搜不到就转换成英文搜<strong>谷歌</strong>。鉴于我很长时间没有使用过 JavaScript 了，很多基本的数据结构的增删改查我不会使用，连循环都不会。中文版本的<strong>菜鸟教程</strong>和 <strong>w3cschool</strong> 以及少量的 CSDN 就可以满足我的需求。虽然我一直骂 CSDN 坑人，但我目前搜中文编程的一些基础资料还是会偶尔参考一下 CSDN。</p><h3 id="1-3-前端原型"><a href="#1-3-前端原型" class="headerlink" title="1.3 前端原型"></a>1.3 前端原型</h3><p>我师兄使用 <strong><a href="https://www.figma.com/">Figma</a></strong> 画的原型。我师兄是个大佬，但是他很谦虚，认为自己是个小虾米。我根据他画的前端原型来进行前端的实现。在代码实现的过程中，如果需要修改需求，我们就会使用 Figma 对界面进行了微调，辅助我们进行需求的确认。</p><h3 id="1-4-安装"><a href="#1-4-安装" class="headerlink" title="1.4 安装"></a>1.4 安装</h3><p>虽然安装不是重点，但是我想有必要补充一下我的安装过程，以免未来遗忘。</p><h4 id="0-在不安装-Vue3-的脚手架的情况下创建-Vue-应用（Vite-安装）"><a href="#0-在不安装-Vue3-的脚手架的情况下创建-Vue-应用（Vite-安装）" class="headerlink" title="(0) 在不安装 Vue3 的脚手架的情况下创建 Vue 应用（Vite 安装）"></a>(0) 在不安装 Vue3 的脚手架的情况下创建 Vue 应用（Vite 安装）</h4><blockquote><p>2022-11-17 更新：<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application">Vue3 官网 Vite 安装方式</a>。</p></blockquote><p>在安装好 npm 后，运行 <code>npm init vue@latest</code> 命令即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm init vue@latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入项目名称 cdtfront</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... 安装过程略，没有特殊需求的话，一路按 enter 即可。</span></span><br><span class="line">cd cdtfront</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br><span class="line">npm run serve  # 运行项目</span><br><span class="line">npm run build  # 服务器部署所需</span><br></pre></td></tr></table></figure><p><img src="static/practices/vue3_create_project.png" alt="vue3_create_project"></p><h4 id="1-准备（脚手架安装）"><a href="#1-准备（脚手架安装）" class="headerlink" title="(1) 准备（脚手架安装）"></a>(1) 准备（脚手架安装）</h4><p>以 Linux 版本为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">已经有 node。没有 Node.js 则需要先装 Node.js</span></span><br><span class="line">sudo apt get npm  # 安装 npm</span><br><span class="line">sudo npm install -g @vue/cli  # 安装 Vue3 的脚手架</span><br></pre></td></tr></table></figure><p>由于原系统环境中安装了 Vue2 的脚手架，所以需要进行下述命令来重新安装 Vue3：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo npm cache clean -f</span><br><span class="line">sudo npm install -g n</span><br><span class="line">sudo n stable</span><br><span class="line">sudo npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>对于上面的命令，有必要解释部分词汇。</p><p>首先，按照 <a href="https://nodejs.org/en/">Node.js 官网</a> 的定义“Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. ” 用我师兄的话来说，Node.js 相当于为 JavaScript 提供了运行环境，类似于 Java 的 JVM。如果没有 Node.js，JavaScript 的运行必须依赖以 Chrome 内核为典型代表的浏览器引擎；有了 Node.js，开发人员不仅可以使用 JavaScript 来撰写前端，也可以使用 JavaScript 来撰写后端等，从而进行全栈开发。</p><p>其次，npm 是一个包管理工具，类似 Python 的 pip。</p><p>我的版本情况如下所示:</p><p><img src="./static/practices/vue3_version.png" alt="version"></p><h4 id="2-创建项目（脚手架安装）"><a href="#2-创建项目（脚手架安装）" class="headerlink" title="(2) 创建项目（脚手架安装）"></a>(2) 创建项目（脚手架安装）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue create tool  <span class="comment"># 创建名为 tool 的 Vue3 项目</span></span><br><span class="line"><span class="built_in">cd</span> tool  <span class="comment"># 进入到新创建的 tool 项目中</span></span><br><span class="line">npm install @element-plus/icons-vue  <span class="comment"># 安装 element-plus</span></span><br></pre></td></tr></table></figure><h4 id="3-运行项目"><a href="#3-运行项目" class="headerlink" title="(3) 运行项目"></a>(3) 运行项目</h4><p>我们运行 Vue 项目需要熟知如下三个命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install  <span class="comment"># 安装 package.json 中罗列的包，文件夹下出现一个名为 node_moudule 的包，打开里面可以看到许多 JavaScript 和 TypeScript 代码</span></span><br><span class="line">npm run serve  <span class="comment"># 运行项目</span></span><br><span class="line">npm run build  <span class="comment"># 服务器部署所需</span></span><br></pre></td></tr></table></figure><h4 id="4-Windows-版本（脚手架安装）"><a href="#4-Windows-版本（脚手架安装）" class="headerlink" title="(4) Windows 版本（脚手架安装）"></a>(4) Windows 版本（脚手架安装）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 已经有 node。没有 Node.js 则需要先装 Node.js</span></span><br><span class="line">sudo apt get npm  <span class="comment"># 安装 npm</span></span><br><span class="line">sudo npm install -g @vue/cli  <span class="comment"># 安装 Vue3 的脚手架</span></span><br><span class="line">vue create tool  <span class="comment"># 创建项目</span></span><br></pre></td></tr></table></figure><h4 id="5-其它"><a href="#5-其它" class="headerlink" title="(5) 其它"></a>(5) 其它</h4><ol><li>警告（Windows）：<code>npm WARN config global --global, --local are deprecated. Use --location=global instead.</code></li></ol><p>解决方法：使用管理员身份运行 PowerShell，运行 <code>npm-windows-upgrade</code>。</p><p><img src="static/practices/vue3_warn.png" alt="npm WARN"></p><ol><li><p>查看 Vue 的版本：<code>npm list vue</code></p></li><li><p>npm 太慢</p></li></ol><p><a href="https://www.runoob.com/w3cnote/npm-slow-use-cnpm.html">解决方法</a>：使用淘宝镜像。</p><p><code>npm install -g cnpm --registry=https://registry.npmmirror.com</code></p><p>运行完上述命令后，即可使用 <code>cnpm</code> 替代 <code>npm</code>。</p><h2 id="2-必要的基础语言技能"><a href="#2-必要的基础语言技能" class="headerlink" title="2. 必要的基础语言技能"></a>2. 必要的基础语言技能</h2><p>前文已经述及，由于太久没有写过 HTML 等语言，我现在的相关技能已经退化至基本没有了，所以我进行必要的基础语言技能复建。</p><h3 id="2-1-JavaScript"><a href="#2-1-JavaScript" class="headerlink" title="2.1 JavaScript"></a>2.1 JavaScript</h3><p>在 Vue3 中，JavaScript 代码被包裹在标签 <code>&lt;script&gt;</code> 中。</p><h4 id="1-重要数据结构的基本方法"><a href="#1-重要数据结构的基本方法" class="headerlink" title="(1) 重要数据结构的基本方法"></a>(1) 重要数据结构的基本方法</h4><h5 id="1-Array"><a href="#1-Array" class="headerlink" title="1. Array"></a>1. <a href="https://www.w3school.com.cn/jsref/jsref_obj_array.asp">Array</a></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化方法</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">let</span> arr2 = [];</span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 添加元素 - push</span></span><br><span class="line">arr1.<span class="title function_">push</span>(<span class="number">1</span>);  <span class="comment">// 一次性添加一个元素</span></span><br><span class="line">arr1.<span class="title function_">push</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);  <span class="comment">// 一次性添加多个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 取出元素 - pop</span></span><br><span class="line"><span class="keyword">let</span> lastItem = arr1.<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 合并两个 Array 0 concat</span></span><br><span class="line">arr1 = arr1.<span class="title function_">concat</span>(arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 遍历</span></span><br><span class="line"><span class="comment">// 5.1. 传统 for 循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++)&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.2 item 为当前元素，index 为下标</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item, index</span>)&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item + <span class="string">&#x27;|&#x27;</span> + index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.3 增强 for 循环，i 为下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 for 循环中，in 会找出 arr 的下标，of 会找出 arr 的所有元素。对于不可遍历的元素，就只能使用 in。</span></span><br></pre></td></tr></table></figure><h5 id="2-Dictionary"><a href="#2-Dictionary" class="headerlink" title="2. Dictionary"></a>2. <a href="https://pietschsoft.com/post/2015/09/05/javascript-basics-how-to-create-a-dictionary-with-keyvalue-pairs">Dictionary</a></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化方法</span></span><br><span class="line"><span class="keyword">let</span> dict = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">let</span> dict = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 添加元素</span></span><br><span class="line">dict[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> dict) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = dict[key];</span><br><span class="line">  <span class="comment">// do something with &quot;key&quot; and &quot;value&quot; variables</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 函数也可以是 key 或者 value，我觉得这个功能应该很好玩，但我还没试过。</span></span><br><span class="line"><span class="keyword">let</span> sleep = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Let us sleep!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">dict[<span class="string">&#x27;rest&#x27;</span>] = sleep</span><br><span class="line">dict.<span class="title function_">rest</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-Set"><a href="#3-Set" class="headerlink" title="3. Set"></a>3. <a href="https://www.w3school.com.cn/js/js_object_sets.asp">Set</a></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化方法</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 添加元素 - add</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="4-Map"><a href="#4-Map" class="headerlink" title="4. Map"></a>4. <a href="https://www.w3school.com.cn/js/js_object_maps.asp">Map</a></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂时没有使用过，不做评价</span></span><br></pre></td></tr></table></figure><h4 id="2-代码调试小技巧"><a href="#2-代码调试小技巧" class="headerlink" title="(2) 代码调试小技巧"></a>(2) 代码调试小技巧</h4><p>当有不确定的代码时，可以先<strong>在浏览器的控制台直接输入代码</strong>，查看其效果。这样比较方便调试。</p><h4 id="3-JavaScript-动态生成-CSS"><a href="#3-JavaScript-动态生成-CSS" class="headerlink" title="(3) JavaScript 动态生成 CSS"></a>(3) JavaScript 动态生成 CSS</h4><p>以一段项目中的代码为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addCSS</span>(<span class="params">className, colorValue</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dotClassName = <span class="string">&#x27;.&#x27;</span> + className</span><br><span class="line">  <span class="keyword">let</span> colorAttribute = <span class="string">&#x27;color: &#x27;</span> + colorValue + <span class="string">&#x27;;&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(style);</span><br><span class="line">  <span class="keyword">if</span>(!(style.<span class="property">sheet</span>||&#123;&#125;).<span class="property">insertRule</span>) </span><br><span class="line">    (style.<span class="property">styleSheet</span> || style.<span class="property">sheet</span>).<span class="title function_">addRule</span>(dotClassName, colorAttribute);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    style.<span class="property">sheet</span>.<span class="title function_">insertRule</span>(dotClassName + <span class="string">&quot;&#123;&quot;</span> + colorAttribute + <span class="string">&quot;&#125;&quot;</span>,<span class="number">0</span>);  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>使用 <code>document.getElementsByTagName(&#39;head&#39;)</code> 获取页面中的 <code>head</code> 元素，然后在其后添加包含 CSS 代码的子节点。</p><h3 id="2-2-CSS"><a href="#2-2-CSS" class="headerlink" title="2.2 CSS"></a>2.2 CSS</h3><p>在 Vue3 中，CSS 代码被包裹在标签 <code>&lt;style&gt;</code> 中。</p><p>使用选择器获取页面元素。</p><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a><a href="https://www.w3school.com.cn/css/css_selectors.asp">选择器</a></h4><ul><li>元素选择器根据元素名称来选择 HTML 元素。<code>p</code></li><li>id 选择器使用 HTML 元素的 id 属性来选择特定元素。<code>#id</code></li><li>类选择器选择有特定 class 属性的 HTML 元素。<code>.classname</code></li><li>通用选择器（<em>）选择页面上的所有的 HTML 元素。`</em>`</li><li>分组选择器选取所有具有相同样式定义的 HTML 元素。<code>p, h1, h2</code></li></ul><p>上述选择器是基础用法，我们可以使用逻辑组合伪类。比如元素的最后一个节点：<code>p:last-child</code>。类似的用法可以在用到的时候进行查询。</p><h3 id="2-3-HTML"><a href="#2-3-HTML" class="headerlink" title="2.3 HTML"></a>2.3 HTML</h3><p>在 Vue3 中，HTML 代码被包裹在标签 <code>&lt;template&gt;</code> 中。</p><h2 id="3-常见问题及解决方式"><a href="#3-常见问题及解决方式" class="headerlink" title="3. 常见问题及解决方式"></a>3. 常见问题及解决方式</h2><h3 id="3-1-不同组件传值"><a href="#3-1-不同组件传值" class="headerlink" title="3.1 不同组件传值"></a>3.1 不同组件传值</h3><h4 id="1-子组件向父组件传值-emit"><a href="#1-子组件向父组件传值-emit" class="headerlink" title="(1) 子组件向父组件传值: emit"></a>(1) 子组件向父组件传值: <strong>emit</strong></h4><p><code>App.vue</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;Child @childVariableName=&quot;parentMethod($event)&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Child from &quot;./components/Child&quot;</span><br><span class="line">  export default&#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Child,</span><br><span class="line">    &#125;,</span><br><span class="line">    data()</span><br><span class="line">    &#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        title:&#x27;Old Title&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      parentMethod(title)</span><br><span class="line">      &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p><code>Child.vue</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template lang=&quot;html&quot;&gt;</span><br><span class="line">  &lt;button type=&quot;button&quot; @click=&#x27;childMethod&#x27;&gt; Update me &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name:&#x27;Child&#x27;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    childMethod()</span><br><span class="line">    &#123;</span><br><span class="line">      this.$emit(&#x27;childVariableName&#x27;, &#x27;New Title&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2-子组件向父组件传递多个值"><a href="#2-子组件向父组件传递多个值" class="headerlink" title="(2) 子组件向父组件传递多个值"></a>(2) 子组件向父组件传递多个值</h4><p>将 <code>App.vue</code> 中的 <code>&lt;Child @childVariableName=&quot;parentMethod($event)&quot; /&gt;</code> 改为 <code>&lt;Child @childVariableName=&quot;parentMethod&quot; /&gt;</code>，将 <code>Child.vue</code> 中的 <code>this.$emit(&#39;childVariableName&#39;, &#39;New Title&#39;)</code> 改为 <code>this.$emit(&#39;changeTitle&#39;, data1, data2, ...)</code></p><h4 id="3-父组件向子组件传值-Props"><a href="#3-父组件向子组件传值-Props" class="headerlink" title="(3) 父组件向子组件传值: Props"></a>(3) 父组件向子组件传值: Props</h4><p><code>Parent.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;Child childValue=&quot;This is parent value&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Child from &quot;./components/Child&quot;</span><br><span class="line">  export default&#123;</span><br><span class="line">    name:&#x27;Parent&#x27;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Child,</span><br><span class="line">    &#125;,</span><br><span class="line">    data()</span><br><span class="line">    &#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        parentValue: &#x27;Parent Value&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>Child.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template lang=&quot;html&quot;&gt;</span><br><span class="line">  &#123;&#123; childValue &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name:&#x27;Child&#x27;,</span><br><span class="line">  props: [&#x27;childValue&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果所传的值是个变量，需要在变量前加冒号 <code>:</code></p><p><code>Parent.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;Child :childValue=&quot;parentValue&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Child from &quot;./components/Child&quot;</span><br><span class="line">  export default&#123;</span><br><span class="line">    name:&#x27;Parent&#x27;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Child,</span><br><span class="line">    &#125;,</span><br><span class="line">    data()</span><br><span class="line">    &#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        parentValue: &#x27;Parent Value&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>Child.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template lang=&quot;html&quot;&gt;</span><br><span class="line">  &#123;&#123; childValue &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name:&#x27;Child&#x27;,</span><br><span class="line">  props: [&#x27;childValue&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 props 从父节点传递到子节点的数据值是不可更改的，因此如果想要对该数值进行修改等操作，需要通过重新定义一个新的变量来复制该数据，进而对新变量进行操作。</p><p><code>Child.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template lang=&quot;html&quot;&gt;</span><br><span class="line">  &#123;&#123; childValue &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name:&#x27;Child&#x27;,</span><br><span class="line">  props: [&#x27;childValue&#x27;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      copiedChildValue: childValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateValue(newValue) &#123;</span><br><span class="line">      this.copiedChildValue = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-父子组件之间值的动态变化"><a href="#4-父子组件之间值的动态变化" class="headerlink" title="(4) 父子组件之间值的动态变化"></a>(4) 父子组件之间值的动态变化</h4><p>当子组件构建完毕后，父组件传递的值发生了变化，此时子组件是不会发生变化的。为了能让子组件相应父组件的变化，我们必须借助生命周期函数 <code>watch</code> 来监视该变量的变化。</p><p><code>Parent.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;Child :childValue=&quot;parentValue&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Child from &quot;./components/Child&quot;</span><br><span class="line">  export default&#123;</span><br><span class="line">    name:&#x27;Parent&#x27;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Child,</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        parentValue: &#x27;Parent Value&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>Child.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&#x27;showValue&#x27;&gt;</span><br><span class="line">  &#123;&#123; childValue &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name:&#x27;Child&#x27;,</span><br><span class="line">  props: [&#x27;childValue&#x27;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      parentValue: &#x27;Parent Value&#x27;,</span><br><span class="line">      showValue: false,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    // 被监听的对象</span><br><span class="line">    childValue: &#123;</span><br><span class="line">      immediate: true,      </span><br><span class="line">      handler (newValue) &#123;</span><br><span class="line">        // 销毁当前组件</span><br><span class="line">        this.showValue = false</span><br><span class="line">        this.$nextTick(() =&gt; &#123;</span><br><span class="line">          this.parentValue = newValue</span><br><span class="line">          this.showValue = true</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-非父子节点传值"><a href="#5-非父子节点传值" class="headerlink" title="(5) 非父子节点传值"></a>(5) 非父子节点传值</h4><p>我的做法是在两个组件的共同父组件中进行数值的转发。这样做的原因是这两个节点属于兄弟节点，它们的关系比较密切。实际上还有其他的官方发布的<a href="https://zhuanlan.zhihu.com/p/51001131">非父子组件间的传值方案</a>。</p><p>目前还没有尝试过。</p><h3 id="3-2-钩子函数"><a href="#3-2-钩子函数" class="headerlink" title="3.2 钩子函数"></a>3.2 钩子函数</h3><h4 id="关于-computed、methods、watch，mounted"><a href="#关于-computed、methods、watch，mounted" class="headerlink" title="关于 computed、methods、watch，mounted"></a>关于 computed、methods、watch，mounted</h4><p>区别见<a href="https://www.cnblogs.com/binmengxue/p/9958174.html">此处链接</a></p><ol><li>computed是在HTML DOM加载后马上执行的，如赋值；</li><li>methods则必须要有一定的触发条件才能执行，如点击事件；</li><li>watch呢？它用于观察Vue实例上的数据变动。对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。所以他们的执行顺序为：默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。</li><li>mounted 是生命周期</li><li>created和mounted区别？</li></ol><h4 id="watch-同时监听多个值"><a href="#watch-同时监听多个值" class="headerlink" title="watch 同时监听多个值"></a>watch 同时监听多个值</h4><p>首先使用 computed 定义一个复合对象吧，然后再对该对象进行 watch。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ...,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">propsVariables</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; val1, val2 &#125; = <span class="variable language_">this</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        vall1,</span><br><span class="line">        val2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">propsVariables</span>: &#123;</span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">      handler (newValue) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue.<span class="property">val1</span>, newValue.<span class="property">val2</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-ElementPlus-组件的属性、方法、事件、插槽及样式修改"><a href="#3-3-ElementPlus-组件的属性、方法、事件、插槽及样式修改" class="headerlink" title="3.3 ElementPlus 组件的属性、方法、事件、插槽及样式修改"></a>3.3 ElementPlus 组件的属性、方法、事件、插槽及样式修改</h3><p>这一部分可以重点关注官方文档。由于我在此次项目中重点使用了 <a href="https://element-plus.gitee.io/zh-CN/component/tree.html">Vue3 的树</a>，所以我以对 Vue3 的树进行样式修改为例。</p><h4 id="1-属性"><a href="#1-属性" class="headerlink" title="(1) 属性"></a>(1) 属性</h4><p>属性是指在 element 组件的基础上，在其元素上添加给定的属性，以提高其灵活性。</p><p>Tree 组件的属性节选如下：</p><p><img src="static/practices/vue3_element_property.png" alt="Tree 组件的属性节选"></p><p>在构建树的时候，我们可以直接将常量或变量复制给特定的属性。<br>在下面的代码中，我给 Tree 组件传进去了包括 <code>data</code>、<code>empty-text</code>、<code>show-checkbox</code> 等值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;grid-content&quot; style=&quot;text-align: left&quot;&gt;</span><br><span class="line">      &lt;el-tree</span><br><span class="line">        v-if=&quot;showReady&quot;</span><br><span class="line">        :data=&quot;[treeHierarchy]&quot;</span><br><span class="line">        :ref=&quot;treeName&quot;</span><br><span class="line">        empty-text=&#x27;No Results&#x27;</span><br><span class="line">        show-checkbox</span><br><span class="line">        node-key=&quot;id&quot;</span><br><span class="line">        indent=&quot;25&quot;</span><br><span class="line">        default-expand-all</span><br><span class="line">        :default-checked-keys=&#x27;[rootId]&#x27;</span><br><span class="line">        :props=&quot;&#123;</span><br><span class="line">                  children: &#x27;children&#x27;,</span><br><span class="line">                  label: &#x27;name&#x27;,</span><br><span class="line">                  class: customNodeClass,</span><br><span class="line">                &#125;&quot;</span><br><span class="line">        @check-change=&quot;handleCheckChange&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;template v-slot:default=&quot;&#123; node &#125;&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;custom-node&quot; style=&#x27;word-wrap:break-word;&#x27; &gt;</span><br><span class="line">              &lt;!-- content --&gt;</span><br><span class="line">              &#123;&#123; node.label &#125;&#125;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/el-tree&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-方法"><a href="#2-方法" class="headerlink" title="(2) 方法"></a>(2) 方法</h4><p>Tree 组件的方法节选如下：</p><p><img src="static/practices/vue3_tree_method.png" alt="Tree 组件的方法节选"></p><p>在使用 Tree 组件的时候，我们需要先获取 Tree 组件，在下面的代码里，我通过 ref 属性给 Tree 组件添加了一个名字，在 <code>methods</code> 中添加了一行代码 <code>let retNodes = this.$refs[&#39;treename&#39;].getCheckedNodes()</code> 以获取当前选中的节点数组。之所以可以调用 getCheckedNodes() 方法是因为在文档中清晰地告知了可以使用该方法。但是我一开始没有看明白文档中方法的使用方式，所以在查找资料上花费了很多时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-tree</span><br><span class="line">    :data=&quot;data&quot;</span><br><span class="line">    show-checkbox</span><br><span class="line">    ref=&#x27;treename&#x27;</span><br><span class="line">    node-key=&quot;id&quot;</span><br><span class="line">    :default-expanded-keys=&quot;[2, 3]&quot;</span><br><span class="line">    :default-checked-keys=&quot;[5]&quot;</span><br><span class="line">    :props=&quot;defaultProps&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">  const defaultProps = &#123;</span><br><span class="line">    children: &#x27;children&#x27;,</span><br><span class="line">    label: &#x27;label&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">  const data = [</span><br><span class="line">    &#123;</span><br><span class="line">      id: 1,</span><br><span class="line">      label: &#x27;Level one 1&#x27;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 4,</span><br><span class="line">          label: &#x27;Level two 1-1&#x27;,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              id: 9,</span><br><span class="line">              label: &#x27;Level three 1-1-1&#x27;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              id: 10,</span><br><span class="line">              label: &#x27;Level three 1-1-2&#x27;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      id: 2,</span><br><span class="line">      label: &#x27;Level one 2&#x27;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 5,</span><br><span class="line">          label: &#x27;Level two 2-1&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 6,</span><br><span class="line">          label: &#x27;Level two 2-2&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      id: 3,</span><br><span class="line">      label: &#x27;Level one 3&#x27;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 7,</span><br><span class="line">          label: &#x27;Level two 3-1&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 8,</span><br><span class="line">          label: &#x27;Level two 3-2&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">  </span><br><span class="line">  export default: &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      test() &#123;</span><br><span class="line">        let retNodes = this.$refs[&#x27;treename&#x27;].getCheckedNodes()</span><br><span class="line">        console.log(retNodes)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="3-事件"><a href="#3-事件" class="headerlink" title="(3) 事件"></a>(3) 事件</h4><p>Tree 组件的事情节选如下：</p><p><img src="static/practices/vue3_tree_event.png" alt="Tree 组件的事情节选"></p><p>回调参数的意思是，如果我们调用事件，那我们就可以获得 Tree 组件包装的函数的返回值。以 check-change 函数为例，我们自定义一个函数 handleCheckChange，当复选框被点击的时候，handleCheckChange 函数就会被执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-tree</span><br><span class="line">    :data=&quot;data&quot;</span><br><span class="line">    show-checkbox</span><br><span class="line">    ref=&#x27;treename&#x27;</span><br><span class="line">    node-key=&quot;id&quot;</span><br><span class="line">    :default-expanded-keys=&quot;[2, 3]&quot;</span><br><span class="line">    :default-checked-keys=&quot;[5]&quot;</span><br><span class="line">    :props=&quot;defaultProps&quot;</span><br><span class="line">    @check-change=&quot;handleCheckChange&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">  const defaultProps = &#123;</span><br><span class="line">    children: &#x27;children&#x27;,</span><br><span class="line">    label: &#x27;label&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">  const data = [</span><br><span class="line">    &#123;</span><br><span class="line">      id: 1,</span><br><span class="line">      label: &#x27;Level one 1&#x27;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 4,</span><br><span class="line">          label: &#x27;Level two 1-1&#x27;,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              id: 9,</span><br><span class="line">              label: &#x27;Level three 1-1-1&#x27;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              id: 10,</span><br><span class="line">              label: &#x27;Level three 1-1-2&#x27;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      id: 2,</span><br><span class="line">      label: &#x27;Level one 2&#x27;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 5,</span><br><span class="line">          label: &#x27;Level two 2-1&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 6,</span><br><span class="line">          label: &#x27;Level two 2-2&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      id: 3,</span><br><span class="line">      label: &#x27;Level one 3&#x27;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 7,</span><br><span class="line">          label: &#x27;Level two 3-1&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 8,</span><br><span class="line">          label: &#x27;Level two 3-2&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">  </span><br><span class="line">  export default: &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleCheckChange(data1, data2) &#123;</span><br><span class="line">        console.log(data1, data2)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="4-插槽"><a href="#4-插槽" class="headerlink" title="(4) 插槽"></a>(4) 插槽</h4><p>ElementPlus 的插槽。仍旧以 Tree 组件为例，我想要修改树上每个节点的内容，那我就可以通过插槽对其样式进行修改。下面我决定将节点上的字变为红色。当然，我们也可以在 slot 中添加图标或任何其他想要的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-tree</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-if</span>=<span class="string">&quot;showReady&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:data</span>=<span class="string">&quot;[treeHierarchy]&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:ref</span>=<span class="string">&quot;treeName&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">show-checkbox</span></span></span><br><span class="line"><span class="tag">  <span class="attr">node-key</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">default-expand-all</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:default-checked-keys</span>=<span class="string">&#x27;[rootId]&#x27;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:props</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">            children: &#x27;children&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">            label: &#x27;name&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">            class: customNodeClass,</span></span></span><br><span class="line"><span class="string"><span class="tag">          &#125;&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">check-change</span>=<span class="string">&quot;handleCheckChange&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;&#123; node &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;template #default=&quot;scope&quot;&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element-tree-line</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:node</span>=<span class="string">&quot;node&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:showLabelLine</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">indent</span>=<span class="string">&quot;25&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;custom-node&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;word-wrap:break-word;&#x27;</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">color</span>=<span class="string">&#x27;red&#x27;</span>&gt;</span>&#123;&#123; node.label &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">element-tree-line</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-tree</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>v-slot</code> 就是我们放进去的插槽。其实，<code>v-slot</code> 是 Vue2 的写法，Vue3 的新写法是 <code>&lt;template #default=&quot;scope&quot;&gt;</code>。</p><h4 id="5-CSS-修改"><a href="#5-CSS-修改" class="headerlink" title="(5) CSS 修改"></a>(5) CSS 修改</h4><p>对于给定的组件，我们经常需要对其进行修改。因为官方的组件虽然做了很多基础的工作，但也给了很多限制。对 CSS 的样式进行修改这一部分内容我们需要知晓如下两种情况。</p><h5 id="1-CSS-添加-class"><a href="#1-CSS-添加-class" class="headerlink" title="1. CSS 添加 class"></a>1. CSS 添加 class</h5><p>以 Tree 组件为例，我在 props 里为其添加了 class。</p><p><img src="static/practices/vue3_tree_props.png" alt="element_tree_class"></p><p>在 class 中，如果有 <code>no-check-node</code>，节点就不会显示复选框。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;grid-content&quot; style=&quot;text-align: left&quot;&gt;</span><br><span class="line">    &lt;el-tree</span><br><span class="line">      :data=&quot;[treeHierarchy]&quot;</span><br><span class="line">      :ref=&quot;treeName&quot;</span><br><span class="line">      empty-text=&#x27;No Results&#x27;</span><br><span class="line">      show-checkbox</span><br><span class="line">      node-key=&quot;id&quot;</span><br><span class="line">      default-expand-all</span><br><span class="line">      :default-checked-keys=&#x27;[rootId]&#x27;</span><br><span class="line">      :props=&quot;&#123;</span><br><span class="line">                children: &#x27;children&#x27;,</span><br><span class="line">                label: &#x27;name&#x27;,</span><br><span class="line">                class: customNodeClass,</span><br><span class="line">              &#125;&quot;</span><br><span class="line">      @check-change=&quot;handleCheckChange&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">// 给节点添加class</span><br><span class="line">const customNodeClass = (data) =&gt; &#123;</span><br><span class="line">  let ret = data.colorClass</span><br><span class="line">  // 针对描述型的节点不显示其复选框</span><br><span class="line">  if (undefined === nodeType || nodeType !== &#x27;Notion&#x27;) &#123;</span><br><span class="line">    ret += &#x27; no-checkbox-node&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;MyTree&#x27;,</span><br><span class="line">  components: &#123; ElementTreeLine: getElementLabelLine(h) &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    &#x27;treeHierarchy&#x27;: &#123;</span><br><span class="line">      require: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x27;treeName&#x27;: &#123;</span><br><span class="line">      require: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x27;rootId&#x27;: &#123;</span><br><span class="line">      require: true</span><br><span class="line">    &#125;, </span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      customNodeClass,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>除了借助已有的 class 外，我们也可以自己新建 class，添加至 HTML 元素上，然后编写 CSS 代码对元素的表现形式进行控制。</p><h5 id="2-less-和-sass"><a href="#2-less-和-sass" class="headerlink" title="2. less 和 sass"></a>2. less 和 sass</h5><p>在查找 Vue3 和 ElementPlus 的资料时，搜索引擎给了我许多 Vue2 和 ElementUI 的资料，有一部分不可以使用在新版本上，但是还有一部分是可以类推到新版本上。其中，许多样式的修改使用到了 <code>less</code>。使用 <code>less</code> 之前需要先下载 <code>less-loader</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev less-loader less</span><br></pre></td></tr></table></figure><p>在开发完成后，我们需要将 less 代码转换为 CSS。</p><blockquote><p>首先sass和less都是css的预编译处理语言，他们引入了mixins，参数，嵌套规则，运算，颜色，名字空间，作用域，JavaScript赋值等 加快了css开发效率,当然这两者都可以配合gulp和grunt等前端构建工具使用</p><p>sass和less主要区别:在于实现方式 less是基于JavaScript的在客户端处理 所以安装的时候用npm，sass是基于ruby所以在服务器处理。</p><p>很多开发者不会选择LESS因为JavaScript引擎需要额外的时间来处理代码然后输出修改过的CSS到浏览器。关于这个有很多种方式，我选择的是只在开发环节使用LESS。一旦我完成了开发，我就复制然后粘贴LESS输出的到一个压缩器，然后到一个单独的CSS文件来替代LESS文件。另一个选择是使用LESS.app来编译和压缩你的LESS文件。两个选择都将最小化你的样式输出，从而避免由于用户的浏览器不支持JavaScript而可能引起的任何问题。尽管这不大可能，但终归是有可能的。<br>摘自 <a href="https://www.jianshu.com/p/e3f1fcbbccc3">LESS与SASS的区别</a></p></blockquote><h3 id="3-4-工具"><a href="#3-4-工具" class="headerlink" title="3.4 工具"></a>3.4 工具</h3><h4 id="前端展示的代码高亮工具"><a href="#前端展示的代码高亮工具" class="headerlink" title="前端展示的代码高亮工具"></a>前端展示的代码高亮工具</h4><p>选择了 <code>Prism.js</code>。详细解释见如下两个链接：<a href="http://prismjs.com/index.html">Prism.js 官网链接</a>、<a href="https://segmentfault.com/a/1190000009122617">Prism.js 简单使用文档</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todo: 如何下载</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">class</span>=<span class="string">&quot;language-java&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">code</span> <span class="attr">class</span>=<span class="string">&quot;language-java&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;&#123; code &#125;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">import Prism <span class="selector-tag">from</span> &quot;prismjs&quot;;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">Prism<span class="selector-class">.highlightAll</span>()</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="3-5-报错与特定功能实现"><a href="#3-5-报错与特定功能实现" class="headerlink" title="3.5 报错与特定功能实现"></a>3.5 报错与特定功能实现</h3><h4 id="1-Vue3-文件导入-JavaScript-文件的值"><a href="#1-Vue3-文件导入-JavaScript-文件的值" class="headerlink" title="(1) Vue3 文件导入 JavaScript 文件的值"></a>(1) Vue3 文件导入 JavaScript 文件的值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; importedVariable &#125; <span class="keyword">from</span> <span class="string">&#x27;data&#x27;</span></span><br></pre></td></tr></table></figure><p>千万不可以少两个花括号 <code>import variable from &#39;data&#39;</code>，不然无法识别。</p><p>上面的代码生效的前提是，只有在 <code>data.js</code> 中有默认导出的 <code>export default</code> 语法时才会生效。也就是说，<code>data.js</code> 中有如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> importedVariable = <span class="string">&#x27;importedVariable&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  importedVariable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-export-default-和-export-的区别"><a href="#2-export-default-和-export-的区别" class="headerlink" title="(2) export default 和 export 的区别"></a>(2) <code>export default</code> 和 <code>export</code> 的区别</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>export 和 export default 实现的功能相同，即：可用于导出（暴露）常量、函数、文件、模块等，以便其他文件调用。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>1、export 导出多个对象，export default 只能导出一个对象</p><p>2、export 导出对象需要用 { }，export default 不需要 { }，如：</p><p>export { A,B,C };</p><p>export default A;</p><p>3、在其他文件引用 export default 导出的对象时不一定使用导出时的名字。因为这种方式实际上是将该导出对象设置为默认导出对象，如：</p><p>假设文件 A、B 在同级目录，实现文件 B 引入文件 A 的导出对象 deObject：</p><p>文件 A：export default deObject</p><p>文件 B：import deObject from ‘./A’</p><p>或者：</p><p>import newDeObject from ‘./A’</p><h4 id="3-Vue3-无法正常显示图标-el-icon"><a href="#3-Vue3-无法正常显示图标-el-icon" class="headerlink" title="(3) Vue3 无法正常显示图标 el-icon"></a>(3) Vue3 无法正常显示图标 el-icon</h4><p>我首先通过 npm 全局导入 element-icon（<a href="https://element-plus.org/en-US/component/icon.html#using-packaging-manager">icon 导入方式</a>），运行命令 <code>npm install @element-plus/icons-vue</code> ，图标不显示。<br>随后我尝试将 icon 组件导入需要使用该 icon 的文件，图标仍然不显示。<br>最后我将图标的 svg 复制下来，最终才正常显示 el-icon。</p><p>在 <a href="https://element-plus.org/en-US/component/icon.html#icon-collection">icon 的代码复制界面</a> 选择“Copy svg content”，即可复制该代码的 svg 值，随后我们将其复制在我们需要的 HTML 代码中。</p><h4 id="4-Vue3-不显示-element-tree"><a href="#4-Vue3-不显示-element-tree" class="headerlink" title="(4) Vue3 不显示 element-tree"></a>(4) Vue3 不显示 element-tree</h4><p>原因一：<br>在 <code>&lt;style&gt;</code> 下使用了 methods 中的方法，导致找不到方法，所以 el-tree 无法显示。</p><p>原因二：传进去的 data 不是 list<br>报错： <code>Uncaught (in promise) TypeError: children.indexOf is not a function</code>。<br>解决方法：在传入的 data 中添加一个 [] </p><h4 id="5-Vue3-文件中定义了两个同名全局变量"><a href="#5-Vue3-文件中定义了两个同名全局变量" class="headerlink" title="(5) Vue3 文件中定义了两个同名全局变量"></a>(5) Vue3 文件中定义了两个同名全局变量</h4><p>报错：<code>error Duplicated key</code>，详见<a href="https://eslint.vuejs.org/rules/no-dupe-keys.html">解释</a>。<br>解决方法：将两个同名变量修改为不同名称。</p><h4 id="6-设置全部节点默认选中"><a href="#6-设置全部节点默认选中" class="headerlink" title="(6) 设置全部节点默认选中"></a>(6) 设置全部节点默认选中</h4><p>实际上仅需设置选中根节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:default-checked-keys=&#x27;[rootId]&#x27;</span><br></pre></td></tr></table></figure><p>在 Tree 组件中添加属性 <code>default-checked-keys</code>，<code>rootId</code> 是一个变量，表示根节点。</p><h4 id="7-控制链接的大小和颜色"><a href="#7-控制链接的大小和颜色" class="headerlink" title="(7) 控制链接的大小和颜色"></a>(7) 控制链接的大小和颜色</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: inherit;  <span class="comment">/* 继承父节点的颜色 */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;  <span class="comment">/*超链接无下划线*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;  <span class="comment">/*鼠标放上去有下划线*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-在-Tree-组件上添加虚线"><a href="#8-在-Tree-组件上添加虚线" class="headerlink" title="(8) 在 Tree 组件上添加虚线"></a>(8) 在 Tree 组件上添加虚线</h4><p>安装网友写的<a href="https://npm.io/package/element-plus-tree-line">插件</a> <code>element-tree-line</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;el-tree</span><br><span class="line">        :data=&quot;data&quot;</span><br><span class="line">        show-checkbox</span><br><span class="line">        node-key=&quot;id&quot;</span><br><span class="line">        draggable</span><br><span class="line">        :default-expanded-keys=&quot;[2, 3]&quot;</span><br><span class="line">        :default-checked-keys=&quot;[5]&quot;</span><br><span class="line">        :props=&quot;defaultProps&quot;</span><br><span class="line">        :indent=&quot;treeIndent&quot;</span><br><span class="line">        &gt;&lt;template v-slot:default=&quot;&#123; node &#125;&quot;&gt;</span><br><span class="line">            &lt;element-tree-line</span><br><span class="line">                :node=&quot;node&quot;</span><br><span class="line">                :indent=&quot;treeIndent&quot;</span><br><span class="line">            &gt;</span><br><span class="line">                &lt;template v-slot:node-label&gt;</span><br><span class="line">                    &lt;span style=&quot;font-size: 12px&quot;&gt;</span><br><span class="line">                        &#123;&#123; node.label &#125;&#125;</span><br><span class="line">                    &lt;/span&gt;</span><br><span class="line">                &lt;/template&gt;</span><br><span class="line">            &lt;/element-tree-line&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">    &lt;/el-tree&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; getElementLabelLine &#125; from &#x27;element-tree-line&#x27;;</span><br><span class="line">    import &#x27;element-tree-line/dist/style.css&#x27;;</span><br><span class="line">    import &#123; h &#125; from &#x27;vue&#x27;;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &#x27;App&#x27;,</span><br><span class="line">        components: &#123; ElementTreeLine: getElementLabelLine(h) &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                treeIndent: 30,</span><br><span class="line">                data: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        id: 1,</span><br><span class="line">                        label: &#x27;Level one 1&#x27;,</span><br><span class="line">                        children: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                id: 4,</span><br><span class="line">                                label: &#x27;Level two 1-1&#x27;,</span><br><span class="line">                                children: [</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        id: 9,</span><br><span class="line">                                        label: &#x27;Level three 1-1-1&#x27;,</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        id: 10,</span><br><span class="line">                                        label: &#x27;Level three 1-1-2&#x27;,</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                ],</span><br><span class="line">                            &#125;,</span><br><span class="line">                        ],</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        id: 2,</span><br><span class="line">                        label: &#x27;Level one 2&#x27;,</span><br><span class="line">                        children: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                id: 5,</span><br><span class="line">                                label: &#x27;Level two 2-1&#x27;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                id: 6,</span><br><span class="line">                                label: &#x27;Level two 2-2&#x27;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        ],</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        id: 3,</span><br><span class="line">                        label: &#x27;Level one 3&#x27;,</span><br><span class="line">                        children: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                id: 7,</span><br><span class="line">                                label: &#x27;Level two 3-1&#x27;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                id: 8,</span><br><span class="line">                                label: &#x27;Level two 3-2&#x27;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        ],</span><br><span class="line">                    &#125;,</span><br><span class="line">                ],</span><br><span class="line">                defaultProps: &#123;</span><br><span class="line">                    children: &#x27;children&#x27;,</span><br><span class="line">                    label: &#x27;label&#x27;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.element-tree-node-line-hor &#123;</span><br><span class="line">  border-bottom: 1px dashed #409eff;</span><br><span class="line">&#125;</span><br><span class="line">.element-tree-node-line-ver &#123;</span><br><span class="line">  border-left: 1px dashed #409eff;</span><br><span class="line">&#125;</span><br><span class="line">.element-tree-node-line-ver.last-node-line &#123;</span><br><span class="line">  border-left: 1px dashed transparent;</span><br><span class="line">&#125;</span><br><span class="line">.element-tree-node-line-ver.last-node-isLeaf-line &#123;</span><br><span class="line">  height: 50%;</span><br><span class="line">&#125;</span><br><span class="line">.element-tree-node-label-line &#123;</span><br><span class="line">  border: 0px;</span><br><span class="line">&#125;</span><br><span class="line">.el-tree-node__expand-icon &#123;</span><br><span class="line">  color: #409eff</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码效果图如下：</p><p><img src="static/practices/vue3_element_line.png" alt="element-tree-line"></p><h4 id="9-元素和页面一样高"><a href="#9-元素和页面一样高" class="headerlink" title="(9) 元素和页面一样高"></a>(9) 元素和页面一样高</h4><p>使用 <code>height=&#39;100vh&#39;</code>。</p>]]></content>
    
    
    <summary type="html">本文记录了使用 Vue3 + ElementPlus 开发论文中前端工具的具体过程。</summary>
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="论文" scheme="https://luorongluorong.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="练习" scheme="https://luorongluorong.github.io/tags/%E7%BB%83%E4%B9%A0/"/>
    
    <category term="前端" scheme="https://luorongluorong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue3" scheme="https://luorongluorong.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>TODO_静态程序分析工具 Antlr 简介</title>
    <link href="https://luorongluorong.github.io/2021/12/08/practices/antlr/"/>
    <id>https://luorongluorong.github.io/2021/12/08/practices/antlr/</id>
    <published>2021-12-08T06:39:19.000Z</published>
    <updated>2023-02-17T05:14:16.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态程序分析工具-Antlr-简介"><a href="#静态程序分析工具-Antlr-简介" class="headerlink" title="静态程序分析工具 Antlr 简介"></a>静态程序分析工具 Antlr 简介</h1><h2 id="一、简介及展示"><a href="#一、简介及展示" class="headerlink" title="一、简介及展示"></a>一、简介及展示</h2><h4 id="Antlr-简介"><a href="#Antlr-简介" class="headerlink" title="Antlr 简介"></a>Antlr 简介</h4><p><strong>ANTLR</strong> (ANother Tool for Language Recognition) is a powerful <strong>parser generator</strong> for reading, processing, executing, or translating structured text or binary files. It’s widely used to build languages, tools, and frameworks. From a <strong>grammar</strong>, ANTLR generates a <strong>parser</strong> that can build and walk <strong>parse tree</strong>s.（见 <a href="https://www.antlr.org/index.html">https://www.antlr.org/index.html</a>）</p><p>最新版本 4.9.3（截止至 2021年12月1日，见 <a href="https://www.antlr.org/download.html">https://www.antlr.org/download.html</a>），可以解析如下程序设计语言:</p><ul><li>Java</li><li>C# (and an alternate C# target)</li></ul><ul><li>Python (2 and 3)</li><li>JavaScript</li></ul><ul><li>Go</li><li>C++</li></ul><ul><li>Swift</li><li>PHP</li></ul><ul><li>DART</li></ul><p>针对上述每一种程序设计语言，Antlr 提供相应的 grammar lexicon。</p><h4 id="Antlr-使用展示"><a href="#Antlr-使用展示" class="headerlink" title="Antlr 使用展示"></a>Antlr 使用展示</h4><p>使用 Antlr 进行程序分析。</p><p>代码文件 <code>test.cpp</code> 如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">addOne</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ten</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line">b = <span class="built_in">addOne</span>(a);</span><br><span class="line">c = b - <span class="number">3</span>;</span><br><span class="line">b = <span class="built_in">ten</span>();</span><br><span class="line">c = a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addOne</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> y = x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ten</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>test.cpp</code> 的 AST 如下图所示：</p><p><img src="static/practices/antlr_01.png" alt="antlr_01"></p><p>以该代码文件的第一行 <code>int addOne(int x);</code> 为例，其子树如下图所示：</p><p><img src="static/practices/antlr_02.png" alt="antlr_02"></p><p>从叶子节点来看，Antlr 将代码 <code>int addOne(int x);</code> 成功解析出来了。</p><h4 id="Antlr-开发流程"><a href="#Antlr-开发流程" class="headerlink" title="Antlr 开发流程"></a>Antlr 开发流程</h4><p>一般开发流程如下：</p><ol><li>定义 .g4 <strong>语法文件</strong>；</li><li>使用 ANTLR4 生成<strong>词法分析器</strong>（Lexer）和<strong>语法分析器</strong>（Parser）目标编程语言代码；</li></ol><ol><li>遍历 <strong>AST</strong>（Abstract Syntax Tree 抽象语法树），ANTLR 4 支持两种模式：访问者模式（Visitor）和监听器模式（Listener）。</li></ol><h4 id="本文总览"><a href="#本文总览" class="headerlink" title="本文总览"></a>本文总览</h4><p>Antlr 简介 👉 静态程序分析（Antlr 存在的意义） 👉 编译（AST 在编译中的位置） 👉 AST 简介 👉 grammar lexicon（如何使用 Antlr 生成可使用的代码） 👉 AST 的遍历方式（Antlr 提供的遍历方式） 👉 使用 Antlr 的应用 👉 和 Antlr 对标的静态程序工具</p><h2 id="二、程序分析"><a href="#二、程序分析" class="headerlink" title="二、程序分析"></a>二、程序分析</h2><p>什么是程序分析？是指在<strong>不运行代码</strong>的方式下，通过<strong>词法分析</strong>、<strong>语法分析</strong>、<strong>控制流分析</strong>、<strong>数据流分析</strong>等技术对程序代码进行扫描，验证代码是否满足规范性、安全性、可靠性、可维护性等指标的一种代码分析技术。目前静态分析技术向模拟执行的技术发展以能够发现更多传统意义上动态测试才能发现的缺陷，例如符号执行、抽象解释、值依赖分析等等并采用数学约束求解工具进行路径约减或者可达性分析以减少误报增加效率。（摘自 <a href="https://www.jianshu.com/p/aeb15d28eb39">https://www.jianshu.com/p/aeb15d28eb39</a>）</p><p>简单来说，<strong>程序分析</strong>就是“我想在不运行一个程序的情况下，通过某种方法分析该程序就知道其是否满足某些性质”。这种“不运行程序”的状态也称为“静态”或“编译时（compile-time）”，与程序的“动态”和“运行时（run-time）”相对应），这种分析方法也被叫作<strong>静态程序分析</strong>或<strong>静态分析</strong>。（摘自 <a href="https://zhuanlan.zhihu.com/p/417187798">https://zhuanlan.zhihu.com/p/417187798</a>）</p><p>做静态程序分析必须提供一个编译器前端来将源代码转成中间代码，那为何不直接在源代码上做静态程序分析呢？原因是静态程序分析一般不是用来分析 trivial 错误的工具，而是分析 non-trivial 错误的。什么是 trivial 的错误？例如拼写错误，语法错误等一些可以被编译器前端处理的错误，non-trivial 就是一些与运行时相关的错误，例如除零错误等。（摘自  <a href="https://zhuanlan.zhihu.com/p/129361229">https://zhuanlan.zhihu.com/p/129361229</a> ）</p><h4 id="为什么要进行静态程序分析？"><a href="#为什么要进行静态程序分析？" class="headerlink" title="为什么要进行静态程序分析？"></a>为什么要进行静态程序分析？</h4><ul><li>在执行代码之前获取代码洞见；</li><li>与动态分析相比，执行速度更快；</li></ul><ul><li>可以对代码质量维护进行自动化；</li><li>在早期阶段 (尽管不是所有阶段) 可以自动检索 bug；</li></ul><ul><li>在早期阶段可以自动发现安全问题；</li><li>如果你在使用带有静态分析器的 IDE(例如遵循 PEP8 的 Pycharm)，那你已经在“船”上了。</li></ul><p>（摘自 <a href="https://www.infoq.cn/article/W0dQwY4dWzXyIxBaxl5D">https://www.infoq.cn/article/W0dQwY4dWzXyIxBaxl5D</a>）</p><h2 id="三、编译原理回顾"><a href="#三、编译原理回顾" class="headerlink" title="三、编译原理回顾"></a>三、编译原理回顾</h2><p><img src="static/practices/antlr_03.png" alt="antlr_03"></p><p>（图源龙书第二版）</p><p><img src="static/practices/antlr_04.png" alt="antlr_04"></p><p>（图源自 <a href="https://pascal-group.bitbucket.io/teaching.html">https://pascal-group.bitbucket.io/teaching.html</a> IR.pdf）</p><h2 id="四、AST"><a href="#四、AST" class="headerlink" title="四、AST"></a>四、AST</h2><p><strong>抽象语法树</strong>（abstract syntax code，AST）<strong>是源代码的抽象语法结构的树状表示</strong>，树上的每个节点都表示源代码中的一种结构，之所以说是抽象的，<strong>抽象表示把代码进行了结构化的转化</strong>，转化为一种数据结构。这种数据结构其实就是一个大的 json 对象，就像一颗枝繁叶茂的树。简单理解，就是把我们写的代码按照一定的规则转换成一种树形结构。</p><p><strong>抽象语法树</strong>是程序源代码结构的树状表示。程序源代码经过词法分析器（Lexer）得到各种不同种类的单词（Token），再由语法分析器（Parser）分析和语法检查后得到抽象语法树(AST)。抽象语法树的根节点表示整个程序，内部节点是抽象语法结构或者单词。AST的核心在于它能与输入源代码中的各个语法元素一一对应。</p><h2 id="五、Grammar-Lexicon"><a href="#五、Grammar-Lexicon" class="headerlink" title="五、Grammar Lexicon"></a>五、Grammar Lexicon</h2><p>grammar lexicon 包括 lexer 和 parser 两部分。</p><p>Antlr 官方提供许多已经写好的 grammar lexicon，见 <a href="https://github.com/antlr/grammars-v4">https://github.com/antlr/grammars-v4</a>。</p><p>语法解析器是传统解析器重要组件，语法解析器工作流程包括词法分析和语法分析两个阶段。</p><h3 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h3><p>定义：lexer 主要负责将符号文本分组成符号类tokens，把输入的文本转换成词法符号的程序称为词法分析器(lexer)。词法单元和词法规则通常以大写字母命名。</p><p>举例：节选自 <code>CPP14Lexer.g4</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IntegerLiteral:</span><br><span class="line">DecimalLiteral Integersuffix?</span><br><span class="line">| OctalLiteral Integersuffix?</span><br><span class="line">| HexadecimalLiteral Integersuffix?</span><br><span class="line">| BinaryLiteral Integersuffix?;</span><br><span class="line"></span><br><span class="line">CharacterLiteral:</span><br><span class="line">(&#x27;u&#x27; | &#x27;U&#x27; | &#x27;L&#x27;)? &#x27;\&#x27;&#x27; Cchar+ &#x27;\&#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">FloatingLiteral:</span><br><span class="line">Fractionalconstant Exponentpart? Floatingsuffix?</span><br><span class="line">| Digitsequence Exponentpart Floatingsuffix?;</span><br><span class="line"></span><br><span class="line">Plus: &#x27;+&#x27;;</span><br><span class="line">Minus: &#x27;-&#x27;;</span><br><span class="line">Star: &#x27;*&#x27;;</span><br><span class="line">Div: &#x27;/&#x27;;</span><br><span class="line"></span><br><span class="line">Whitespace: [ \t]+ -&gt; skip;</span><br><span class="line">Newline: (&#x27;\r&#x27; &#x27;\n&#x27;? | &#x27;\n&#x27;) -&gt; skip;</span><br><span class="line">BlockComment: &#x27;/*&#x27; .*? &#x27;*/&#x27; -&gt; skip;</span><br><span class="line">LineComment: &#x27;//&#x27; ~ [\r\n]* -&gt; skip;</span><br></pre></td></tr></table></figure><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><p>定义：parser 的目标就是构建一个语法解析树。语法解析的输入是tokens，输出就是一颗语法解析树。解析规则以小写字母开头命名(驼峰命名法)</p><p>举例：节选自 <code>CPP14Parser.g4</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">noPointerDeclarator:</span><br><span class="line">declaratorid attributeSpecifierSeq?</span><br><span class="line">| noPointerDeclarator (</span><br><span class="line">parametersAndQualifiers</span><br><span class="line">| LeftBracket constantExpression? RightBracket attributeSpecifierSeq?</span><br><span class="line">)</span><br><span class="line">| LeftParen pointerDeclarator RightParen;</span><br><span class="line"></span><br><span class="line">parametersAndQualifiers:</span><br><span class="line">LeftParen parameterDeclarationClause? RightParen cvqualifierseq? refqualifier?</span><br><span class="line">exceptionSpecification? attributeSpecifierSeq?;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="static/practices/antlr_05.png" alt="antlr_05"></p><h3 id="Grammar-Lexcon-的用途"><a href="#Grammar-Lexcon-的用途" class="headerlink" title="Grammar Lexcon 的用途"></a>Grammar Lexcon 的用途</h3><p>Antlr 通过 grammar lexicon 生成可个性化定制的 Java 代码文件。</p><p><img src="static/practices/antlr_06.png" alt="antlr_06"></p><p>（图源自《Antlr权威指南》59页）</p><p>grammar lexicon 中的每一个不被 skip 的 rule 都会被 Antlr 转换为一个节点。</p><h4 id="AST-中节点在代码文件中的表现形式举例"><a href="#AST-中节点在代码文件中的表现形式举例" class="headerlink" title="AST 中节点在代码文件中的表现形式举例"></a>AST 中节点在代码文件中的表现形式举例</h4><p>例一：以上图中的 ArrayInit.g4 为例，在 <code>ArrayInitBaseListener.java</code>  和 <code>ArrayInitBaseVisitor.java</code>文件中，parser rule <code>init</code> 和 <code>value</code>，以及 lexer rule <code>INT</code> 会生成响应的节点监听或节点访问方法。</p><p>例二：以 C++14 中的 <code>noPointerDeclarator</code> 节点为例（访问模式）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">visitNoPointerDeclarator</span><span class="params">(CPP14Parser.NoPointerDeclaratorContext ctx)</span> &#123;</span><br><span class="line">  <span class="comment">// 注：下列注释是 CPP14Parser.g4 文件中定义的 parser rule 生成的节点。</span></span><br><span class="line">  <span class="comment">// noPointerDeclarator:</span></span><br><span class="line">  <span class="comment">//     declaratorid attributeSpecifierSeq?</span></span><br><span class="line">  <span class="comment">//     | noPointerDeclarator (</span></span><br><span class="line">  <span class="comment">//         parametersAndQualifiers</span></span><br><span class="line">  <span class="comment">//         | LeftBracket constantExpression? RightBracket attributeSpecifierSeq?</span></span><br><span class="line">  <span class="comment">//     )</span></span><br><span class="line">  <span class="comment">//     | LeftParen pointerDeclarator RightParen;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">noPointerDeclaratorString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// 注：这是 noPointerDeclarator 节点的子节点的第一种情况，问号表示该节点存在一次或者两次。</span></span><br><span class="line">  <span class="comment">// case 1: declaratorid attributeSpecifierSeq?</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.declaratorid() != <span class="literal">null</span>) &#123;</span><br><span class="line">    noPointerDeclaratorString += visit(ctx.declaratorid());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注：这是 noPointerDeclarator 节点的子节点的第三种情况。之所以把这种情况提前，是因为第二种情况比较复杂。</span></span><br><span class="line">  <span class="comment">// case 3: LeftParen pointerDeclarator RightParen</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ctx.pointerDeclarator() != <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注：这是 noPointerDeclarator 节点的子节点的第二种情况。这种情况下，noPointerDeclarator 作为子节点是一定存在的，而其余的节点可能存在，也可能不存在，所以就接着分情况继续讨论。</span></span><br><span class="line">  <span class="comment">// case 2: noPointerDeclarator</span></span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">//  ctx.noPointerDeclarator() != null            </span></span><br><span class="line">    <span class="comment">// case 2.1: noPointerDeclarator parametersAndQualifiers</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.parametersAndQualifiers() != <span class="literal">null</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// parameters and their qualifiers</span></span><br><span class="line">      noPointerDeclaratorString += visit(ctx.parametersAndQualifiers());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// case 2.2: noPointerDeclarator LeftBracket constantExpression? RightBracket attributeSpecifierSeq?</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ctx.LeftBracket() != <span class="literal">null</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      noPointerDeclaratorString += visit(ctx.noPointerDeclarator());  <span class="comment">// return the name of param/field/variable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// case 2.0: noPointerDeclarator</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      noPointerDeclaratorString += visitChildren(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> noPointerDeclaratorString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用规则"><a href="#通用规则" class="headerlink" title="通用规则"></a>通用规则</h3><ul><li>grammar 名称和文件名要一致</li><li>Parser 规则（即 non-terminal）以小写字母开始</li></ul><ul><li>Lexer 规则（即 terminal）以大写字母开始</li><li>所有的 Lexer 规则无论写在哪里都会被重排到 Parser 规则之后</li></ul><ul><li>所有规则中若有冲突，先出现的规则优先匹配</li><li>用 ‘string’ 单引号引出字符串</li></ul><ul><li>| 用于分隔两个产生式，(a|b) 括号用于指定子产生式，?+*用法同正则表达式</li><li>在产生式后面 # label 可以给某条产生式命名，在生成的代码中即可根据标签分辨不同产生式</li></ul><ul><li>不需要指定开始符号</li><li>规则以分号终结</li></ul><ul><li>/<em> block comment </em>/ 以及 // line comment</li><li>默认的左结合，可以用 <assoc=right> 指定右结合</li></ul><ul><li>可以处理直接的左递归，不能处理间接的左递归</li><li>如果用 MUL: ‘*’; 指定了某个字符串的名字，在程序里面就能用这个名字了</li></ul><ul><li>用 fragment 可以给 Lexer 规则中的公共部分命名</li></ul><h2 id="六、遍历模式"><a href="#六、遍历模式" class="headerlink" title="六、遍历模式"></a>六、遍历模式</h2><h3 id="listener-模式"><a href="#listener-模式" class="headerlink" title="listener 模式"></a>listener 模式</h3><p><img src="static/practices/antlr_07.png" alt="antlr_07"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以节点 noPointerDeclarator 为例的 Listener 模式</span></span><br><span class="line"><span class="comment"> * 如果 AST 中存在 noPointerDeclarator，那么 Listener 首先会自动触发 enter 函数，继而遍历其子树，遍历 * 完毕后再执行 exit 函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterNoPointerDeclarator</span><span class="params">(CPP14Parser.NoPointerDeclaratorContext ctx)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitNoPointerDeclarator</span><span class="params">(CPP14Parser.NoPointerDeclaratorContext ctx)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="visitor-模式"><a href="#visitor-模式" class="headerlink" title="visitor 模式"></a>visitor 模式</h3><p><img src="static/practices/antlr_08.png" alt="antlr_08"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 以节点 NoPointerDeclarator 为例的 Visitor 模式 </span></span><br><span class="line"><span class="comment"> * 该方法被其父节点调用时才会执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitNoPointerDeclarator</span><span class="params">(CPP14Parser.NoPointerDeclaratorContext ctx)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> visitChildren(ctx); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两种模式的区别"><a href="#两种模式的区别" class="headerlink" title="两种模式的区别"></a>两种模式的区别</h3><ul><li>Listener 模式会由 ANTLR 提供的 walker 对象自动调用，每一个节点都会被遍历到，对于非叶子节点会有两个函数，分别是 enter 和 exist；而 Visitor 模式则必须通过显式的访问调用遍历其子节点，如果忘记在节点的子节点上调用 visit()，意味着这些子树不会被访问；</li><li>Listener 模式不能返回值，其返回节点为 void；而 Visitor 模式可以返回任何自定义类型，其抽象类的返回值为 T，子类可以通过继承自定义返回值。 因此，Listener模式就只能用一些变量来存储中间值，而 Visitor 可以直接返回计算值；</li></ul><ul><li>Listener 模式使用分配在堆上的显式堆栈，而 Visitor 模式使用调用堆栈来管理树遍历，在深度嵌套的 AST 上使用访客时，这可能会导致 StackOverFlow 异常。（不是很确定，因为我目前接触到的 AST 最高不过百层）</li></ul><h2 id="七、Antlr-的应用"><a href="#七、Antlr-的应用" class="headerlink" title="七、Antlr 的应用"></a>七、Antlr 的应用</h2><h3 id="Presto"><a href="#Presto" class="headerlink" title="Presto"></a>Presto</h3><p><strong>查询引擎 presto 就是用的 antlr 做底层 sql 语法解析。</strong></p><p>对于SQL语言，ANTLR的应用广度和深度会更大，这是由于Hive, Presto, SparkSQL等由于需要对SQL的执行进行定制化开发，比如实现分布式查询引擎、实现各种大数据场景下独有的特性等。（摘自 <a href="https://segmentfault.com/a/1190000040490309?sort=newest">https://segmentfault.com/a/1190000040490309?sort=newest</a>）</p><h3 id="CheckStyle"><a href="#CheckStyle" class="headerlink" title="CheckStyle"></a>CheckStyle</h3><p><strong>在构建特定语言的 AST 方面，CheckStyle 工具，就是基于 Antlr 来解析 Java 的语法结构的。</strong></p><p>（源代码见 <a href="https://github.com/checkstyle/checkstyle">https://github.com/checkstyle/checkstyle</a> ）</p><p><strong>CheckStyle</strong> 能够帮助程序员检查代码是否符合制定的规范。通过将 CheckStyle 的检查引入到项目构建中，可以强制让项目中的所有的开发者遵循制定规范，而不是仅仅停留在纸面上。如果发现代码违反了标准，比如类名未以大写开头、单个方法超过了指定行数、甚至单个方法抛出了 3 个以上的异常等。这些检查由于是基于源码的，所以不需要编译，执行速度快。（<a href="https://www.cnblogs.com/huang0925/p/3148389.html">https://www.cnblogs.com/huang0925/p/3148389.html</a>）</p><p>CheckStyle是SourceForge下的一个项目，提供了一个帮助JAVA开发人员遵守某些编码规范的工具。它能够自动化代码规范检查过程，从而使得开发人员从这项重要，但是枯燥的任务中解脱出来。（<a href="https://baike.baidu.com/item/Checkstyle/10774012">https://baike.baidu.com/item/Checkstyle/10774012</a>）</p><h4 id="CheckStyle-的工作过程"><a href="#CheckStyle-的工作过程" class="headerlink" title="CheckStyle 的工作过程"></a>CheckStyle 的工作过程</h4><p>CheckStyle基于antlr对源码进行处理</p><ul><li>antlr对AST解析</li><li>使用Visitor模式</li></ul><p>CheckStyle will use ANTLR to parse your <strong>code</strong> into a <strong>AST</strong>(Abstract Syntax Tree) and visit it in a <strong>DFS</strong>(Depth First Search) pattern to check violations. （from <a href="https://se-education.org/learningresources/contents/staticAnalysis/checkStyle.html">https://se-education.org/learningresources/contents/staticAnalysis/checkStyle.html</a>）</p><h3 id="Xtent"><a href="#Xtent" class="headerlink" title="Xtent"></a>Xtent</h3><p><strong>还有就是广泛应用在**</strong>领域专用语言(DSL)<strong>**构建上，著名的 Eclipse Xtext 就有使用 Antlr。</strong></p><p><strong>Xtend</strong> is a flexible and expressive dialect of Java, which compiles into readable Java 8 compatible source code. You can use any existing Java library seamlessly. The compiled output is readable and pretty-printed, and tends to run as fast as the equivalent handwritten Java code. (from <a href="http://www.eclipse.org/xtend/">http://www.eclipse.org/xtend/</a>)</p><p>Xtent 构建 DSL 15 分钟教程：<a href="http://www.eclipse.org/Xtext/documentation/102_domainmodelwalkthrough.html">http://www.eclipse.org/Xtext/documentation/102_domainmodelwalkthrough.html</a></p><h2 id="八、其它工具"><a href="#八、其它工具" class="headerlink" title="八、其它工具"></a>八、其它工具</h2><h4 id="程序分析的经典工具"><a href="#程序分析的经典工具" class="headerlink" title="程序分析的经典工具"></a>程序分析的经典工具</h4><p>CDT</p><p>Soot</p><p>Wala</p><p><a href="https://www.infoq.cn/article/W0dQwY4dWzXyIxBaxl5D">https://www.infoq.cn/article/W0dQwY4dWzXyIxBaxl5D</a></p><h2 id="九、拓展"><a href="#九、拓展" class="headerlink" title="九、拓展"></a>九、拓展</h2><h3 id="中间表示-intermediate-representation-IR"><a href="#中间表示-intermediate-representation-IR" class="headerlink" title="中间表示 intermediate representation, IR"></a>中间表示 intermediate representation, IR</h3><p>(来源 <a href="https://blog.csdn.net/csdnnews/article/details/105592032">https://blog.csdn.net/csdnnews/article/details/105592032</a>)</p><p>IR 是编译系统或程序静态分析系统的核心，它是源程序在编译器或者静态分析器的内部表示，所有的代码分析，优化和转换工作都是基于中间表示进行的。IR 一般由 AST 经过类型检查和规范化后转换而来。对编译器来说，它在中间表示上做完分析和优化工作后，将中间表示转换为其他语言源代码或者汇编/目标语言。</p><p>而静态分析工具则会在中间表示上进行语义或未定义的行为分析，然后结合各种预定义规则或者用户自定义规则检测源代码的各种漏洞或缺陷。</p><p>在现代编译器和静态分析工具中，通常会使用<strong>控制流图</strong>（Control Flow Graph，CFG）来表示程序的控制流，使用<strong>静态单赋值</strong>（Static Single Assignment，SSA）来表示程序中数据的<strong>使用-定义链</strong>（Use-Def Chain），这两个关键数据结构都是 AST 中没有的。</p><p><img src="static/practices/antlr_10.png" alt="img_10">      </p><p>通常AST都是输入语言相关的，比如C程序有对应的 CAST，Java程序有对应的Java AST；而IR一般来说是输入语言无关的。</p><p>SSA：每一个被赋值的变量的名字都不一样。SSA 每一次赋值行为赋予一个新的变量名，且在这个程序的整个生命周期内的任一变量仅有唯一的定义。</p><hr><h3 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h3><ul><li>不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR)</li><li>如果需要支持一种新的编程语言，那么只需要实现一个新的前端</li></ul><ul><li>如果需要支持一种新的硬件设备，那么只需要实现一个新的后端</li><li>优化阶段是一个通用的阶段，它针对的是统一的 LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改</li></ul><ul><li>相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就 变得特别困难</li><li>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族、Java、.NET、Python、Ruby、Scheme、Haskell、D等)</li></ul><p>LLVM IR有3种表示形式（本质是等价的）</p><ul><li>text:便于阅读的文本格式，类似于汇编语言，拓展名.ll， $ clang -S -emit-llvm main.m</li><li>memory:内存格式</li></ul><ul><li>bitcode:二进制格式，拓展名.bc， $ clang -c -emit-llvm main.m</li></ul><p>Clang 与 LLVM 关系：Clang 是 LLVM 项目的一个子项目，基于 LLVM 架构的 C/C++/Objective-C 编译器前端。</p><p><img src="static/practices/antlr_11.png" alt="img_11"><br>作者：呆呆滴木木菇凉<br>链接：<a href="https://www.jianshu.com/p/1367dad95445">https://www.jianshu.com/p/1367dad95445</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><h3 id="数据流图-data-flow-graph-DFG"><a href="#数据流图-data-flow-graph-DFG" class="headerlink" title="数据流图 data flow graph, DFG"></a>数据流图 data flow graph, DFG</h3><h3 id="控制流图-control-flow-graph-CFG"><a href="#控制流图-control-flow-graph-CFG" class="headerlink" title="控制流图 control flow graph, CFG"></a>控制流图 control flow graph, CFG</h3><h3 id="静态值流，static-value-flow-SVF"><a href="#静态值流，static-value-flow-SVF" class="headerlink" title="静态值流，static value flow, SVF"></a>静态值流，static value flow, SVF</h3><hr><h3 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h3><p>（见<a href="https://bbs.huaweicloud.com/blogs/detail/229334#:~:text=%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E5%B0%B1%E6%98%AF%E5%9F%BA%E4%BA%8E,%E9%A2%98%E6%98%AF%E4%B8%8D%E5%8F%AF%E6%BB%A1%E8%B6%B3%E7%9A%84%E3%80%82"> 静态代码分析之约束求解简介</a>）</p><p>约束求解和抽象解释，是程序分析的两大基石。一般程序分析问题通常都需要转换为各种数学模型，例如<strong>图可达性问题</strong>、<strong>约束求解问题</strong>（通常在符号执行、路径敏感分析等场景使用）等，然后进行特定的求解来发现程序中存在的问题。</p><h4 id="1-约束求解问题"><a href="#1-约束求解问题" class="headerlink" title="1. 约束求解问题"></a>1. 约束求解问题</h4><p>约束求解问题，可以形式化表示为一个三元组的形式 P=<V, D, C>，其中的三个部分，含义分别为：</p><p>V：变量的集合，表示为{v1, v2, …, vn}；</p><p>D：变量的值域的集合，即每个变量的取值范围，即变量vi需要在其值域di内取值；</p><p>C：约束条件的集合，每个约束条件包含中一个或者多个变量，若ci中包含k个变量，则称该约束是这k个变量集合上的k元约束。</p><p>约束求解就是基于这一系列的约束问题，求出来一个解，这个解对所有的约束都满足，并且在自己的值域范围内，如果有这样的一个解，就说这个约束问题是可满足的，否则，就说这个约束问题是不可满足的。</p><p>当前，主流的约束求解器主要有两种理论模型：SAT求解器和SMT求解器。</p><h4 id="1-1-SAT问题求解"><a href="#1-1-SAT问题求解" class="headerlink" title="1.1 SAT问题求解"></a>1.1 SAT问题求解</h4><p>SAT问题（The Satisfiability Problem，可满足性问题），最典型的是布尔可满足性问题，是指求解由布尔变量集合组成的布尔表达式，是否存在一组布尔变量的值，使得该布尔表达式为真。SAT问题，求解的变量的类型，只能是布尔类型，可以解决的问题为命题逻辑公式问题，为了求解SAT问题，需要将SAT问题转换为CNF形式的公式。</p><p>下面简单介绍一些在SAT求解问题中的一些关键概念。</p><ul><li><strong>布尔变量</strong>（Boolean Variable）：即取值只能为真或者假的变量，布尔变量是布尔逻辑的基础（类似于Java中boolean类型的变量）。</li><li><strong>布尔操作</strong>（Boolean Operation）：可以对布尔变量进行的操作，例如布尔与∧（类似于Java中 &amp;&amp; 操作），布尔或∨ （类似于Java中 || 操作）和布尔非 ¬（类似于Java中变量前的 ! 操作）；</li></ul><ul><li><strong>布尔表达式</strong>（Boolean Expression）：通过布尔运算符将布尔变量连接起来的表达式。如针对布尔变量a和b的布尔表达式可以是 a∧b（类似于Java中 a &amp;&amp; b 操作），a∨b（类似于Java中 a || b 操作），¬a（类似于Java中 !a 操作），我们通过对这些简单的表达式不断进行或且非操作就可以变成很复杂的表达式，例如 (¬a∨b)∧(a∨¬b)（类似于Java中 (!a || b) &amp;&amp; (a || !b)）。</li><li><strong>析取</strong>(Disjunctive)：即布尔或操作。仅由布尔或运算符连接而成的布尔表达式为<strong>析取子句</strong> (Disjunctive clause)。</li></ul><ul><li><strong>合取</strong>(Conjunctive) 即布尔与操作。仅有与运算符连接而成的布尔表达式为<strong>合取子句</strong> (Conjunctive clause)。</li></ul><p>对上面的概念介绍完成后，我们可以给出CNF的概念。</p><p><strong>合取范式</strong>(Conjunctive Normal Form)，合取范式，是命题逻辑公式的标准形式，它由一系列 析取子句 用 合取操作 连接而来。与之相反，<strong>析取范式**</strong> **(Disjunctive Normal Form) 是命题公式的另一个标准型，它由一系列 合取子句 用 析取操作 连接而来。</p><p>如下：</p><p>a∧(¬a∨b)∧(a∨¬b)：即为一个合取范式，最外层所有的连接都是合取操作；</p><p>a∨(¬a∧b)∨(a∧¬b)：即为一个析取范式，最外层所有的连接都是析取操作。</p><p>在传统的SAT求解器中，都需要提供一个CNF文件描述命题逻辑，扩展名是dimacs，然后将所有的变量和约束都定义到CNF文件中。不过以静态代码分析来说，我们不大需要用到这种方式进行计算求解，因为这种方式需要首先定义一种格式良好的文件，使用方式并不是很友好，而且当前的一些更优的SMT求解器，并不需要生成这样的文件也可以求解SAT问题，例如Z3求解器，在后面会举例介绍如何使用Z3求解器求解SAT问题。</p><h4 id="1-2-SMT问题求解"><a href="#1-2-SMT问题求解" class="headerlink" title="1.2 SMT问题求解"></a>1.2 SMT问题求解</h4><p>如上面的分析，SAT求解器只能解决命题逻辑公式问题，而当前有很多实际应用的问题，并不能直接转换为SAT问题来进行求解。因此后来提出来SMT理论。</p><p>SMT（Satisfiability Module Theories， 可满足性模理论），是在SAT问题的基础上扩展而来的，SMT求解器的求解范围从命题逻辑公式扩展为可以解决一阶逻辑所表达的公式。SMT包含很多的求解方法，通过组合这些方法，可以解决很多问题。</p><p>当前，已经有大量的SMT求解器，例如微软研究院研发的Z3求解器、麻省理工学院研发的STP求解器等，并且SMT包含很多理论，例如Z3求解器就支持空理论、线性计算、非线性计算、位向量、数组等理论。在维基百科可满足性模理论（<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories）概念介绍部分，也列出了很多SMT求解器，并给出了支持的操作系统、支持的求解理论、支持的API等。">https://en.wikipedia.org/wiki/Satisfiability_modulo_theories）概念介绍部分，也列出了很多SMT求解器，并给出了支持的操作系统、支持的求解理论、支持的API等。</a></p><h3 id="Z3求解器"><a href="#Z3求解器" class="headerlink" title="Z3求解器"></a>Z3求解器</h3><p><a href="https://github.com/Z3Prover/z3">https://github.com/Z3Prover/z3</a></p><hr><h4 id="CG、CFG、ICFG"><a href="#CG、CFG、ICFG" class="headerlink" title="CG、CFG、ICFG"></a>CG、CFG、ICFG</h4><p>(from <a href="https://www.zhihu.com/question/267555156/answer/326573874">https://www.zhihu.com/question/267555156/answer/326573874</a>)</p><p>CG（call graph）和CFG（control-flow graph）都是表示程序控制流的有向图，但它们并没有包含的关系。</p><p>一个<strong>CG</strong>是表示整个程序中方法（函数）之间调用关系的图，图中的节点是方法，边表示调用关系。例如方法foo()调用了方法bar()，则CG中应有一条从foo()到bar()的有向边。</p><p>一个<strong>CFG</strong>是表示一个方法内的程序执行流的图，图中的节点是语句（指令），边表示执行流。例如语句A执行后的下一条语句是B，则CFG中应有一条从A到B的有向边。条件语句（if-else, while-do）之后可能执行的语句不止一个，可能执行true-branch或false-branch，所以CFG上条件语句节点的后缀会有多个，表示其后可能执行的不同branches。</p><p>还有<strong>ICFG</strong>（interprocedural control-flow graph），它的信息就是CG加上CFG的信息。ICFG可以看做是给所有方法的CFG加上这些方法之间互相调用的边（CG）所形成的图。调用边（call edge）从调用语句（call site）连到被调方法（callee）的入口。与CG不同的是，ICFG除了调用边，还包含相应的返回边（return edge），从callee的出口连到call site之后执行的下一个语句。</p><hr><h3 id="抽象解释"><a href="#抽象解释" class="headerlink" title="抽象解释"></a>抽象解释</h3><hr><h3 id="XXX-sensitive-分析"><a href="#XXX-sensitive-分析" class="headerlink" title="XXX-sensitive 分析"></a>XXX-sensitive 分析</h3><p>通常所说的<strong>xxx-sensitive</strong>是指静态分析中用于降低误报（false positive）的技术，最常提的xxx正是题主所说的path, context以及flow。</p><p>xxx-sensitive就是在静态分析时，按照xxx给程序里的对象（模拟动态运行）创建“分身”（或者说按照xxx区分分析对象）：按照<strong>上下文</strong>区分叫做context-sensitive；按照<strong>位置</strong>区分叫做flow-sensitive；按照<strong>路径</strong>区分叫做path-sensitive。区分之后再分析可以减少false positive。但是静态不可能完全模拟动态的所有情况，因为一旦有递归和循环，理论上你写下的方法和变量就能产生无穷无尽的“分身”。所以静态分析只能或多或少地通过xxx-sensitive技术减少false positive，而不可能消除。<br>作者：甜品专家<br>链接：<a href="https://www.zhihu.com/question/35167483/answer/62199381">https://www.zhihu.com/question/35167483/answer/62199381</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><blockquote><p>创建于 2022-11-15</p><p>更新于 2022-11-15</p></blockquote>]]></content>
    
    
    <summary type="html">本文详细介绍了 Antlr 及其使用方式。</summary>
    
    
    
    <category term="技术" scheme="https://luorongluorong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="程序分析" scheme="https://luorongluorong.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    <category term="静态分析" scheme="https://luorongluorong.github.io/tags/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Antlr" scheme="https://luorongluorong.github.io/tags/Antlr/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读论文？</title>
    <link href="https://luorongluorong.github.io/2021/11/11/papers/how_to_read_paper/"/>
    <id>https://luorongluorong.github.io/2021/11/11/papers/how_to_read_paper/</id>
    <published>2021-11-11T02:29:54.000Z</published>
    <updated>2023-02-17T02:18:11.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何阅读论文？"><a href="#如何阅读论文？" class="headerlink" title="如何阅读论文？"></a>如何阅读论文？</h1><blockquote><p>2022 年 11 月 11 日</p></blockquote><p>You may find it useful to ask yourself the following questions as you read the paper, or after you read the paper.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">What problem is the paper addressing? How well do they succeed in solving the problem?</span><br><span class="line">What is the contribution of the paper? How important is this contribution?</span><br><span class="line">How would you have addressed the problem?</span><br><span class="line">What was unclear to you?</span><br><span class="line">How does the paper relate to other papers we have read?</span><br><span class="line">Are there any obvious or non-obvious extensions to this work?</span><br><span class="line">Can you suggest a two-sentence project idea based on the ideas of this paper?</span><br><span class="line">—— from https://groups.seas.harvard.edu/courses/cs252/2015fa/reading_paper.html</span><br></pre></td></tr></table></figure><h1 id="大佬的建议"><a href="#大佬的建议" class="headerlink" title="大佬的建议"></a>大佬的建议</h1><blockquote><p>from <a href="http://www.eecs.harvard.edu/~michaelm/postscripts/ReadPaper.pdf">http://www.eecs.harvard.edu/~michaelm/postscripts/ReadPaper.pdf</a></p></blockquote><ul><li><p>批判性阅读</p><ul><li>作者要解决的问题是对的吗？是合适的吗？</li><li>作者是否忽视了更简单的解决问题的方法？</li><li>该方法的局限在哪？作者有没有承认？</li><li>作者的假设真的是合理的吗？</li><li>论文的逻辑清晰吗？合法吗？通过假设能推理出结果吗？有逻辑漏洞吗？</li><li>数据准确吗？收集数据的方式正确吗？</li><li>收集的数据证实了该文论点吗？</li><li>论文解释数据的方式合理吗？</li><li>有没有更有说服力的数据呢？</li></ul></li><li><p>创造性地阅读</p><ul><li>论文的 idea 好在哪儿？</li><li>这些 idea 有其它应用或者拓展吗？</li><li>这些 idea 可以 be generalized 吗？</li><li>是否存在可能的改善产生重大的不同？</li><li>如果你想从这篇论文着手开始研究，你接下来该开始做什么呢？</li></ul></li><li>做笔记<ul><li>标记重点内容。</li><li>记下问题和批判。</li><li>标记重要的数据或者有问题的数据。</li></ul></li><li><p>总结</p><ul><li>读完一遍后，用一两句话总结这篇文章。</li><li>第二遍阅读可以在把握大纲的基础上了解更多细节。</li><li>如果可以用简介的话表示 points，那么就可以总结三到四个重要的 subpoints</li></ul></li><li><p>将该文与其它工作进行比较</p><ul><li>总结论文是为了发现它的贡献。但总结一篇文章贡献的最好的方式还是和同领域内其它的文章进行比较。</li><li>该文的观点之前出现过吗？</li><li>不同文章的贡献呈现出不同的模式，比如观点新颖，比如实现新颖，比如组合方式新颖。</li></ul></li></ul><h2 id="Paper-Review"><a href="#Paper-Review" class="headerlink" title="Paper Review"></a>Paper Review</h2><p>论文阅读报告必须有如下内容：</p><blockquote><p>a one or two sentence summary of the paper.  </p><p>a deeper, more extensive outline of the main points of the paper, including for example assumptions<br>made, arguments presented, data analyzed, and conclusions drawn.  </p><p>any limitations or extensions you see for the ideas in the paper.  </p><p>your opinion of the paper; primarily, the quality of the ideas and its potential impact.</p></blockquote><ol><li>论文总结</li><li>论文大纲<ol><li>假设</li><li>论点</li><li>数据</li><li>结论</li></ol></li><li>局限或拓展</li><li>个人感想<ol><li>针对论文 idea 的看法</li><li>论文的潜在影响力</li></ol></li></ol>]]></content>
    
    
    <summary type="html">在阅读论文的时候，我们究竟应该如何高效阅读呢？</summary>
    
    
    
    <category term="学术" scheme="https://luorongluorong.github.io/categories/%E5%AD%A6%E6%9C%AF/"/>
    
    
    <category term="论文" scheme="https://luorongluorong.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="技巧" scheme="https://luorongluorong.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>
