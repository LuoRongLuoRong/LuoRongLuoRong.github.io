<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>TODO_十大排序算法 | LuoRongLuoRong</title><meta name="author" content="LuoRongLuoRong"><meta name="copyright" content="LuoRongLuoRong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="十大排序算法包括选择排序、冒泡排序、插入排序、快速排序、归并排序、希尔排序、堆排序、桶排序、计数排序、基数排序。">
<meta property="og:type" content="article">
<meta property="og:title" content="TODO_十大排序算法">
<meta property="og:url" content="https://luorongluorong.github.io/2023/02/16/algorithms/sort/index.html">
<meta property="og:site_name" content="LuoRongLuoRong">
<meta property="og:description" content="十大排序算法包括选择排序、冒泡排序、插入排序、快速排序、归并排序、希尔排序、堆排序、桶排序、计数排序、基数排序。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luorongluorong.github.io/static/algorithms/sort1.png">
<meta property="article:published_time" content="2023-02-16T01:59:11.000Z">
<meta property="article:modified_time" content="2023-02-17T02:31:00.406Z">
<meta property="article:author" content="LuoRongLuoRong">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="排序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luorongluorong.github.io/static/algorithms/sort1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://luorongluorong.github.io/2023/02/16/algorithms/sort/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TODO_十大排序算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-17 10:31:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LuoRongLuoRong" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/static/algorithms/sort1.png')"><nav id="nav"><span id="blog-info"><a href="/" title="LuoRongLuoRong"><span class="site-name">LuoRongLuoRong</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">TODO_十大排序算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-16T01:59:11.000Z" title="发表于 2023-02-16 09:59:11">2023-02-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-17T02:31:00.406Z" title="更新于 2023-02-17 10:31:00">2023-02-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="TODO_十大排序算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="十大排序算法"><a href="#十大排序算法" class="headerlink" title="十大排序算法"></a>十大排序算法</h1><p>选泡插：选择排序、冒泡排序、插入排序</p>
<p>快归希堆：快速排序、归并排序、希尔排序、堆排序</p>
<p>桶计基：桶排序、计数排序、基数排序</p>
<p>8种常见排序中（快排、希尔、堆排、归并、冒泡、选择、插入、基数排序）=&gt; <code>快些（希尔）选堆不稳定</code></p>
<ul>
<li>冒泡排序（Bubble Sort）</li>
<li>插入排序（Insertion Sort）</li>
<li>希尔排序（Shell Sort）</li>
<li>选择排序（Selection Sort）</li>
<li>快速排序（Quick Sort）</li>
<li>归并排序（Merge Sort）</li>
<li>堆排序（Heap Sort）</li>
<li>计数排序（Counting Sort）</li>
<li>桶排序（Bucket Sort）</li>
<li>基数排序（Radix Sort）</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="时间复杂度-O-n-2-的排序算法"><a href="#时间复杂度-O-n-2-的排序算法" class="headerlink" title="时间复杂度 O(n^2) 的排序算法"></a>时间复杂度 O(n^2) 的排序算法</h3><p>冒泡排序<br>冒泡排序有两种优化方式：</p>
<p>记录当前轮次是否发生过交换，没有发生过交换表示数组已经有序；<br>记录上次发生交换的位置，下一轮排序时只比较到此位置。<br>选择排序<br>选择排序可以演变为二元选择排序：</p>
<p>二元选择排序：一次遍历选出两个值——最大值和最小值；<br>二元选择排序剪枝优化：当某一轮遍历出现最大值和最小值相等，表示数组中剩余元素已经全部相等。<br>插入排序<br>插入排序有两种写法：</p>
<p>交换法：新数字通过不断交换找到自己合适的位置；<br>移动法：旧数字不断向后移动，直到新数字找到合适的位置。<br>相同点<br>时间复杂度都是  O(n^2) ，空间复杂度都是 O(1)。</p>
<p>都需要采用两重循环。</p>
<p>不同点<br>选择排序是不稳定的，冒泡排序、插入排序是稳定的；<br>在这三个排序算法中，选择排序交换的次数是最少的；<br>在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。</p>
<h3 id="时间复杂度-O-n-log-n-的排序算法"><a href="#时间复杂度-O-n-log-n-的排序算法" class="headerlink" title="时间复杂度 O(n log n) 的排序算法"></a>时间复杂度 O(n log n) 的排序算法</h3><p>希尔排序<br>希尔排序是一个承上启下的算法，通过交换间隔较远的元素，使得一次交换能消除一个以上的逆序对，打破了在空间复杂度为 O(1) 的情况下，时间复杂度 O(n^2) 的魔咒。它启发出了后续一系列时间复杂度为 O(nlogn)，空间复杂度为 O(1) 的排序算法。<br>希尔排序本质上是插入排序的优化，先对间隔较大的元素进行插入排序，完成宏观调控，然后逐步缩小间隔，最后一轮一定是间隔为<br>1<br>1 的排序，也就是插入排序。间隔在希尔排序中被称为「增量」，增量序列不同，希尔排序的效率也不同。<br>堆排序<br>堆排序分为两步：初始化建堆、重建堆。排序过程是：</p>
<p>用数列构建出一个大顶堆，取出堆顶的数字；<br>调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字；<br>循环往复，完成整个排序。<br>快速排序<br>快速排序算法是面试中考察的重点，也是应用最广泛的排序算法。排序过程是：</p>
<p>从数组中取出一个数，称之为基数（pivot）；<br>遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域；<br>将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。<br>快速排序中最重要的是分区算法，最常用的分区算法是双指针分区算法，优点是一次交换可以完成两个数的分区。</p>
<p>归并排序<br>归并排序分为两步：二分拆数组、不断合并两个有序列表。<br>归并的优化主要在于减少临时空间的开辟。<br>不存在空间复杂度为 O(1) 的归并排序。<br>相同点<br>平均时间复杂度都在 O(n) 到 O(n^2) 之间。<br>不同点<br>希尔排序、堆排序、快速排序是不稳定的，归并排序是稳定的。<br>希尔排序的平均复杂度界于 O(n) 到 O(n^2) 之间，普遍认为它最好的时间复杂度为 O(n^1.3)，希尔排序的空间复杂度为 O(1)；堆排序的时间复杂度为 O(nlogn)，空间复杂度为 O(1)，快速排序的平均时间复杂度为 O(nlogn)，平均空间复杂度为 O(logn)；归并排序的时间复杂度是 O(nlogn)，空间复杂度是 O(n)。</p>
<h3 id="时间复杂度-O-n-的排序算法"><a href="#时间复杂度-O-n-的排序算法" class="headerlink" title="时间复杂度 O(n) 的排序算法"></a>时间复杂度 O(n) 的排序算法</h3><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>通常来说，冒泡排序有三种写法：</p>
<ul>
<li>一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位；</li>
<li>经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序；</li>
<li>进一步优化的写法：除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始时 swapped 为 true，否则排序过程无法启动</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果没有发生过交换，说明剩余部分已经有序，排序完成</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 设置 swapped 为 false，如果发生交换，则将其置为 true</span></span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 表示发生了交换</span></span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 最后一个没有经过排序的元素的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">indexOfLastUnsortedElement</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 上次发生交换的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">swappedIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; indexOfLastUnsortedElement; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 表示发生了交换</span></span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 更新交换的位置</span></span><br><span class="line">                swappedIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置</span></span><br><span class="line">        indexOfLastUnsortedElement = swappedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序的空间复杂度为 O(1)，时间复杂度为 O(n^2)，第二种、第三种冒泡排序由于经过优化，最好的情况下只需要 O(n) 的时间复杂度。</p>
<p>但优化后的冒泡排序平均时间复杂度仍然是 O(n^2)，所以这些优化对算法的性能并没有质的提升。正如 Donald E. Knuth（1974 年图灵奖获得者）所言：“冒泡排序法除了它迷人的名字和导致了某些有趣的理论问题这一事实外，似乎没有什么值得推荐的。”</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。</p>
<p>思考一下，选择排序算法如何实现稳定排序呢？</p>
<p>实现的方式有很多种，这里给出一种最简单的思路：新开一个数组，将每轮找出的最小值依次添加到新数组中，选择排序算法就变成稳定的了。</p>
<h2 id="二元选择排序"><a href="#二元选择排序" class="headerlink" title="二元选择排序"></a>二元选择排序</h2><p>选择排序算法也是可以优化的，既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想。</p>
<p>使用二元选择排序，每轮选择时记录最小值和最大值，可以把数组需要遍历的范围缩小一倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> minIndex, maxIndex;</span><br><span class="line">    <span class="comment">// i 只需要遍历一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最大值的下标</span></span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">        <span class="comment">// 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) maxIndex = minIndex;</span><br><span class="line">        <span class="comment">// 将最大元素交换至末尾</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> arr.length - <span class="number">1</span> - i;</span><br><span class="line">        temp = arr[lastIndex];</span><br><span class="line">        arr[lastIndex] = arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的思想非常简单，生活中有一个很常见的场景：在打扑克牌时，我们一边抓牌一边给扑克牌排序，每次摸一张牌，就将它插入手上已有的牌中合适的位置，逐渐完成整个排序。</p>
<p>插入排序是稳定的。</p>
<p>插入排序有两种写法：</p>
<ul>
<li>交换法：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。</li>
<li>移动法：在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。</li>
</ul>
<p>在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span></span><br><span class="line">        <span class="comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = currentNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序本质上是对插入排序的一种优化，它利用了插入排序的简单，又克服了插入排序每次只交换相邻两个元素的缺点。它的基本思想是：</p>
<ul>
<li>将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组</li>
<li>逐渐缩小间隔进行下一轮排序</li>
<li>最后一轮时，取间隔为 1，也就相当于直接使用插入排序。但这时经过前面的「宏观调控」，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成</li>
</ul>
<p>其中，每一遍排序的间隔在希尔排序中被称之为增量，所有的增量组成的序列称之为增量序列。增量依次递减，最后一个增量必须为 1，所以希尔排序又被称之为「缩小增量排序」。要是以专业术语来描述希尔排序，可以分为以下两个步骤：</p>
<ul>
<li>定义增量序列 </li>
<li>对每个增量序列进行插入排序</li>
</ul>
<p>增量序列的选择会极大地影响希尔排序的效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 间隔序列，在希尔排序中我们称之为增量序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">groupStartIndex</span> <span class="operator">=</span> <span class="number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;</span><br><span class="line">            <span class="comment">// 插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> groupStartIndex + gap; currentIndex &lt; arr.length; currentIndex += gap) &#123;</span><br><span class="line">                <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> arr[currentIndex];</span><br><span class="line">                <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> currentIndex - gap;</span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= groupStartIndex &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                    <span class="comment">// 向后挪位置</span></span><br><span class="line">                    arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                    preIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">                arr[preIndex + gap] = currentNumber;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这段代码可以优化一下。我们现在的处理方式是：处理完一组间隔序列后，再回来处理下一组间隔序列，这非常符合人类思维。但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式。虽然这个过程看起来是在不同的间隔序列中不断跳跃，但站在计算机的角度，它是在访问一段连续数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 间隔序列，在希尔排序中我们称之为增量序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="comment">// 该组前一个数字的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                <span class="comment">// 向后挪位置</span></span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">            arr[preIndex + gap] = currentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增量元素不互质，则小增量可能根本不起作用。</p>
<p>事实上，希尔排序的增量序列如何选择是一个数学界的难题，但它也是希尔排序算法的核心优化点。数学界有不少的大牛做过这方面的研究。比较著名的有 Hibbard 增量序列、Knuth 增量序列、Sedgewick 增量序列。</p>
<p><img src="static/algorithms/sort1.png" alt="Alt text"></p>
<p>以 Knuth 增量序列为例，Knuth 就是上篇文章中吐槽冒泡算法的那个数学家 Donald E. Knuth，使用 Knuth 序列进行希尔排序的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSortByKnuth</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到当前数组需要用到的 Knuth 序列中的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxKnuthNumber</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxKnuthNumber &lt;= arr.length / <span class="number">3</span>) &#123;</span><br><span class="line">        maxKnuthNumber = maxKnuthNumber * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增量按照 Knuth 序列规则依次递减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> maxKnuthNumber; gap &gt; <span class="number">0</span>; gap = (gap - <span class="number">1</span>) / <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="comment">// 该组前一个数字的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                <span class="comment">// 向后挪位置</span></span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">            arr[preIndex + gap] = currentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先根据数组的长度，计算出需要用到的 Knuth 序列中的最大增量值，然后根据 Knuth 序列的规则依次缩小增量，从高增量到低增量分别进行排序。</p>
<p>使用 Knuth 序列的希尔排序，时间复杂度已经降到了 O(n^2) 以下。但具体时间复杂度是多少，尚未有明确的证明，数学界仅仅是猜想它的平均时间复杂度为 O(n ^ 3/2)。</p>
<p>虽然插入排序是稳定的排序算法，但<strong>希尔排序是不稳定的</strong>。在增量较大时，排序过程可能会破坏原有数组中相同关键字的相对次序。</p>
<h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><p>事实上，希尔排序时间复杂度非常难以分析，它的平均复杂度界于 O(n) 到 O(n^2) 之间，普遍认为它最好的时间复杂度为 O(n ^ 1.3)。</p>
<p>希尔排序的空间复杂度为 O(1)，只需要常数级的临时变量。</p>
<h2 id="希尔排序与-O-n-2-级排序算法的本质区别"><a href="#希尔排序与-O-n-2-级排序算法的本质区别" class="headerlink" title="希尔排序与 O(n^2) 级排序算法的本质区别"></a>希尔排序与 O(n^2) 级排序算法的本质区别</h2><p>相对于前面介绍的冒泡排序、选择排序、插入排序来说，希尔排序的排序过程显得较为复杂，希望读者还没有被绕晕。接下来我们来分析一个有趣的问题：希尔排序凭什么可以打破时间复杂度 O(n^2) 的魔咒呢？它和之前介绍的 O(n^2) 级排序算法的本质区别是什么？</p>
<p>只要理解了这一点，我们就能知道为什么希尔排序能够承上启下，启发出之后的一系列 O(n^2) 级以下的排序算法。</p>
<p>这个问题我们可以用逆序对来理解。</p>
<p>当我们从小到大排序时，在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。</p>
<p>排序算法本质上就是一个消除逆序对的过程。</p>
<p>对于随机数组，逆序对的数量是 O(n^2) 级的，如果采用「交换相邻元素」的办法来消除逆序对，每次最多只能消除一组逆序对，因此必须执行 O(n^2) 级的交换次数，这就是为什么冒泡、插入、选择算法只能到 O(n^2) 级的原因。反过来说，基于交换元素的排序算法要想突破 O(n^2) 级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。</p>
<p>希尔排序算法就是通过这种方式，打破了在空间复杂度为 O(1) 的情况下，时间复杂度为 O(n^2) 的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>数组、链表都是一维的数据结构，相对来说比较容易理解，而堆是二维的数据结构，对抽象思维的要求更高，所以许多程序员「谈堆色变」。但堆又是数据结构进阶必经的一步，我们不妨静下心来，将其梳理清楚。</p>
<p>堆：符合以下两个条件之一的完全二叉树：</p>
<ul>
<li>根节点的值 ≥ 子节点的值，这样的堆被称之为最大堆，或大顶堆；</li>
<li>根节点的值 ≤ 子节点的值，这样的堆被称之为最小堆，或小顶堆。</li>
</ul>
<p>堆排序过程如下：</p>
<ul>
<li>用数列构建出一个大顶堆，取出堆顶的数字；</li>
<li>调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字；</li>
<li><p>循环往复，完成整个排序。<br>整体的思路就是这么简单，我们需要解决的问题有两个：</p>
</li>
<li><p>如何用数列构建出一个大顶堆；</p>
</li>
<li>取出堆顶的数字后，如何将剩余的数字调整成新的大顶堆。</li>
</ul>
<h2 id="构建大顶堆-amp-调整堆"><a href="#构建大顶堆-amp-调整堆" class="headerlink" title="构建大顶堆 &amp; 调整堆"></a>构建大顶堆 &amp; 调整堆</h2><p>构建大顶堆有两种方式：</p>
<p>方案一：从 0 开始，将每个数字依次插入堆中，一边插入，一边调整堆的结构，使其满足大顶堆的要求；<br>方案二：将整个数列的初始状态视作一棵完全二叉树，自底向上调整树的结构，使其满足大顶堆的要求。<br>方案二更为常用，动图演示如下：</p>
<p><img src="static/algorithms/sort2.gif" alt="Alt text"></p>
<p><img src="static/algorithms/sort3.gif" alt="Alt text"></p>
<p>在介绍堆排序具体实现之前，我们先要了解完全二叉树的几个性质。将根节点的下标视为 0，则完全二叉树有如下性质：</p>
<p>对于完全二叉树中的第 i 个数，它的左子节点下标：left = 2i + 1<br>对于完全二叉树中的第 i 个数，它的右子节点下标：right = left + 1<br>对于有 n 个元素的完全二叉树 (n≥2)，它的最后一个非叶子结点的下标：n/2 - 1</p>
<p>堆排序代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建初始大顶堆</span></span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将最大值交换到数组最后</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, i);</span><br><span class="line">        <span class="comment">// 调整剩余数组，使其满足大顶堆</span></span><br><span class="line">        maxHeapify(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建初始大顶堆</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        maxHeapify(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 左子结点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右子结点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 记录根结点、左子树结点、右子树结点三者中的最大值下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="comment">// 与左子树结点比较</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与右子树结点比较</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="comment">// 将最大值交换为根结点</span></span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        <span class="comment">// 再次调整交换数字后的大顶堆</span></span><br><span class="line">        maxHeapify(arr, largest, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>堆排序的第一步就是构建大顶堆，对应代码中的 buildMaxHeap 函数。我们将数组视作一颗完全二叉树，从它的最后一个非叶子结点开始，调整此结点和其左右子树，使这三个数字构成一个大顶堆。</p>
<p>调整过程由 maxHeapify 函数处理， maxHeapify 函数记录了最大值的下标，根结点和其左右子树结点在经过比较之后，将最大值交换到根结点位置。这样，这三个数字就构成了一个大顶堆。</p>
<p>需要注意的是，如果根结点和左右子树结点任何一个数字发生了交换，则还需要保证调整后的子树仍然是大顶堆，所以子树会执行一个递归的调整过程。</p>
<p>当构建出大顶堆之后，就要把冠军交换到数列最后，深藏功与名。来到冠军宝座的新人又要开始向下比较，找到自己的真实位置，使得剩下的 n−1 个数字构建成新的大顶堆。这就是 heapSort 方法的 for 循环中，调用 maxHeapify 的原因。</p>
<p>变量 heapSize 用来记录还剩下多少个数字没有排序完成，每当交换了一个堆顶的数字，heapSize 就会减 1。在 maxHeapify 方法中，使用 heapSize 来限制剩下的选手，不要和已经躺在数组最后最大的值比较。</p>
<p>这就是堆排序的思想。学习时我们采用的是最简单的代码实现，在熟练掌握了之后我们就可以加一些小技巧以获得更高的效率。比如我们知道计算机采用二进制来存储数据，数字左移一位表示乘以 2<br>2，右移一位表示除以 2。所以堆排序代码中的arr.length / 2 - 1 可以修改为 (arr.length &gt;&gt; 1) - 1，左子结点下标2 * i + 1可以修改为(i &lt;&lt; 1) + 1。需要注意的是，位运算符的优先级比加减运算的优先级低，所以必须给位运算过程加上括号。</p>
<blockquote>
<p>注：在有的文章中，作者将堆的根节点下标视为 1，这样做的好处是使得第 i 个结点的左子结点下标为 2i，右子结点下标为 2i + 1，与 2i + 1 和 2i + 2 相比，计算量会少一点，本文未采取这种实现，但两种实现思路的核心思想都是一致的。</p>
</blockquote>
<p>分析可知，堆排序是不稳定的排序算法。</p>
<p>时间复杂度 &amp; 空间复杂度<br>堆排序分为两个阶段：初始化建堆（buildMaxHeap）和重建堆（maxHeapify，直译为大顶堆化）。所以时间复杂度要从这两个方面分析。</p>
<p>根据数学运算可以推导出初始化建堆的时间复杂度为 O(n)，重建堆的时间复杂度为 O(nlogn) ，所以堆排序总的时间复杂度为 O(nlogn) 。推导过程较为复杂，故不再给出证明过程。</p>
<p>堆排序的空间复杂度为 O(1)，只需要常数级的临时变量。</p>
<p>堆排序是一个优秀的排序算法，但是在实际应用中，快速排序的性能一般会优于堆排序，我们将在下一节介绍快速排序的思想。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序算法由 C. A. R. Hoare 在 1960 年提出。它的时间复杂度也是 O(nlogn) ，但它在时间复杂度为 O(nlogn)  级的几种排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。</p>
<p>快速排序算法的基本思想是：</p>
<ul>
<li>从数组中取出一个数，称之为基数（pivot）</li>
<li>遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域</li>
<li>将左右两个区域视为两个数组，重复前两个步骤，直到排序完成<br>事实上，快速排序的每一次遍历，都将基数摆到了最终位置上。第一轮遍历排好 1 个基数，第二轮遍历排好 2 个基数（每个区域一个基数，但如果某个区域为空，则此轮只能排好一个基数），第三轮遍历排好 4 个基数（同理，最差的情况下，只能排好一个基数），以此类推。总遍历次数为 logn～n 次，每轮遍历的时间复杂度为 O(n)，所以很容易分析出快速排序的时间复杂度为 O(nlogn)  ～ O(n ^ 2)，平均时间复杂度为 O(nlogn) 。</li>
</ul>
<p>根据我们分析出的思路，先搭出快速排序的架子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>partition 意为“划分”，我们期望 partition 函数做的事情是：将 arr 从 start 到 end 这一区间的值分成两个区域，左边区域的每个数都比基数小，右边区域的每个数都比基数大，然后返回中间值的下标。</p>
<p>只要有了这个函数，我们就能写出快速排序的递归函数框架。首先调用 partition 函数得到中间值的下标 middle，然后对左边区域执行快速排序，也就是递归调用 quickSort(arr, start, middle - 1)，再对右边区域执行快速排序，也就是递归调用 quickSort(arr, middle + 1, end)。</p>
<p>现在还有一个问题，何时退出这个递归函数呢？</p>
<p>很容易想到，当某个区域只剩下一个数字的时候，自然不需要排序了，此时退出递归函数。实际上还有一种情况，就是某个区域只剩下 0 个数字时，也需要退出递归函数。当 middle 等于 start 或者 end 时，就会出现某个区域剩余数字为 0。</p>
<p>所以我们可以通过这种方式退出递归函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 当左边区域中至少有 2 个数字时，对左边区域快速排序</span></span><br><span class="line">    <span class="keyword">if</span> (start != middle &amp;&amp; start != middle - <span class="number">1</span>) quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 当右边区域中至少有 2 个数字时，对右边区域快速排序</span></span><br><span class="line">    <span class="keyword">if</span> (middle != end &amp;&amp; middle != end - <span class="number">1</span>) quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在递归之前，先判断此区域剩余数字是否为 0 个或者 1 个，当数字至少为 2 个时，才执行这个区域的快速排序。因为我们知道 middle &gt;= start &amp;&amp; middle &lt;= end 必然成立，所以判断剩余区域的数字为 0 个或者 1 个也就是指 start 或 end 与 middle 相等或相差 1。</p>
<p>我们来分析一下这四个判断条件：</p>
<p>当 start == middle 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end + 1<br>当 start == middle - 1 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end<br>当 middle == end 时，相当于 quickSort(arr, middle + 1, end) 中的 start == end + 1<br>当 middle == end -1 时，相当于 quickSort(arr, middle + 1, end) 中的 start == end</p>
<p>综上，我们可以将此边界条件统一移到 quickSort 函数之前：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果区域内的数字少于 2 个，退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (start == end || start == end + <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>更进一步，由上文所说的 middle &gt;= start &amp;&amp; middle &lt;= end 可以推出，除了start == end || start == end + 1这两个条件之外，其他的情况下 start 都小于 end。所以我们可以将这个判断条件再次简写为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果区域内的数字少于 2 个，退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样我们就写出了最简洁版的边界条件，我们需要知道，这里的 start &gt;= end 实际上只有两种情况：</p>
<p>start == end: 表明区域内只有一个数字<br>start == end + 1: 表明区域内一个数字也没有</p>
<p>不会存在 start 比 end 大 2 或者大 3 之类的。</p>
<h2 id="分区算法实现"><a href="#分区算法实现" class="headerlink" title="分区算法实现"></a>分区算法实现</h2><p>快速排序中最重要的便是分区算法，也就是 partition 函数。大多数人都能说出快速排序的整体思路，但实现起来却很难一次写对。主要问题就在于分区时存在的各种边界条件，需要读者亲自动手实践才能加深体会。</p>
<p>上文已经说到，partition 函数需要做的事情就是将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标。那么首先我们要做的事情就是选择一个基数，基数我们一般称之为 pivot，意为“轴”。整个数组就像围绕这个轴进行旋转，小于轴的数字旋转到左边，大于轴的数字旋转到右边。（所谓的双轴快排就是一次选取两个基数，将数组分为三个区域进行旋转，关于双轴快排的内容我们将在后续章节讲解。）</p>
<p>基数的选择<br>基数的选择没有固定标准，随意选择区间内任何一个数字做基数都可以。通常来讲有三种选择方式：</p>
<p>选择第一个元素作为基数<br>选择最后一个元素作为基数<br>选择区间内一个随机元素作为基数</p>
<p>选择的基数不同，算法的实现也不同。实际上第三种选择方式的平均时间复杂度是最优的，待会分析时间复杂度时我们会详细说明。</p>
<p>本文通过第一种方式来讲解快速排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 取第一个数为基数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[start];</span><br><span class="line">    <span class="comment">// 从第二个数开始分区</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最简单的分区算法"><a href="#最简单的分区算法" class="headerlink" title="最简单的分区算法"></a>最简单的分区算法</h3><p>分区的方式也有很多种，最简单的思路是：从 left 开始，遇到比基数大的数，就交换到数组最后，并将 right 减一，直到 left 和 right 相遇，此时数组就被分成了左右两个区域。再将基数和中间的数交换，返回中间值的下标即可。</p>
<p>按照这个思路，我们敲出了如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果区域内的数字少于 2 个，退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 取第一个数为基数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[start];</span><br><span class="line">    <span class="comment">// 从第二个数开始分区</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="comment">// left、right 相遇时退出循环</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于基数的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;</span><br><span class="line">        <span class="comment">// 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数</span></span><br><span class="line">        <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">            exchange(arr, left, right);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span></span><br><span class="line">    <span class="keyword">if</span> (left == right &amp;&amp; arr[right] &gt; pivot) right--;</span><br><span class="line">    <span class="comment">// 将基数和中间数交换</span></span><br><span class="line">    <span class="keyword">if</span> (right != start) exchange(arr, start, right);</span><br><span class="line">    <span class="comment">// 返回中间值的下标</span></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="双指针分区算法"><a href="#双指针分区算法" class="headerlink" title="双指针分区算法"></a>双指针分区算法</h3><p>除了上述的分区算法外，还有一种双指针的分区算法更为常用：从 left 开始，遇到比基数大的数，记录其下标；再从 right 往前遍历，找到第一个比基数小的数，记录其下标；然后交换这两个数。继续遍历，直到 left 和 right 相遇。然后就和刚才的算法一样了，交换基数和中间值，并返回中间值的下标。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果区域内的数字少于 2 个，退出递归</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    quickSort(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    quickSort(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 取第一个数为基数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[start];</span><br><span class="line">    <span class="comment">// 从第二个数开始分区</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于基数的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;</span><br><span class="line">        <span class="comment">// 找到第一个小于基数的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) right--;</span><br><span class="line">        <span class="comment">// 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            exchange(arr, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span></span><br><span class="line">    <span class="keyword">if</span> (left == right &amp;&amp; arr[right] &gt; pivot) right--;</span><br><span class="line">    <span class="comment">// 将基数和轴交换</span></span><br><span class="line">    exchange(arr, start, right);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样地，我们需要在退出循环后，单独比较 left 和 right 的值。</p>
<p>从代码实现中可以分析出，快速排序是一种不稳定的排序算法，在分区过程中，相同数字的相对顺序可能会被修改。</p>
<h2 id="时间复杂度-amp-空间复杂度-1"><a href="#时间复杂度-amp-空间复杂度-1" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><p>快速排序的时间复杂度上文已经提到过，平均时间复杂度为 O(nlogn) ，最坏的时间复杂度为 O(n ^ 2)，空间复杂度与递归的层数有关，每层递归会生成一些临时变量，所以空间复杂度为 O(logn)  ~ O(n)，平均空间复杂度为 O(logn) 。</p>
<p>回到前文提到的那个问题，为什么说随机选择剩余数组中的一个元素作为基数的方案平均复杂度是最优的呢？要理清这个问题，我们先来看一下什么情况下快速排序算法的时间复杂度最高，一共有两种情况。</p>
<p>数组为正序或逆序</p>
<p>理想中的快速排序在第 k 轮遍历中，可以排好 2 ^ k−1 个基数。但我们发现，当数组原本为正序或逆序时，我们将第一个数作为基数的话，每轮分区后，都有一个区域是空的，也就是说数组中剩下的数字都被分到了同一个区域！这就导致了每一轮遍历只能排好一个基数。所以总的比较次数为 (n - 1) + (n - 2) + (n - 3) + … + 1 次，由等差数列求和公式可以计算出总的比较次数为 n(n - 1)/2 次，此时快速排序的时间复杂度达到了 O(n ^ 2) 级。</p>
<p>有的读者可能会疑惑，既然数组已经有序了，为什么还要再对其排序呢？这个操作看起来毫无意义。但事实可能让你大吃一惊，因为在实际工作中，这种重复排序的需求非常常见。</p>
<p>设想一个场景，前端程序员从第三方平台提供的接口中获取一列数据，并且产品部门要求前端必须保证这一列数据在展示给用户时是有序的。在测试环境下，前端程序员发现从第三方平台获取到的数据总是有序的，但为了保险起见，他还是不得不对收到的数据再次进行排序。因为第三方平台提供的数据是不可控的，他不能选择相信后台，否则万一哪天后台提供的数据变成了无序的，给用户展示数据时就会出现问题。于是这里就发生了重复排序，此时如果直接使用快速排序就可能出现排序速度很慢，拖慢程序性能的问题。</p>
<p>如何解决这样的问题呢？其实思路也很简单，只要我们每轮选择的基数不是剩余数组中最大或最小的值就可以了。具体方案有很多种，其中较常用的有三种。</p>
<p>快速排序的优化思路<br>第一种就是我们在前文中提到的，每轮选择基数时，从剩余的数组中随机选择一个数字作为基数。这样每轮都选到最大或最小值的概率就会变得很低了。所以我们才说用这种方式选择基数，其平均时间复杂度是最优的</p>
<p>第二种解决方案是在排序之前，先用洗牌算法将数组的原有顺序打乱，以防止原数组正序或逆序。</p>
<p>Java 已经将洗牌算法封装到了集合类中，即 Collections.shuffle() 函数。洗牌算法由 Ronald A.Fisher 和 Frank Yates 于 1938 年发明，思路是每次从未处理的数据中随机取出一个数字，然后把该数字放在数组中所有未处理数据的尾部。 Collections.shuffle() 函数源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUFFLE_THRESHOLD</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list, Random rnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; SHUFFLE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(list, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object arr[] = list.toArray();</span><br><span class="line">        <span class="comment">// Shuffle array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">        <span class="comment">// Dump array back into list</span></span><br><span class="line">        <span class="comment">// instead of using a raw type here, it&#x27;s possible to capture</span></span><br><span class="line">        <span class="comment">// the wildcard but it will require a call to a supplementary</span></span><br><span class="line">        <span class="comment">// private method</span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">it</span> <span class="operator">=</span> list.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.set(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// instead of using a raw type here, it&#x27;s possible to capture</span></span><br><span class="line">    <span class="comment">// the wildcard but it will require a call to a supplementary</span></span><br><span class="line">    <span class="comment">// private method</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">List</span> <span class="variable">l</span> <span class="operator">=</span> list;</span><br><span class="line">    l.set(i, l.set(j, l.get(i)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Object[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码中可以看出，对于数据量较小的列表（少于 5 个值），shuffle 函数直接通过列表的 set 方法进行洗牌，否则先将 list 转换为 array，再进行洗牌，以提高交换效率，洗牌完成后再将 array 转成 list 返回。</p>
<p>还有一种解决方案，既然数组重复排序的情况如此常见，那么我们可以在快速排序之前先对数组做个判断，如果已经有序则直接返回，如果是逆序则直接倒序即可。在 Java 内部封装的 Arrays.sort() 的源码中就采用了此解决方案。</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>核心思路是将两个有序的列表合并成一个有序的列表。</p>
<p>我们排序时用的都是无序数组，那么上哪里去找这两个有序的数组呢？</p>
<p>答案是 —— 自己拆分，我们可以把数组不断地拆成两份，直到只剩下一个数字时，这一个数字组成的数组我们就可以认为它是有序的。</p>
<p>然后通过上述合并有序列表的思路，将 1 个数字组成的有序数组合并成一个包含 2 个数字的有序数组，再将 2 个数字组成的有序数组合并成包含 4 个数字的有序数组…直到整个数组排序完成，这就是归并排序（Merge Sort）的思想。</p>
<p>为了减少在递归过程中不断开辟空间的问题，我们可以在归并排序之前，先开辟出一个临时空间，在递归过程中统一使用此空间进行归并即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 arr 的 [start, end] 区间归并排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] result)</span> &#123;</span><br><span class="line">    <span class="comment">// 只剩下一个数字，停止拆分</span></span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间</span></span><br><span class="line">    mergeSort(arr, start, middle, result);</span><br><span class="line">    <span class="comment">// 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间</span></span><br><span class="line">    mergeSort(arr, middle + <span class="number">1</span>, end, result);</span><br><span class="line">    <span class="comment">// 合并左右区域到 result 的 [start, end] 区间</span></span><br><span class="line">    merge(arr, start, end, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] result)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end1</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start2</span> <span class="operator">=</span> end1 + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 用来遍历数组的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> start2;</span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= end1 &amp;&amp; index2 &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[index1] &lt;= arr[index2]) &#123;</span><br><span class="line">            result[index1 + index2 - start2] = arr[index1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[index1 + index2 - start2] = arr[index2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余数字补到结果数组之后</span></span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= end1) &#123;</span><br><span class="line">        result[index1 + index2 - start2] = arr[index1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index2 &lt;= end) &#123;</span><br><span class="line">        result[index1 + index2 - start2] = arr[index2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        arr[start] = result[start++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原地归并排序？</p>
<p>现在的归并排序看起来仍”美中不足”，那就是仍然需要开辟额外的空间，能不能实现不开辟额外空间的归并排序呢？好像是可以做到的。在一些文章中，将这样的归并排序称之为 In-Place Merge Sort，直译为原地归并排序。</p>
<p>所谓的原地归并排序事实上并不存在，它打着归并排序的幌子，卖的是插入排序的思想，实际排序效率比归并排序低得多。</p>
<h2 id="时间复杂度-amp-空间复杂度-2"><a href="#时间复杂度-amp-空间复杂度-2" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><p>归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分 logn 次，每层执行的比较次数都约等于 n 次，所以时间复杂度是 O(nlogn)。</p>
<p>空间复杂度是 O(n)，主要占用空间的就是我们在排序前创建的长度为 n 的 result 数组。</p>
<p>分析归并的过程可知，归并排序是一种稳定的排序算法。其中，对算法稳定性非常重要的一行代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr[index1] &lt;= arr[index2]) &#123;</span><br><span class="line">    result[index1 + index2 - start2] = arr[index1++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们通过arr[index1] &lt;= arr[index2]来合并两个有序数组，保证了原数组中，相同的元素相对顺序不会变化，如果这里的比较条件写成了arr[index1] &lt; arr[index2]，则归并排序将变得不稳定。</p>
<p>总结起来，归并排序分成两步，一是拆分数组，二是合并数组，它是分治思想的典型应用。分治的意思是“分而治之”，分的时候体现了二分的思想，“一尺之棰，日取其半，logn 世竭”，治是一个滚雪球的过程，将 1 个数字组成的有序数组合并成一个包含 2 个数字的有序数组，再将 2 个数字组成的有序数组合并成包含 4 个数字的有序数组…如《活着》一书中的经典名句：“小鸡长大了就变成了鹅；鹅长大了，就变成了羊；羊再长大了，就变成了牛…”</p>
<p>由于性能较好，且排序稳定，归并排序应用非常广泛，Arrays.sort() 源码中的 TimSort就是归并排序的优化版。</p>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>O(n) 级的排序算法存在已久，但他们只能用于特定的场景。</p>
<p>计数排序就是一种时间复杂度为 O(n)  的排序算法，该算法于 1954 年由 Harold H. Seward 提出。在对一定范围内的整数排序时，它的复杂度为 O(n+k)（其中 k 是整数的范围大小）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 判空及防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="type">int</span>[] counting = <span class="keyword">new</span> <span class="title class_">int</span>[range];</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        counting[element - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录前面比自己小的数字的总数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preCounts</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前的数字比下一个数字小，累计到 preCounts 中</span></span><br><span class="line">        preCounts += counting[i];</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的起始下标位置。位置 = 前面比自己小的数字的总数。</span></span><br><span class="line">        counting[i] = preCounts - counting[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// counting[element - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[element - min]] = element;</span><br><span class="line">        <span class="comment">// 更新 counting[element - min]，指向此元素的下一个下标</span></span><br><span class="line">        counting[element - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倒序遍历的计数排序，性能更好。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="type">int</span>[] counting = <span class="keyword">new</span> <span class="title class_">int</span>[range];</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        counting[element - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个元素在结果数组中的最后一个下标位置 = 前面比自己小的数字的总数 + 自己的数量 - 1。我们将 counting[0] 先减去 1，后续 counting 直接累加即可</span></span><br><span class="line">    counting[<span class="number">0</span>]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的最后一个下标位置。位置 = 前面比自己小的数字的总数 + 自己的数量 - 1</span></span><br><span class="line">        <span class="comment">// 由于 counting[0] 已经减了 1，所以后续的减 1 可以省略。</span></span><br><span class="line">        counting[i] += counting[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="comment">// 从后往前遍历数组，通过 counting 中记录的下标位置，将 arr 中的元素放到 result 数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// counting[arr[i] - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[arr[i] - min]] = arr[i];</span><br><span class="line">        <span class="comment">// 更新 counting[arr[i] - min]，指向此元素的前一个下标</span></span><br><span class="line">        counting[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="时间复杂度-amp-空间复杂度-3"><a href="#时间复杂度-amp-空间复杂度-3" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><p>从计数排序的实现代码中，可以看到，每次遍历都是进行 n 次或者 k 次，所以计数排序的时间复杂度为 O(n+k) ，k 表示数据的范围大小。</p>
<p>用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 O(n+k) 。</p>
<p>需要注意的是，一般我们分析时间复杂度和空间复杂度时，常数项都是忽略不计的。但计数排序的常数项可能非常大，以至于我们无法忽略。</p>
<p>计数排序只适用于数据范围不大的场景。例如对考试成绩排序就非常适合计数排序，如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。</p>
<h2 id="计数排序与-O-nlogn-级排序算法的本质区别"><a href="#计数排序与-O-nlogn-级排序算法的本质区别" class="headerlink" title="计数排序与 O(nlogn)  级排序算法的本质区别"></a>计数排序与 O(nlogn)  级排序算法的本质区别</h2><p>计数排序凭什么能够突破 O(nlogn)  的下界呢？它和之前介绍的 O(nlogn)  级排序算法的本质区别是什么？</p>
<p>这个问题我们可以从决策树的角度和概率的角度来理解。</p>
<p>决策树<br>决策树是一棵完全二叉树，它可以反映比较排序算法中对所有元素的比较操作。</p>
<p>以包含三个整数的数组 [a,b,c] 为例，基于比较的排序算法的排序过程可以抽象为这样一棵 决策树：</p>
<p>这棵决策树上的每一个叶结点都对应了一种可能的排列，从根结点到任意一个叶结点之间的最短路径（也称为「简单路径」）的长度，表示的是完成对应排列的比较次数。所以从根结点到叶结点之间的最长简单路径的长度，就表示比较排序算法中最坏情况下的比较次数。</p>
<p>设决策树的高度为 h，叶结点的数量为 l，排序元素总数为 n 。</p>
<p>因为叶结点最多有 n! 个，所以我们可以得到：n! ≤ l，又因为一棵高度为 h 的二叉树，叶结点的数量最多为 2 ^ h，所以我们可以得到：n!≤l≤2 ^ h</p>
<p>对该式两边取对数，可得：h≥log(n!)</p>
<p>由斯特林（Stirling）近似公式，可知 lg(n!)=O(nlogn)</p>
<p>所以 h≥log(n!)=O(nlogn)</p>
<p>于是我们可以得出以下定理：</p>
<blockquote>
<p>《算法导论》定理 8.1：在最坏情况下，任何比较排序算法都需要做 O(nlogn)  次比较。</p>
</blockquote>
<p>由此我们还可以得到以下推论：</p>
<blockquote>
<p>《算法导论》推论 8.2：堆排序和归并排序都是渐进最优的比较排序算法。</p>
</blockquote>
<p>到这里我们就可以得出结论了，如果基于比较来进行排序，无论怎么优化都无法突破 O(nlogn)  的下界。计数排序和基于比较的排序算法相比，根本区别就在于：它不是基于比较的排序算法，而是利用了数字本身的属性来进行的排序。整个计数排序算法中没有出现任何一次比较。</p>
<p>概率<br>相信大家都玩过「猜数字」游戏：一方从 [1, 100] 中随机选取一个数字，另一方来猜。每次猜测都会得到「高了」或者「低了」的回答。怎样才能以最少的次数猜中呢？</p>
<p>答案很简单：二分。</p>
<p>二分算法能够保证每次都排除一半的数字。每次猜测不会出现惊喜（一次排除了多于一半的数字），也不会出现悲伤（一次只排除了少于一半的数字），因为答案的每一个分支都是等概率的，所以它在最差的情况下表现是最好的，猜测的一方在 logn 次以内必然能够猜中。</p>
<p>基于比较的排序算法与「猜数字」是类似的，每次比较，我们只能得到 a&gt;b 或者 a≤b 两种结果，如果我们把数组的全排列比作一块区域，那么每次比较都只能将这块区域分成两份，也就是说每次比较最多排除掉 1/2 的可能性。</p>
<p>再来看计数排序算法，计数排序时申请了长度为 k 的计数数组，在遍历每一个数字时，这个数字落在计数数组中的可能性共有 k 种，但通过数字本身的大小属性，我们可以「一次」把它放到正确的位置上。相当于一次排除了 (k−1)/k 种可能性。</p>
<p>这就是计数排序算法比基于比较的排序算法更快的根本原因。</p>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>想一下我们是怎么对日期进行排序的。这种利用多关键字进行排序的思想就是基数排序，和计数排序一样，这也是一种线性时间复杂度的排序算法。其中的每个关键字都被称作一个基数。</p>
<p>比如我们对 999,997,866,666 这四个数字进行基数排序，过程如下：</p>
<ul>
<li>先看第一位基数：6 最小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系。</li>
<li>再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系</li>
<li>再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999</li>
</ul>
<p>基数排序有两种实现方式。本例属于「最高位优先法」，简称 MSD (Most significant digital)，思路是从最高位开始，依次对基数进行排序。</p>
<p>与之对应的是「最低位优先法」，简称 LSD (Least significant digital)。思路是从最低位开始，依次对基数进行排序。使用 LSD 必须保证对基数进行排序的过程是稳定的。</p>
<p>通常来讲，LSD 比 MSD 更常用。以上述排序过程为例，因为使用的是 MSD，所以在第二步比较两个以 9 开头的数字时，其他基数开头的数字不得不放到一边。体现在计算机中，这里会产生很多临时变量。</p>
<p>但在采用 LSD 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 LSD 的基数排序更符合计算机的操作习惯。</p>
<p>基数排序最早是用在卡片排序机上的，一张卡片有 80 列，类似一个 80 位的整数。机器通过在卡片不同位置上穿孔表示当前基数的大小。卡片排序机的排序过程就是采用的 LSD 的基数排序。</p>
<p><img src="static/algorithms/sort5.gif" alt="Alt text"></p>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/sort-algorithms">排序算法图文学</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://LuoRongLuoRong.github.io">LuoRongLuoRong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://luorongluorong.github.io/2023/02/16/algorithms/sort/">https://luorongluorong.github.io/2023/02/16/algorithms/sort/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://LuoRongLuoRong.github.io" target="_blank">LuoRongLuoRong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a></div><div class="post_share"><div class="social-share" data-image="/static/algorithms/sort1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/16/source_codes/java_arrays_sort/" title="TODO_Java Arrays.sort() 源码分析"><img class="cover" src="/img/flag.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TODO_Java Arrays.sort() 源码分析</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/15/diaries/museum_exhibition_bottlicelli_to_van_gogh/" title="从波提切利到梵高——英国国家美术馆珍藏展"><img class="cover" src="/static/museums/museum_exhibition_bottlicelli_to_van_gogh_21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">从波提切利到梵高——英国国家美术馆珍藏展</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/16/source_codes/java_arrays_sort/" title="TODO_Java Arrays.sort() 源码分析"><img class="cover" src="/img/flag.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-16</div><div class="title">TODO_Java Arrays.sort() 源码分析</div></div></a></div><div><a href="/2023/02/18/algorithms/binary_gray_code/" title="格雷码"><img class="cover" src="/img/flag.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="title">格雷码</div></div></a></div><div><a href="/2023/01/15/algorithms/contest_record/" title="每周周赛复盘记录"><img class="cover" src="/img/flag.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">每周周赛复盘记录</div></div></a></div><div><a href="/2023/02/11/algorithms/dp_short/" title="动态规划总结及练习巩固"><img class="cover" src="/static/algorithms/dp_s1.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-11</div><div class="title">动态规划总结及练习巩固</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LuoRongLuoRong</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LuoRongLuoRong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LuoRongLuoRong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:luorongfamily@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">十大排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-n-2-%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">时间复杂度 O(n^2) 的排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-n-log-n-%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">时间复杂度 O(n log n) 的排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-n-%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">时间复杂度 O(n) 的排序算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">二元选择排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-amp-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时间复杂度 &amp; 空间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E4%B8%8E-O-n-2-%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-text">希尔排序与 O(n^2) 级排序算法的本质区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%A4%A7%E9%A1%B6%E5%A0%86-amp-%E8%B0%83%E6%95%B4%E5%A0%86"><span class="toc-text">构建大顶堆 &amp; 调整堆</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">分区算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-text">最简单的分区算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-text">双指针分区算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-amp-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-text">时间复杂度 &amp; 空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-amp-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-text">时间复杂度 &amp; 空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-amp-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-text">时间复杂度 &amp; 空间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E4%B8%8E-O-nlogn-%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-text">计数排序与 O(nlogn)  级排序算法的本质区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">桶排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/18/algorithms/binary_gray_code/" title="格雷码"><img src="/img/flag.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="格雷码"/></a><div class="content"><a class="title" href="/2023/02/18/algorithms/binary_gray_code/" title="格雷码">格雷码</a><time datetime="2023-02-18T11:21:41.000Z" title="发表于 2023-02-18 19:21:41">2023-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/18/practices/latex_math/" title="使用 LaTex 书写符号"><img src="/img/flag.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用 LaTex 书写符号"/></a><div class="content"><a class="title" href="/2023/02/18/practices/latex_math/" title="使用 LaTex 书写符号">使用 LaTex 书写符号</a><time datetime="2023-02-18T11:21:41.000Z" title="发表于 2023-02-18 19:21:41">2023-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/17/papers/FSE'22_AutoPruner_Transformer_Based_Call_Graph_Pruning/" title="【论文精读】AutoPruner, Transformer-Based Call Graph Pruning"><img src="/img/flag.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【论文精读】AutoPruner, Transformer-Based Call Graph Pruning"/></a><div class="content"><a class="title" href="/2023/02/17/papers/FSE'22_AutoPruner_Transformer_Based_Call_Graph_Pruning/" title="【论文精读】AutoPruner, Transformer-Based Call Graph Pruning">【论文精读】AutoPruner, Transformer-Based Call Graph Pruning</a><time datetime="2023-02-17T09:11:23.000Z" title="发表于 2023-02-17 17:11:23">2023-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/16/source_codes/java_arrays_sort/" title="TODO_Java Arrays.sort() 源码分析"><img src="/img/flag.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TODO_Java Arrays.sort() 源码分析"/></a><div class="content"><a class="title" href="/2023/02/16/source_codes/java_arrays_sort/" title="TODO_Java Arrays.sort() 源码分析">TODO_Java Arrays.sort() 源码分析</a><time datetime="2023-02-16T11:02:10.000Z" title="发表于 2023-02-16 19:02:10">2023-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/16/algorithms/sort/" title="TODO_十大排序算法"><img src="/static/algorithms/sort1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TODO_十大排序算法"/></a><div class="content"><a class="title" href="/2023/02/16/algorithms/sort/" title="TODO_十大排序算法">TODO_十大排序算法</a><time datetime="2023-02-16T01:59:11.000Z" title="发表于 2023-02-16 09:59:11">2023-02-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By LuoRongLuoRong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="❤,🧡,💛,💚,💙,💜,🤎,🖤,🤍,💖,💘,💝,💖" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>